
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model Specialty
 * 
 */
export type Specialty = $Result.DefaultSelection<Prisma.$SpecialtyPayload>
/**
 * Model Amenity
 * 
 */
export type Amenity = $Result.DefaultSelection<Prisma.$AmenityPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model UnitSpecialty
 * 
 */
export type UnitSpecialty = $Result.DefaultSelection<Prisma.$UnitSpecialtyPayload>
/**
 * Model UnitAmenity
 * 
 */
export type UnitAmenity = $Result.DefaultSelection<Prisma.$UnitAmenityPayload>
/**
 * Model UnitService
 * 
 */
export type UnitService = $Result.DefaultSelection<Prisma.$UnitServicePayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model BookingRule
 * 
 */
export type BookingRule = $Result.DefaultSelection<Prisma.$BookingRulePayload>
/**
 * Model BookingException
 * 
 */
export type BookingException = $Result.DefaultSelection<Prisma.$BookingExceptionPayload>
/**
 * Model UnitAvailabilityRule
 * 
 */
export type UnitAvailabilityRule = $Result.DefaultSelection<Prisma.$UnitAvailabilityRulePayload>
/**
 * Model UnitAvailabilityException
 * 
 */
export type UnitAvailabilityException = $Result.DefaultSelection<Prisma.$UnitAvailabilityExceptionPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Discount
 * 
 */
export type Discount = $Result.DefaultSelection<Prisma.$DiscountPayload>
/**
 * Model CouponRedemption
 * 
 */
export type CouponRedemption = $Result.DefaultSelection<Prisma.$CouponRedemptionPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationTemplate
 * 
 */
export type NotificationTemplate = $Result.DefaultSelection<Prisma.$NotificationTemplatePayload>
/**
 * Model NotificationPreference
 * 
 */
export type NotificationPreference = $Result.DefaultSelection<Prisma.$NotificationPreferencePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ServiceType: {
  local: 'local',
  home: 'home',
  both: 'both'
};

export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType]


export const BookingStatus: {
  confirmed: 'confirmed',
  cancelled: 'cancelled',
  completed: 'completed',
  no_show: 'no_show'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const BookingRuleType: {
  weekly: 'weekly',
  specific_date: 'specific_date'
};

export type BookingRuleType = (typeof BookingRuleType)[keyof typeof BookingRuleType]


export const BookingExceptionType: {
  block: 'block',
  override: 'override'
};

export type BookingExceptionType = (typeof BookingExceptionType)[keyof typeof BookingExceptionType]


export const UnitAvailabilityRuleType: {
  weekly: 'weekly',
  specific_date: 'specific_date'
};

export type UnitAvailabilityRuleType = (typeof UnitAvailabilityRuleType)[keyof typeof UnitAvailabilityRuleType]


export const UnitAvailabilityExceptionType: {
  block: 'block',
  override: 'override'
};

export type UnitAvailabilityExceptionType = (typeof UnitAvailabilityExceptionType)[keyof typeof UnitAvailabilityExceptionType]


export const RenewalInterval: {
  monthly: 'monthly',
  yearly: 'yearly',
  custom: 'custom'
};

export type RenewalInterval = (typeof RenewalInterval)[keyof typeof RenewalInterval]


export const SubscriptionStatus: {
  incomplete: 'incomplete',
  incomplete_expired: 'incomplete_expired',
  trialing: 'trialing',
  active: 'active',
  past_due: 'past_due',
  unpaid: 'unpaid',
  canceled: 'canceled',
  expired: 'expired'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const InvoiceStatus: {
  open: 'open',
  paid: 'paid',
  uncollectible: 'uncollectible',
  void: 'void'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const DiscountType: {
  percentage: 'percentage',
  fixed: 'fixed',
  free_period: 'free_period'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]


export const DiscountDuration: {
  once: 'once',
  repeating: 'repeating',
  forever: 'forever'
};

export type DiscountDuration = (typeof DiscountDuration)[keyof typeof DiscountDuration]


export const NotificationChannel: {
  email: 'email',
  whatsapp: 'whatsapp',
  push: 'push'
};

export type NotificationChannel = (typeof NotificationChannel)[keyof typeof NotificationChannel]


export const NotificationStatus: {
  pending: 'pending',
  sent: 'sent',
  failed: 'failed',
  delivered: 'delivered'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const NotificationPriority: {
  low: 'low',
  normal: 'normal',
  high: 'high'
};

export type NotificationPriority = (typeof NotificationPriority)[keyof typeof NotificationPriority]


export const NotificationTemplateChannel: {
  email: 'email',
  whatsapp: 'whatsapp',
  push: 'push'
};

export type NotificationTemplateChannel = (typeof NotificationTemplateChannel)[keyof typeof NotificationTemplateChannel]


export const NotificationPreferenceCategory: {
  transactional: 'transactional',
  marketing: 'marketing',
  security: 'security',
  billing: 'billing'
};

export type NotificationPreferenceCategory = (typeof NotificationPreferenceCategory)[keyof typeof NotificationPreferenceCategory]

}

export type ServiceType = $Enums.ServiceType

export const ServiceType: typeof $Enums.ServiceType

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type BookingRuleType = $Enums.BookingRuleType

export const BookingRuleType: typeof $Enums.BookingRuleType

export type BookingExceptionType = $Enums.BookingExceptionType

export const BookingExceptionType: typeof $Enums.BookingExceptionType

export type UnitAvailabilityRuleType = $Enums.UnitAvailabilityRuleType

export const UnitAvailabilityRuleType: typeof $Enums.UnitAvailabilityRuleType

export type UnitAvailabilityExceptionType = $Enums.UnitAvailabilityExceptionType

export const UnitAvailabilityExceptionType: typeof $Enums.UnitAvailabilityExceptionType

export type RenewalInterval = $Enums.RenewalInterval

export const RenewalInterval: typeof $Enums.RenewalInterval

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

export type DiscountDuration = $Enums.DiscountDuration

export const DiscountDuration: typeof $Enums.DiscountDuration

export type NotificationChannel = $Enums.NotificationChannel

export const NotificationChannel: typeof $Enums.NotificationChannel

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type NotificationPriority = $Enums.NotificationPriority

export const NotificationPriority: typeof $Enums.NotificationPriority

export type NotificationTemplateChannel = $Enums.NotificationTemplateChannel

export const NotificationTemplateChannel: typeof $Enums.NotificationTemplateChannel

export type NotificationPreferenceCategory = $Enums.NotificationPreferenceCategory

export const NotificationPreferenceCategory: typeof $Enums.NotificationPreferenceCategory

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.specialty`: Exposes CRUD operations for the **Specialty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Specialties
    * const specialties = await prisma.specialty.findMany()
    * ```
    */
  get specialty(): Prisma.SpecialtyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenity`: Exposes CRUD operations for the **Amenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amenities
    * const amenities = await prisma.amenity.findMany()
    * ```
    */
  get amenity(): Prisma.AmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitSpecialty`: Exposes CRUD operations for the **UnitSpecialty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitSpecialties
    * const unitSpecialties = await prisma.unitSpecialty.findMany()
    * ```
    */
  get unitSpecialty(): Prisma.UnitSpecialtyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitAmenity`: Exposes CRUD operations for the **UnitAmenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitAmenities
    * const unitAmenities = await prisma.unitAmenity.findMany()
    * ```
    */
  get unitAmenity(): Prisma.UnitAmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitService`: Exposes CRUD operations for the **UnitService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitServices
    * const unitServices = await prisma.unitService.findMany()
    * ```
    */
  get unitService(): Prisma.UnitServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingRule`: Exposes CRUD operations for the **BookingRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingRules
    * const bookingRules = await prisma.bookingRule.findMany()
    * ```
    */
  get bookingRule(): Prisma.BookingRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingException`: Exposes CRUD operations for the **BookingException** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingExceptions
    * const bookingExceptions = await prisma.bookingException.findMany()
    * ```
    */
  get bookingException(): Prisma.BookingExceptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitAvailabilityRule`: Exposes CRUD operations for the **UnitAvailabilityRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitAvailabilityRules
    * const unitAvailabilityRules = await prisma.unitAvailabilityRule.findMany()
    * ```
    */
  get unitAvailabilityRule(): Prisma.UnitAvailabilityRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitAvailabilityException`: Exposes CRUD operations for the **UnitAvailabilityException** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitAvailabilityExceptions
    * const unitAvailabilityExceptions = await prisma.unitAvailabilityException.findMany()
    * ```
    */
  get unitAvailabilityException(): Prisma.UnitAvailabilityExceptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discount`: Exposes CRUD operations for the **Discount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discounts
    * const discounts = await prisma.discount.findMany()
    * ```
    */
  get discount(): Prisma.DiscountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.couponRedemption`: Exposes CRUD operations for the **CouponRedemption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CouponRedemptions
    * const couponRedemptions = await prisma.couponRedemption.findMany()
    * ```
    */
  get couponRedemption(): Prisma.CouponRedemptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationTemplate`: Exposes CRUD operations for the **NotificationTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationTemplates
    * const notificationTemplates = await prisma.notificationTemplate.findMany()
    * ```
    */
  get notificationTemplate(): Prisma.NotificationTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationPreference`: Exposes CRUD operations for the **NotificationPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationPreferences
    * const notificationPreferences = await prisma.notificationPreference.findMany()
    * ```
    */
  get notificationPreference(): Prisma.NotificationPreferenceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.1.0
   * Query Engine version: ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Organization: 'Organization',
    Unit: 'Unit',
    Specialty: 'Specialty',
    Amenity: 'Amenity',
    Service: 'Service',
    UnitSpecialty: 'UnitSpecialty',
    UnitAmenity: 'UnitAmenity',
    UnitService: 'UnitService',
    Booking: 'Booking',
    Customer: 'Customer',
    BookingRule: 'BookingRule',
    BookingException: 'BookingException',
    UnitAvailabilityRule: 'UnitAvailabilityRule',
    UnitAvailabilityException: 'UnitAvailabilityException',
    Plan: 'Plan',
    Subscription: 'Subscription',
    Invoice: 'Invoice',
    Discount: 'Discount',
    CouponRedemption: 'CouponRedemption',
    Notification: 'Notification',
    NotificationTemplate: 'NotificationTemplate',
    NotificationPreference: 'NotificationPreference'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "organization" | "unit" | "specialty" | "amenity" | "service" | "unitSpecialty" | "unitAmenity" | "unitService" | "booking" | "customer" | "bookingRule" | "bookingException" | "unitAvailabilityRule" | "unitAvailabilityException" | "plan" | "subscription" | "invoice" | "discount" | "couponRedemption" | "notification" | "notificationTemplate" | "notificationPreference"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      Specialty: {
        payload: Prisma.$SpecialtyPayload<ExtArgs>
        fields: Prisma.SpecialtyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecialtyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecialtyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          findFirst: {
            args: Prisma.SpecialtyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecialtyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          findMany: {
            args: Prisma.SpecialtyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>[]
          }
          create: {
            args: Prisma.SpecialtyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          createMany: {
            args: Prisma.SpecialtyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecialtyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>[]
          }
          delete: {
            args: Prisma.SpecialtyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          update: {
            args: Prisma.SpecialtyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          deleteMany: {
            args: Prisma.SpecialtyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecialtyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpecialtyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>[]
          }
          upsert: {
            args: Prisma.SpecialtyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          aggregate: {
            args: Prisma.SpecialtyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecialty>
          }
          groupBy: {
            args: Prisma.SpecialtyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecialtyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecialtyCountArgs<ExtArgs>
            result: $Utils.Optional<SpecialtyCountAggregateOutputType> | number
          }
        }
      }
      Amenity: {
        payload: Prisma.$AmenityPayload<ExtArgs>
        fields: Prisma.AmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findFirst: {
            args: Prisma.AmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findMany: {
            args: Prisma.AmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          create: {
            args: Prisma.AmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          createMany: {
            args: Prisma.AmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          delete: {
            args: Prisma.AmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          update: {
            args: Prisma.AmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          deleteMany: {
            args: Prisma.AmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          upsert: {
            args: Prisma.AmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          aggregate: {
            args: Prisma.AmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenity>
          }
          groupBy: {
            args: Prisma.AmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenityCountArgs<ExtArgs>
            result: $Utils.Optional<AmenityCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      UnitSpecialty: {
        payload: Prisma.$UnitSpecialtyPayload<ExtArgs>
        fields: Prisma.UnitSpecialtyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitSpecialtyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitSpecialtyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitSpecialtyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitSpecialtyPayload>
          }
          findFirst: {
            args: Prisma.UnitSpecialtyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitSpecialtyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitSpecialtyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitSpecialtyPayload>
          }
          findMany: {
            args: Prisma.UnitSpecialtyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitSpecialtyPayload>[]
          }
          create: {
            args: Prisma.UnitSpecialtyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitSpecialtyPayload>
          }
          createMany: {
            args: Prisma.UnitSpecialtyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitSpecialtyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitSpecialtyPayload>[]
          }
          delete: {
            args: Prisma.UnitSpecialtyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitSpecialtyPayload>
          }
          update: {
            args: Prisma.UnitSpecialtyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitSpecialtyPayload>
          }
          deleteMany: {
            args: Prisma.UnitSpecialtyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitSpecialtyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitSpecialtyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitSpecialtyPayload>[]
          }
          upsert: {
            args: Prisma.UnitSpecialtyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitSpecialtyPayload>
          }
          aggregate: {
            args: Prisma.UnitSpecialtyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitSpecialty>
          }
          groupBy: {
            args: Prisma.UnitSpecialtyGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitSpecialtyGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitSpecialtyCountArgs<ExtArgs>
            result: $Utils.Optional<UnitSpecialtyCountAggregateOutputType> | number
          }
        }
      }
      UnitAmenity: {
        payload: Prisma.$UnitAmenityPayload<ExtArgs>
        fields: Prisma.UnitAmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitAmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitAmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAmenityPayload>
          }
          findFirst: {
            args: Prisma.UnitAmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitAmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAmenityPayload>
          }
          findMany: {
            args: Prisma.UnitAmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAmenityPayload>[]
          }
          create: {
            args: Prisma.UnitAmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAmenityPayload>
          }
          createMany: {
            args: Prisma.UnitAmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitAmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAmenityPayload>[]
          }
          delete: {
            args: Prisma.UnitAmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAmenityPayload>
          }
          update: {
            args: Prisma.UnitAmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAmenityPayload>
          }
          deleteMany: {
            args: Prisma.UnitAmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitAmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitAmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAmenityPayload>[]
          }
          upsert: {
            args: Prisma.UnitAmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAmenityPayload>
          }
          aggregate: {
            args: Prisma.UnitAmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitAmenity>
          }
          groupBy: {
            args: Prisma.UnitAmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitAmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitAmenityCountArgs<ExtArgs>
            result: $Utils.Optional<UnitAmenityCountAggregateOutputType> | number
          }
        }
      }
      UnitService: {
        payload: Prisma.$UnitServicePayload<ExtArgs>
        fields: Prisma.UnitServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServicePayload>
          }
          findFirst: {
            args: Prisma.UnitServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServicePayload>
          }
          findMany: {
            args: Prisma.UnitServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServicePayload>[]
          }
          create: {
            args: Prisma.UnitServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServicePayload>
          }
          createMany: {
            args: Prisma.UnitServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServicePayload>[]
          }
          delete: {
            args: Prisma.UnitServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServicePayload>
          }
          update: {
            args: Prisma.UnitServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServicePayload>
          }
          deleteMany: {
            args: Prisma.UnitServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServicePayload>[]
          }
          upsert: {
            args: Prisma.UnitServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitServicePayload>
          }
          aggregate: {
            args: Prisma.UnitServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitService>
          }
          groupBy: {
            args: Prisma.UnitServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitServiceCountArgs<ExtArgs>
            result: $Utils.Optional<UnitServiceCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      BookingRule: {
        payload: Prisma.$BookingRulePayload<ExtArgs>
        fields: Prisma.BookingRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRulePayload>
          }
          findFirst: {
            args: Prisma.BookingRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRulePayload>
          }
          findMany: {
            args: Prisma.BookingRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRulePayload>[]
          }
          create: {
            args: Prisma.BookingRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRulePayload>
          }
          createMany: {
            args: Prisma.BookingRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRulePayload>[]
          }
          delete: {
            args: Prisma.BookingRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRulePayload>
          }
          update: {
            args: Prisma.BookingRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRulePayload>
          }
          deleteMany: {
            args: Prisma.BookingRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRulePayload>[]
          }
          upsert: {
            args: Prisma.BookingRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRulePayload>
          }
          aggregate: {
            args: Prisma.BookingRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingRule>
          }
          groupBy: {
            args: Prisma.BookingRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingRuleCountArgs<ExtArgs>
            result: $Utils.Optional<BookingRuleCountAggregateOutputType> | number
          }
        }
      }
      BookingException: {
        payload: Prisma.$BookingExceptionPayload<ExtArgs>
        fields: Prisma.BookingExceptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingExceptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExceptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingExceptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExceptionPayload>
          }
          findFirst: {
            args: Prisma.BookingExceptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExceptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingExceptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExceptionPayload>
          }
          findMany: {
            args: Prisma.BookingExceptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExceptionPayload>[]
          }
          create: {
            args: Prisma.BookingExceptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExceptionPayload>
          }
          createMany: {
            args: Prisma.BookingExceptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingExceptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExceptionPayload>[]
          }
          delete: {
            args: Prisma.BookingExceptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExceptionPayload>
          }
          update: {
            args: Prisma.BookingExceptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExceptionPayload>
          }
          deleteMany: {
            args: Prisma.BookingExceptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingExceptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingExceptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExceptionPayload>[]
          }
          upsert: {
            args: Prisma.BookingExceptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingExceptionPayload>
          }
          aggregate: {
            args: Prisma.BookingExceptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingException>
          }
          groupBy: {
            args: Prisma.BookingExceptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingExceptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingExceptionCountArgs<ExtArgs>
            result: $Utils.Optional<BookingExceptionCountAggregateOutputType> | number
          }
        }
      }
      UnitAvailabilityRule: {
        payload: Prisma.$UnitAvailabilityRulePayload<ExtArgs>
        fields: Prisma.UnitAvailabilityRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitAvailabilityRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitAvailabilityRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityRulePayload>
          }
          findFirst: {
            args: Prisma.UnitAvailabilityRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitAvailabilityRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityRulePayload>
          }
          findMany: {
            args: Prisma.UnitAvailabilityRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityRulePayload>[]
          }
          create: {
            args: Prisma.UnitAvailabilityRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityRulePayload>
          }
          createMany: {
            args: Prisma.UnitAvailabilityRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitAvailabilityRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityRulePayload>[]
          }
          delete: {
            args: Prisma.UnitAvailabilityRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityRulePayload>
          }
          update: {
            args: Prisma.UnitAvailabilityRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityRulePayload>
          }
          deleteMany: {
            args: Prisma.UnitAvailabilityRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitAvailabilityRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitAvailabilityRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityRulePayload>[]
          }
          upsert: {
            args: Prisma.UnitAvailabilityRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityRulePayload>
          }
          aggregate: {
            args: Prisma.UnitAvailabilityRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitAvailabilityRule>
          }
          groupBy: {
            args: Prisma.UnitAvailabilityRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitAvailabilityRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitAvailabilityRuleCountArgs<ExtArgs>
            result: $Utils.Optional<UnitAvailabilityRuleCountAggregateOutputType> | number
          }
        }
      }
      UnitAvailabilityException: {
        payload: Prisma.$UnitAvailabilityExceptionPayload<ExtArgs>
        fields: Prisma.UnitAvailabilityExceptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitAvailabilityExceptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityExceptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitAvailabilityExceptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityExceptionPayload>
          }
          findFirst: {
            args: Prisma.UnitAvailabilityExceptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityExceptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitAvailabilityExceptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityExceptionPayload>
          }
          findMany: {
            args: Prisma.UnitAvailabilityExceptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityExceptionPayload>[]
          }
          create: {
            args: Prisma.UnitAvailabilityExceptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityExceptionPayload>
          }
          createMany: {
            args: Prisma.UnitAvailabilityExceptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitAvailabilityExceptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityExceptionPayload>[]
          }
          delete: {
            args: Prisma.UnitAvailabilityExceptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityExceptionPayload>
          }
          update: {
            args: Prisma.UnitAvailabilityExceptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityExceptionPayload>
          }
          deleteMany: {
            args: Prisma.UnitAvailabilityExceptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitAvailabilityExceptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitAvailabilityExceptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityExceptionPayload>[]
          }
          upsert: {
            args: Prisma.UnitAvailabilityExceptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitAvailabilityExceptionPayload>
          }
          aggregate: {
            args: Prisma.UnitAvailabilityExceptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitAvailabilityException>
          }
          groupBy: {
            args: Prisma.UnitAvailabilityExceptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitAvailabilityExceptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitAvailabilityExceptionCountArgs<ExtArgs>
            result: $Utils.Optional<UnitAvailabilityExceptionCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Discount: {
        payload: Prisma.$DiscountPayload<ExtArgs>
        fields: Prisma.DiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findFirst: {
            args: Prisma.DiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findMany: {
            args: Prisma.DiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          create: {
            args: Prisma.DiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          createMany: {
            args: Prisma.DiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          delete: {
            args: Prisma.DiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          update: {
            args: Prisma.DiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          deleteMany: {
            args: Prisma.DiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          upsert: {
            args: Prisma.DiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          aggregate: {
            args: Prisma.DiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscount>
          }
          groupBy: {
            args: Prisma.DiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscountCountArgs<ExtArgs>
            result: $Utils.Optional<DiscountCountAggregateOutputType> | number
          }
        }
      }
      CouponRedemption: {
        payload: Prisma.$CouponRedemptionPayload<ExtArgs>
        fields: Prisma.CouponRedemptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponRedemptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponRedemptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          findFirst: {
            args: Prisma.CouponRedemptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponRedemptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          findMany: {
            args: Prisma.CouponRedemptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>[]
          }
          create: {
            args: Prisma.CouponRedemptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          createMany: {
            args: Prisma.CouponRedemptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponRedemptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>[]
          }
          delete: {
            args: Prisma.CouponRedemptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          update: {
            args: Prisma.CouponRedemptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          deleteMany: {
            args: Prisma.CouponRedemptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponRedemptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CouponRedemptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>[]
          }
          upsert: {
            args: Prisma.CouponRedemptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          aggregate: {
            args: Prisma.CouponRedemptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCouponRedemption>
          }
          groupBy: {
            args: Prisma.CouponRedemptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponRedemptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponRedemptionCountArgs<ExtArgs>
            result: $Utils.Optional<CouponRedemptionCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationTemplate: {
        payload: Prisma.$NotificationTemplatePayload<ExtArgs>
        fields: Prisma.NotificationTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          findFirst: {
            args: Prisma.NotificationTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          findMany: {
            args: Prisma.NotificationTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
          }
          create: {
            args: Prisma.NotificationTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          createMany: {
            args: Prisma.NotificationTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
          }
          delete: {
            args: Prisma.NotificationTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          update: {
            args: Prisma.NotificationTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          deleteMany: {
            args: Prisma.NotificationTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
          }
          upsert: {
            args: Prisma.NotificationTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          aggregate: {
            args: Prisma.NotificationTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationTemplate>
          }
          groupBy: {
            args: Prisma.NotificationTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationTemplateCountAggregateOutputType> | number
          }
        }
      }
      NotificationPreference: {
        payload: Prisma.$NotificationPreferencePayload<ExtArgs>
        fields: Prisma.NotificationPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findFirst: {
            args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          findMany: {
            args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          create: {
            args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          createMany: {
            args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          delete: {
            args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          update: {
            args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          deleteMany: {
            args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
          }
          upsert: {
            args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
          }
          aggregate: {
            args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationPreference>
          }
          groupBy: {
            args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationPreferenceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    organization?: OrganizationOmit
    unit?: UnitOmit
    specialty?: SpecialtyOmit
    amenity?: AmenityOmit
    service?: ServiceOmit
    unitSpecialty?: UnitSpecialtyOmit
    unitAmenity?: UnitAmenityOmit
    unitService?: UnitServiceOmit
    booking?: BookingOmit
    customer?: CustomerOmit
    bookingRule?: BookingRuleOmit
    bookingException?: BookingExceptionOmit
    unitAvailabilityRule?: UnitAvailabilityRuleOmit
    unitAvailabilityException?: UnitAvailabilityExceptionOmit
    plan?: PlanOmit
    subscription?: SubscriptionOmit
    invoice?: InvoiceOmit
    discount?: DiscountOmit
    couponRedemption?: CouponRedemptionOmit
    notification?: NotificationOmit
    notificationTemplate?: NotificationTemplateOmit
    notificationPreference?: NotificationPreferenceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    bookings_as_owner: number
    bookings_as_client: number
    booking_rules: number
    booking_exceptions: number
    subscriptions: number
    invoices: number
    coupon_redemptions: number
    notifications: number
    notification_prefs: number
    customer_profiles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings_as_owner?: boolean | UserCountOutputTypeCountBookings_as_ownerArgs
    bookings_as_client?: boolean | UserCountOutputTypeCountBookings_as_clientArgs
    booking_rules?: boolean | UserCountOutputTypeCountBooking_rulesArgs
    booking_exceptions?: boolean | UserCountOutputTypeCountBooking_exceptionsArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
    coupon_redemptions?: boolean | UserCountOutputTypeCountCoupon_redemptionsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    notification_prefs?: boolean | UserCountOutputTypeCountNotification_prefsArgs
    customer_profiles?: boolean | UserCountOutputTypeCountCustomer_profilesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookings_as_ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookings_as_clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBooking_rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRuleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBooking_exceptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingExceptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoupon_redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponRedemptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotification_prefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomer_profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    units: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    units?: boolean | OrganizationCountOutputTypeCountUnitsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    unit_specialties: number
    unit_services: number
    unit_amenities: number
    unit_availability_rules: number
    unit_availability_exceptions: number
    bookings: number
    customers: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit_specialties?: boolean | UnitCountOutputTypeCountUnit_specialtiesArgs
    unit_services?: boolean | UnitCountOutputTypeCountUnit_servicesArgs
    unit_amenities?: boolean | UnitCountOutputTypeCountUnit_amenitiesArgs
    unit_availability_rules?: boolean | UnitCountOutputTypeCountUnit_availability_rulesArgs
    unit_availability_exceptions?: boolean | UnitCountOutputTypeCountUnit_availability_exceptionsArgs
    bookings?: boolean | UnitCountOutputTypeCountBookingsArgs
    customers?: boolean | UnitCountOutputTypeCountCustomersArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountUnit_specialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitSpecialtyWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountUnit_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitServiceWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountUnit_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitAmenityWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountUnit_availability_rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitAvailabilityRuleWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountUnit_availability_exceptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitAvailabilityExceptionWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }


  /**
   * Count Type SpecialtyCountOutputType
   */

  export type SpecialtyCountOutputType = {
    services: number
    unit_specialties: number
  }

  export type SpecialtyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | SpecialtyCountOutputTypeCountServicesArgs
    unit_specialties?: boolean | SpecialtyCountOutputTypeCountUnit_specialtiesArgs
  }

  // Custom InputTypes
  /**
   * SpecialtyCountOutputType without action
   */
  export type SpecialtyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialtyCountOutputType
     */
    select?: SpecialtyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpecialtyCountOutputType without action
   */
  export type SpecialtyCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * SpecialtyCountOutputType without action
   */
  export type SpecialtyCountOutputTypeCountUnit_specialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitSpecialtyWhereInput
  }


  /**
   * Count Type AmenityCountOutputType
   */

  export type AmenityCountOutputType = {
    unit_amenities: number
  }

  export type AmenityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit_amenities?: boolean | AmenityCountOutputTypeCountUnit_amenitiesArgs
  }

  // Custom InputTypes
  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityCountOutputType
     */
    select?: AmenityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeCountUnit_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitAmenityWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    unit_services: number
    bookings: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit_services?: boolean | ServiceCountOutputTypeCountUnit_servicesArgs
    bookings?: boolean | ServiceCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountUnit_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    subscriptions: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | PlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    invoices: number
    coupon_redemptions: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | SubscriptionCountOutputTypeCountInvoicesArgs
    coupon_redemptions?: boolean | SubscriptionCountOutputTypeCountCoupon_redemptionsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountCoupon_redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponRedemptionWhereInput
  }


  /**
   * Count Type DiscountCountOutputType
   */

  export type DiscountCountOutputType = {
    subscriptions: number
  }

  export type DiscountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | DiscountCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * DiscountCountOutputType without action
   */
  export type DiscountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountCountOutputType
     */
    select?: DiscountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiscountCountOutputType without action
   */
  export type DiscountCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type NotificationTemplateCountOutputType
   */

  export type NotificationTemplateCountOutputType = {
    notifications: number
  }

  export type NotificationTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | NotificationTemplateCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * NotificationTemplateCountOutputType without action
   */
  export type NotificationTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplateCountOutputType
     */
    select?: NotificationTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationTemplateCountOutputType without action
   */
  export type NotificationTemplateCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    provider_id: string | null
    photo_url: string | null
    onboarding_completed: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    provider_id: string | null
    photo_url: string | null
    onboarding_completed: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    provider_id: number
    photo_url: number
    onboarding_completed: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    provider_id?: true
    photo_url?: true
    onboarding_completed?: true
    created_at?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    provider_id?: true
    photo_url?: true
    onboarding_completed?: true
    created_at?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    provider_id?: true
    photo_url?: true
    onboarding_completed?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url: string | null
    onboarding_completed: boolean
    created_at: Date
    updated_at: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    provider_id?: boolean
    photo_url?: boolean
    onboarding_completed?: boolean
    created_at?: boolean
    updated_at?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
    bookings_as_owner?: boolean | User$bookings_as_ownerArgs<ExtArgs>
    bookings_as_client?: boolean | User$bookings_as_clientArgs<ExtArgs>
    booking_rules?: boolean | User$booking_rulesArgs<ExtArgs>
    booking_exceptions?: boolean | User$booking_exceptionsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    coupon_redemptions?: boolean | User$coupon_redemptionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    notification_prefs?: boolean | User$notification_prefsArgs<ExtArgs>
    customer_profiles?: boolean | User$customer_profilesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    provider_id?: boolean
    photo_url?: boolean
    onboarding_completed?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    provider_id?: boolean
    photo_url?: boolean
    onboarding_completed?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    provider_id?: boolean
    photo_url?: boolean
    onboarding_completed?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "provider_id" | "photo_url" | "onboarding_completed" | "created_at" | "updated_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
    bookings_as_owner?: boolean | User$bookings_as_ownerArgs<ExtArgs>
    bookings_as_client?: boolean | User$bookings_as_clientArgs<ExtArgs>
    booking_rules?: boolean | User$booking_rulesArgs<ExtArgs>
    booking_exceptions?: boolean | User$booking_exceptionsArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    coupon_redemptions?: boolean | User$coupon_redemptionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    notification_prefs?: boolean | User$notification_prefsArgs<ExtArgs>
    customer_profiles?: boolean | User$customer_profilesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      bookings_as_owner: Prisma.$BookingPayload<ExtArgs>[]
      bookings_as_client: Prisma.$BookingPayload<ExtArgs>[]
      booking_rules: Prisma.$BookingRulePayload<ExtArgs>[]
      booking_exceptions: Prisma.$BookingExceptionPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      coupon_redemptions: Prisma.$CouponRedemptionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      notification_prefs: Prisma.$NotificationPreferencePayload<ExtArgs>[]
      customer_profiles: Prisma.$CustomerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      provider_id: string
      photo_url: string | null
      onboarding_completed: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends User$organizationArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bookings_as_owner<T extends User$bookings_as_ownerArgs<ExtArgs> = {}>(args?: Subset<T, User$bookings_as_ownerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings_as_client<T extends User$bookings_as_clientArgs<ExtArgs> = {}>(args?: Subset<T, User$bookings_as_clientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    booking_rules<T extends User$booking_rulesArgs<ExtArgs> = {}>(args?: Subset<T, User$booking_rulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    booking_exceptions<T extends User$booking_exceptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$booking_exceptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingExceptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends User$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coupon_redemptions<T extends User$coupon_redemptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$coupon_redemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification_prefs<T extends User$notification_prefsArgs<ExtArgs> = {}>(args?: Subset<T, User$notification_prefsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customer_profiles<T extends User$customer_profilesArgs<ExtArgs> = {}>(args?: Subset<T, User$customer_profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly provider_id: FieldRef<"User", 'String'>
    readonly photo_url: FieldRef<"User", 'String'>
    readonly onboarding_completed: FieldRef<"User", 'Boolean'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.organization
   */
  export type User$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * User.bookings_as_owner
   */
  export type User$bookings_as_ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.bookings_as_client
   */
  export type User$bookings_as_clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.booking_rules
   */
  export type User$booking_rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRule
     */
    select?: BookingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRule
     */
    omit?: BookingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRuleInclude<ExtArgs> | null
    where?: BookingRuleWhereInput
    orderBy?: BookingRuleOrderByWithRelationInput | BookingRuleOrderByWithRelationInput[]
    cursor?: BookingRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingRuleScalarFieldEnum | BookingRuleScalarFieldEnum[]
  }

  /**
   * User.booking_exceptions
   */
  export type User$booking_exceptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingException
     */
    select?: BookingExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingException
     */
    omit?: BookingExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExceptionInclude<ExtArgs> | null
    where?: BookingExceptionWhereInput
    orderBy?: BookingExceptionOrderByWithRelationInput | BookingExceptionOrderByWithRelationInput[]
    cursor?: BookingExceptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingExceptionScalarFieldEnum | BookingExceptionScalarFieldEnum[]
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * User.invoices
   */
  export type User$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.coupon_redemptions
   */
  export type User$coupon_redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouponRedemption
     */
    omit?: CouponRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    where?: CouponRedemptionWhereInput
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    cursor?: CouponRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.notification_prefs
   */
  export type User$notification_prefsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    cursor?: NotificationPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * User.customer_profiles
   */
  export type User$customer_profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    owner_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    owner_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    owner_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    owner_id?: true
    created_at?: true
    updated_at?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    owner_id?: true
    created_at?: true
    updated_at?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    owner_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    owner_id: string
    created_at: Date
    updated_at: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    owner_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    units?: boolean | Organization$unitsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    owner_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    owner_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    owner_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "owner_id" | "created_at" | "updated_at", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    units?: boolean | Organization$unitsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      units: Prisma.$UnitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      owner_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    units<T extends Organization$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly owner_id: FieldRef<"Organization", 'String'>
    readonly created_at: FieldRef<"Organization", 'DateTime'>
    readonly updated_at: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.units
   */
  export type Organization$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitMinAggregateOutputType = {
    id: string | null
    organization_id: string | null
    name: string | null
    brand_color: string | null
    logo: string | null
    is_active: boolean | null
    whatsapp: string | null
    phone: string | null
    service_type: $Enums.ServiceType | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: string | null
    organization_id: string | null
    name: string | null
    brand_color: string | null
    logo: string | null
    is_active: boolean | null
    whatsapp: string | null
    phone: string | null
    service_type: $Enums.ServiceType | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    organization_id: number
    name: number
    brand_color: number
    logo: number
    gallery: number
    is_active: number
    whatsapp: number
    phone: number
    address: number
    especialidades: number
    services: number
    service_type: number
    amenities: number
    subscription: number
    working_hours: number
    lunch_break: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UnitMinAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    brand_color?: true
    logo?: true
    is_active?: true
    whatsapp?: true
    phone?: true
    service_type?: true
    created_at?: true
    updated_at?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    brand_color?: true
    logo?: true
    is_active?: true
    whatsapp?: true
    phone?: true
    service_type?: true
    created_at?: true
    updated_at?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    organization_id?: true
    name?: true
    brand_color?: true
    logo?: true
    gallery?: true
    is_active?: true
    whatsapp?: true
    phone?: true
    address?: true
    especialidades?: true
    services?: true
    service_type?: true
    amenities?: true
    subscription?: true
    working_hours?: true
    lunch_break?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: string
    organization_id: string
    name: string
    brand_color: string
    logo: string | null
    gallery: string[]
    is_active: boolean
    whatsapp: string
    phone: string | null
    address: JsonValue
    especialidades: JsonValue
    services: JsonValue
    service_type: $Enums.ServiceType
    amenities: string[]
    subscription: JsonValue | null
    working_hours: JsonValue | null
    lunch_break: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: UnitCountAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    brand_color?: boolean
    logo?: boolean
    gallery?: boolean
    is_active?: boolean
    whatsapp?: boolean
    phone?: boolean
    address?: boolean
    especialidades?: boolean
    services?: boolean
    service_type?: boolean
    amenities?: boolean
    subscription?: boolean
    working_hours?: boolean
    lunch_break?: boolean
    created_at?: boolean
    updated_at?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    unit_specialties?: boolean | Unit$unit_specialtiesArgs<ExtArgs>
    unit_services?: boolean | Unit$unit_servicesArgs<ExtArgs>
    unit_amenities?: boolean | Unit$unit_amenitiesArgs<ExtArgs>
    unit_availability_rules?: boolean | Unit$unit_availability_rulesArgs<ExtArgs>
    unit_availability_exceptions?: boolean | Unit$unit_availability_exceptionsArgs<ExtArgs>
    subscription_record?: boolean | Unit$subscription_recordArgs<ExtArgs>
    bookings?: boolean | Unit$bookingsArgs<ExtArgs>
    customers?: boolean | Unit$customersArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    brand_color?: boolean
    logo?: boolean
    gallery?: boolean
    is_active?: boolean
    whatsapp?: boolean
    phone?: boolean
    address?: boolean
    especialidades?: boolean
    services?: boolean
    service_type?: boolean
    amenities?: boolean
    subscription?: boolean
    working_hours?: boolean
    lunch_break?: boolean
    created_at?: boolean
    updated_at?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organization_id?: boolean
    name?: boolean
    brand_color?: boolean
    logo?: boolean
    gallery?: boolean
    is_active?: boolean
    whatsapp?: boolean
    phone?: boolean
    address?: boolean
    especialidades?: boolean
    services?: boolean
    service_type?: boolean
    amenities?: boolean
    subscription?: boolean
    working_hours?: boolean
    lunch_break?: boolean
    created_at?: boolean
    updated_at?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    organization_id?: boolean
    name?: boolean
    brand_color?: boolean
    logo?: boolean
    gallery?: boolean
    is_active?: boolean
    whatsapp?: boolean
    phone?: boolean
    address?: boolean
    especialidades?: boolean
    services?: boolean
    service_type?: boolean
    amenities?: boolean
    subscription?: boolean
    working_hours?: boolean
    lunch_break?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organization_id" | "name" | "brand_color" | "logo" | "gallery" | "is_active" | "whatsapp" | "phone" | "address" | "especialidades" | "services" | "service_type" | "amenities" | "subscription" | "working_hours" | "lunch_break" | "created_at" | "updated_at", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    unit_specialties?: boolean | Unit$unit_specialtiesArgs<ExtArgs>
    unit_services?: boolean | Unit$unit_servicesArgs<ExtArgs>
    unit_amenities?: boolean | Unit$unit_amenitiesArgs<ExtArgs>
    unit_availability_rules?: boolean | Unit$unit_availability_rulesArgs<ExtArgs>
    unit_availability_exceptions?: boolean | Unit$unit_availability_exceptionsArgs<ExtArgs>
    subscription_record?: boolean | Unit$subscription_recordArgs<ExtArgs>
    bookings?: boolean | Unit$bookingsArgs<ExtArgs>
    customers?: boolean | Unit$customersArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type UnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      unit_specialties: Prisma.$UnitSpecialtyPayload<ExtArgs>[]
      unit_services: Prisma.$UnitServicePayload<ExtArgs>[]
      unit_amenities: Prisma.$UnitAmenityPayload<ExtArgs>[]
      unit_availability_rules: Prisma.$UnitAvailabilityRulePayload<ExtArgs>[]
      unit_availability_exceptions: Prisma.$UnitAvailabilityExceptionPayload<ExtArgs>[]
      subscription_record: Prisma.$SubscriptionPayload<ExtArgs> | null
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organization_id: string
      name: string
      brand_color: string
      logo: string | null
      gallery: string[]
      is_active: boolean
      whatsapp: string
      phone: string | null
      address: Prisma.JsonValue
      especialidades: Prisma.JsonValue
      services: Prisma.JsonValue
      service_type: $Enums.ServiceType
      amenities: string[]
      subscription: Prisma.JsonValue | null
      working_hours: Prisma.JsonValue | null
      lunch_break: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units and returns the data updated in the database.
     * @param {UnitUpdateManyAndReturnArgs} args - Arguments to update many Units.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit_specialties<T extends Unit$unit_specialtiesArgs<ExtArgs> = {}>(args?: Subset<T, Unit$unit_specialtiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitSpecialtyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unit_services<T extends Unit$unit_servicesArgs<ExtArgs> = {}>(args?: Subset<T, Unit$unit_servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unit_amenities<T extends Unit$unit_amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Unit$unit_amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unit_availability_rules<T extends Unit$unit_availability_rulesArgs<ExtArgs> = {}>(args?: Subset<T, Unit$unit_availability_rulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAvailabilityRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unit_availability_exceptions<T extends Unit$unit_availability_exceptionsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$unit_availability_exceptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAvailabilityExceptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription_record<T extends Unit$subscription_recordArgs<ExtArgs> = {}>(args?: Subset<T, Unit$subscription_recordArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bookings<T extends Unit$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends Unit$customersArgs<ExtArgs> = {}>(args?: Subset<T, Unit$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'String'>
    readonly organization_id: FieldRef<"Unit", 'String'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly brand_color: FieldRef<"Unit", 'String'>
    readonly logo: FieldRef<"Unit", 'String'>
    readonly gallery: FieldRef<"Unit", 'String[]'>
    readonly is_active: FieldRef<"Unit", 'Boolean'>
    readonly whatsapp: FieldRef<"Unit", 'String'>
    readonly phone: FieldRef<"Unit", 'String'>
    readonly address: FieldRef<"Unit", 'Json'>
    readonly especialidades: FieldRef<"Unit", 'Json'>
    readonly services: FieldRef<"Unit", 'Json'>
    readonly service_type: FieldRef<"Unit", 'ServiceType'>
    readonly amenities: FieldRef<"Unit", 'String[]'>
    readonly subscription: FieldRef<"Unit", 'Json'>
    readonly working_hours: FieldRef<"Unit", 'Json'>
    readonly lunch_break: FieldRef<"Unit", 'Json'>
    readonly created_at: FieldRef<"Unit", 'DateTime'>
    readonly updated_at: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit updateManyAndReturn
   */
  export type UnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.unit_specialties
   */
  export type Unit$unit_specialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitSpecialty
     */
    select?: UnitSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitSpecialty
     */
    omit?: UnitSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitSpecialtyInclude<ExtArgs> | null
    where?: UnitSpecialtyWhereInput
    orderBy?: UnitSpecialtyOrderByWithRelationInput | UnitSpecialtyOrderByWithRelationInput[]
    cursor?: UnitSpecialtyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitSpecialtyScalarFieldEnum | UnitSpecialtyScalarFieldEnum[]
  }

  /**
   * Unit.unit_services
   */
  export type Unit$unit_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitService
     */
    select?: UnitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitService
     */
    omit?: UnitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceInclude<ExtArgs> | null
    where?: UnitServiceWhereInput
    orderBy?: UnitServiceOrderByWithRelationInput | UnitServiceOrderByWithRelationInput[]
    cursor?: UnitServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitServiceScalarFieldEnum | UnitServiceScalarFieldEnum[]
  }

  /**
   * Unit.unit_amenities
   */
  export type Unit$unit_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAmenity
     */
    select?: UnitAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAmenity
     */
    omit?: UnitAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAmenityInclude<ExtArgs> | null
    where?: UnitAmenityWhereInput
    orderBy?: UnitAmenityOrderByWithRelationInput | UnitAmenityOrderByWithRelationInput[]
    cursor?: UnitAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitAmenityScalarFieldEnum | UnitAmenityScalarFieldEnum[]
  }

  /**
   * Unit.unit_availability_rules
   */
  export type Unit$unit_availability_rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityRule
     */
    select?: UnitAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityRule
     */
    omit?: UnitAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityRuleInclude<ExtArgs> | null
    where?: UnitAvailabilityRuleWhereInput
    orderBy?: UnitAvailabilityRuleOrderByWithRelationInput | UnitAvailabilityRuleOrderByWithRelationInput[]
    cursor?: UnitAvailabilityRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitAvailabilityRuleScalarFieldEnum | UnitAvailabilityRuleScalarFieldEnum[]
  }

  /**
   * Unit.unit_availability_exceptions
   */
  export type Unit$unit_availability_exceptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityException
     */
    select?: UnitAvailabilityExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityException
     */
    omit?: UnitAvailabilityExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityExceptionInclude<ExtArgs> | null
    where?: UnitAvailabilityExceptionWhereInput
    orderBy?: UnitAvailabilityExceptionOrderByWithRelationInput | UnitAvailabilityExceptionOrderByWithRelationInput[]
    cursor?: UnitAvailabilityExceptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitAvailabilityExceptionScalarFieldEnum | UnitAvailabilityExceptionScalarFieldEnum[]
  }

  /**
   * Unit.subscription_record
   */
  export type Unit$subscription_recordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Unit.bookings
   */
  export type Unit$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Unit.customers
   */
  export type Unit$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model Specialty
   */

  export type AggregateSpecialty = {
    _count: SpecialtyCountAggregateOutputType | null
    _min: SpecialtyMinAggregateOutputType | null
    _max: SpecialtyMaxAggregateOutputType | null
  }

  export type SpecialtyMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    icon: string | null
    is_predefined: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SpecialtyMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    icon: string | null
    is_predefined: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SpecialtyCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    icon: number
    is_predefined: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SpecialtyMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    icon?: true
    is_predefined?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type SpecialtyMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    icon?: true
    is_predefined?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type SpecialtyCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    icon?: true
    is_predefined?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SpecialtyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialty to aggregate.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Specialties
    **/
    _count?: true | SpecialtyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialtyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialtyMaxAggregateInputType
  }

  export type GetSpecialtyAggregateType<T extends SpecialtyAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialty[P]>
      : GetScalarType<T[P], AggregateSpecialty[P]>
  }




  export type SpecialtyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialtyWhereInput
    orderBy?: SpecialtyOrderByWithAggregationInput | SpecialtyOrderByWithAggregationInput[]
    by: SpecialtyScalarFieldEnum[] | SpecialtyScalarFieldEnum
    having?: SpecialtyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialtyCountAggregateInputType | true
    _min?: SpecialtyMinAggregateInputType
    _max?: SpecialtyMaxAggregateInputType
  }

  export type SpecialtyGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    icon: string
    is_predefined: boolean
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: SpecialtyCountAggregateOutputType | null
    _min: SpecialtyMinAggregateOutputType | null
    _max: SpecialtyMaxAggregateOutputType | null
  }

  type GetSpecialtyGroupByPayload<T extends SpecialtyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecialtyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialtyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialtyGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialtyGroupByOutputType[P]>
        }
      >
    >


  export type SpecialtySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    is_predefined?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    services?: boolean | Specialty$servicesArgs<ExtArgs>
    unit_specialties?: boolean | Specialty$unit_specialtiesArgs<ExtArgs>
    _count?: boolean | SpecialtyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialty"]>

  export type SpecialtySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    is_predefined?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["specialty"]>

  export type SpecialtySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    is_predefined?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["specialty"]>

  export type SpecialtySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    is_predefined?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SpecialtyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "icon" | "is_predefined" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["specialty"]>
  export type SpecialtyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | Specialty$servicesArgs<ExtArgs>
    unit_specialties?: boolean | Specialty$unit_specialtiesArgs<ExtArgs>
    _count?: boolean | SpecialtyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpecialtyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SpecialtyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SpecialtyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Specialty"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
      unit_specialties: Prisma.$UnitSpecialtyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      icon: string
      is_predefined: boolean
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["specialty"]>
    composites: {}
  }

  type SpecialtyGetPayload<S extends boolean | null | undefined | SpecialtyDefaultArgs> = $Result.GetResult<Prisma.$SpecialtyPayload, S>

  type SpecialtyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpecialtyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpecialtyCountAggregateInputType | true
    }

  export interface SpecialtyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Specialty'], meta: { name: 'Specialty' } }
    /**
     * Find zero or one Specialty that matches the filter.
     * @param {SpecialtyFindUniqueArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecialtyFindUniqueArgs>(args: SelectSubset<T, SpecialtyFindUniqueArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Specialty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpecialtyFindUniqueOrThrowArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecialtyFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecialtyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Specialty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindFirstArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecialtyFindFirstArgs>(args?: SelectSubset<T, SpecialtyFindFirstArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Specialty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindFirstOrThrowArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecialtyFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecialtyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Specialties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specialties
     * const specialties = await prisma.specialty.findMany()
     * 
     * // Get first 10 Specialties
     * const specialties = await prisma.specialty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialtyWithIdOnly = await prisma.specialty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpecialtyFindManyArgs>(args?: SelectSubset<T, SpecialtyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Specialty.
     * @param {SpecialtyCreateArgs} args - Arguments to create a Specialty.
     * @example
     * // Create one Specialty
     * const Specialty = await prisma.specialty.create({
     *   data: {
     *     // ... data to create a Specialty
     *   }
     * })
     * 
     */
    create<T extends SpecialtyCreateArgs>(args: SelectSubset<T, SpecialtyCreateArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Specialties.
     * @param {SpecialtyCreateManyArgs} args - Arguments to create many Specialties.
     * @example
     * // Create many Specialties
     * const specialty = await prisma.specialty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecialtyCreateManyArgs>(args?: SelectSubset<T, SpecialtyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Specialties and returns the data saved in the database.
     * @param {SpecialtyCreateManyAndReturnArgs} args - Arguments to create many Specialties.
     * @example
     * // Create many Specialties
     * const specialty = await prisma.specialty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Specialties and only return the `id`
     * const specialtyWithIdOnly = await prisma.specialty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecialtyCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecialtyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Specialty.
     * @param {SpecialtyDeleteArgs} args - Arguments to delete one Specialty.
     * @example
     * // Delete one Specialty
     * const Specialty = await prisma.specialty.delete({
     *   where: {
     *     // ... filter to delete one Specialty
     *   }
     * })
     * 
     */
    delete<T extends SpecialtyDeleteArgs>(args: SelectSubset<T, SpecialtyDeleteArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Specialty.
     * @param {SpecialtyUpdateArgs} args - Arguments to update one Specialty.
     * @example
     * // Update one Specialty
     * const specialty = await prisma.specialty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecialtyUpdateArgs>(args: SelectSubset<T, SpecialtyUpdateArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Specialties.
     * @param {SpecialtyDeleteManyArgs} args - Arguments to filter Specialties to delete.
     * @example
     * // Delete a few Specialties
     * const { count } = await prisma.specialty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecialtyDeleteManyArgs>(args?: SelectSubset<T, SpecialtyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specialties
     * const specialty = await prisma.specialty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecialtyUpdateManyArgs>(args: SelectSubset<T, SpecialtyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specialties and returns the data updated in the database.
     * @param {SpecialtyUpdateManyAndReturnArgs} args - Arguments to update many Specialties.
     * @example
     * // Update many Specialties
     * const specialty = await prisma.specialty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Specialties and only return the `id`
     * const specialtyWithIdOnly = await prisma.specialty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpecialtyUpdateManyAndReturnArgs>(args: SelectSubset<T, SpecialtyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Specialty.
     * @param {SpecialtyUpsertArgs} args - Arguments to update or create a Specialty.
     * @example
     * // Update or create a Specialty
     * const specialty = await prisma.specialty.upsert({
     *   create: {
     *     // ... data to create a Specialty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Specialty we want to update
     *   }
     * })
     */
    upsert<T extends SpecialtyUpsertArgs>(args: SelectSubset<T, SpecialtyUpsertArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyCountArgs} args - Arguments to filter Specialties to count.
     * @example
     * // Count the number of Specialties
     * const count = await prisma.specialty.count({
     *   where: {
     *     // ... the filter for the Specialties we want to count
     *   }
     * })
    **/
    count<T extends SpecialtyCountArgs>(
      args?: Subset<T, SpecialtyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialtyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Specialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialtyAggregateArgs>(args: Subset<T, SpecialtyAggregateArgs>): Prisma.PrismaPromise<GetSpecialtyAggregateType<T>>

    /**
     * Group by Specialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialtyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialtyGroupByArgs['orderBy'] }
        : { orderBy?: SpecialtyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialtyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialtyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Specialty model
   */
  readonly fields: SpecialtyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Specialty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecialtyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends Specialty$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unit_specialties<T extends Specialty$unit_specialtiesArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$unit_specialtiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitSpecialtyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Specialty model
   */
  interface SpecialtyFieldRefs {
    readonly id: FieldRef<"Specialty", 'String'>
    readonly code: FieldRef<"Specialty", 'String'>
    readonly name: FieldRef<"Specialty", 'String'>
    readonly description: FieldRef<"Specialty", 'String'>
    readonly icon: FieldRef<"Specialty", 'String'>
    readonly is_predefined: FieldRef<"Specialty", 'Boolean'>
    readonly is_active: FieldRef<"Specialty", 'Boolean'>
    readonly created_at: FieldRef<"Specialty", 'DateTime'>
    readonly updated_at: FieldRef<"Specialty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Specialty findUnique
   */
  export type SpecialtyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty findUniqueOrThrow
   */
  export type SpecialtyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty findFirst
   */
  export type SpecialtyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialties.
     */
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty findFirstOrThrow
   */
  export type SpecialtyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialties.
     */
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty findMany
   */
  export type SpecialtyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialties to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty create
   */
  export type SpecialtyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to create a Specialty.
     */
    data: XOR<SpecialtyCreateInput, SpecialtyUncheckedCreateInput>
  }

  /**
   * Specialty createMany
   */
  export type SpecialtyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Specialties.
     */
    data: SpecialtyCreateManyInput | SpecialtyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Specialty createManyAndReturn
   */
  export type SpecialtyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * The data used to create many Specialties.
     */
    data: SpecialtyCreateManyInput | SpecialtyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Specialty update
   */
  export type SpecialtyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to update a Specialty.
     */
    data: XOR<SpecialtyUpdateInput, SpecialtyUncheckedUpdateInput>
    /**
     * Choose, which Specialty to update.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty updateMany
   */
  export type SpecialtyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Specialties.
     */
    data: XOR<SpecialtyUpdateManyMutationInput, SpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which Specialties to update
     */
    where?: SpecialtyWhereInput
    /**
     * Limit how many Specialties to update.
     */
    limit?: number
  }

  /**
   * Specialty updateManyAndReturn
   */
  export type SpecialtyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * The data used to update Specialties.
     */
    data: XOR<SpecialtyUpdateManyMutationInput, SpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which Specialties to update
     */
    where?: SpecialtyWhereInput
    /**
     * Limit how many Specialties to update.
     */
    limit?: number
  }

  /**
   * Specialty upsert
   */
  export type SpecialtyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The filter to search for the Specialty to update in case it exists.
     */
    where: SpecialtyWhereUniqueInput
    /**
     * In case the Specialty found by the `where` argument doesn't exist, create a new Specialty with this data.
     */
    create: XOR<SpecialtyCreateInput, SpecialtyUncheckedCreateInput>
    /**
     * In case the Specialty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecialtyUpdateInput, SpecialtyUncheckedUpdateInput>
  }

  /**
   * Specialty delete
   */
  export type SpecialtyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter which Specialty to delete.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty deleteMany
   */
  export type SpecialtyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialties to delete
     */
    where?: SpecialtyWhereInput
    /**
     * Limit how many Specialties to delete.
     */
    limit?: number
  }

  /**
   * Specialty.services
   */
  export type Specialty$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Specialty.unit_specialties
   */
  export type Specialty$unit_specialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitSpecialty
     */
    select?: UnitSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitSpecialty
     */
    omit?: UnitSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitSpecialtyInclude<ExtArgs> | null
    where?: UnitSpecialtyWhereInput
    orderBy?: UnitSpecialtyOrderByWithRelationInput | UnitSpecialtyOrderByWithRelationInput[]
    cursor?: UnitSpecialtyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitSpecialtyScalarFieldEnum | UnitSpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty without action
   */
  export type SpecialtyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
  }


  /**
   * Model Amenity
   */

  export type AggregateAmenity = {
    _count: AmenityCountAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  export type AmenityMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    icon: string | null
    is_predefined: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AmenityMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    icon: string | null
    is_predefined: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AmenityCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    icon: number
    is_predefined: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AmenityMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    icon?: true
    is_predefined?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type AmenityMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    icon?: true
    is_predefined?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type AmenityCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    icon?: true
    is_predefined?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenity to aggregate.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Amenities
    **/
    _count?: true | AmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenityMaxAggregateInputType
  }

  export type GetAmenityAggregateType<T extends AmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenity[P]>
      : GetScalarType<T[P], AggregateAmenity[P]>
  }




  export type AmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityWhereInput
    orderBy?: AmenityOrderByWithAggregationInput | AmenityOrderByWithAggregationInput[]
    by: AmenityScalarFieldEnum[] | AmenityScalarFieldEnum
    having?: AmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenityCountAggregateInputType | true
    _min?: AmenityMinAggregateInputType
    _max?: AmenityMaxAggregateInputType
  }

  export type AmenityGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    icon: string
    is_predefined: boolean
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: AmenityCountAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  type GetAmenityGroupByPayload<T extends AmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenityGroupByOutputType[P]>
            : GetScalarType<T[P], AmenityGroupByOutputType[P]>
        }
      >
    >


  export type AmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    is_predefined?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit_amenities?: boolean | Amenity$unit_amenitiesArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    is_predefined?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    is_predefined?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    is_predefined?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "icon" | "is_predefined" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["amenity"]>
  export type AmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit_amenities?: boolean | Amenity$unit_amenitiesArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Amenity"
    objects: {
      unit_amenities: Prisma.$UnitAmenityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      icon: string
      is_predefined: boolean
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["amenity"]>
    composites: {}
  }

  type AmenityGetPayload<S extends boolean | null | undefined | AmenityDefaultArgs> = $Result.GetResult<Prisma.$AmenityPayload, S>

  type AmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmenityCountAggregateInputType | true
    }

  export interface AmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Amenity'], meta: { name: 'Amenity' } }
    /**
     * Find zero or one Amenity that matches the filter.
     * @param {AmenityFindUniqueArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenityFindUniqueArgs>(args: SelectSubset<T, AmenityFindUniqueArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Amenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmenityFindUniqueOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenityFindFirstArgs>(args?: SelectSubset<T, AmenityFindFirstArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amenities
     * const amenities = await prisma.amenity.findMany()
     * 
     * // Get first 10 Amenities
     * const amenities = await prisma.amenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenityWithIdOnly = await prisma.amenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenityFindManyArgs>(args?: SelectSubset<T, AmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Amenity.
     * @param {AmenityCreateArgs} args - Arguments to create a Amenity.
     * @example
     * // Create one Amenity
     * const Amenity = await prisma.amenity.create({
     *   data: {
     *     // ... data to create a Amenity
     *   }
     * })
     * 
     */
    create<T extends AmenityCreateArgs>(args: SelectSubset<T, AmenityCreateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Amenities.
     * @param {AmenityCreateManyArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenity = await prisma.amenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenityCreateManyArgs>(args?: SelectSubset<T, AmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Amenities and returns the data saved in the database.
     * @param {AmenityCreateManyAndReturnArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenity = await prisma.amenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Amenities and only return the `id`
     * const amenityWithIdOnly = await prisma.amenity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, AmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Amenity.
     * @param {AmenityDeleteArgs} args - Arguments to delete one Amenity.
     * @example
     * // Delete one Amenity
     * const Amenity = await prisma.amenity.delete({
     *   where: {
     *     // ... filter to delete one Amenity
     *   }
     * })
     * 
     */
    delete<T extends AmenityDeleteArgs>(args: SelectSubset<T, AmenityDeleteArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Amenity.
     * @param {AmenityUpdateArgs} args - Arguments to update one Amenity.
     * @example
     * // Update one Amenity
     * const amenity = await prisma.amenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenityUpdateArgs>(args: SelectSubset<T, AmenityUpdateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Amenities.
     * @param {AmenityDeleteManyArgs} args - Arguments to filter Amenities to delete.
     * @example
     * // Delete a few Amenities
     * const { count } = await prisma.amenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenityDeleteManyArgs>(args?: SelectSubset<T, AmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amenities
     * const amenity = await prisma.amenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenityUpdateManyArgs>(args: SelectSubset<T, AmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities and returns the data updated in the database.
     * @param {AmenityUpdateManyAndReturnArgs} args - Arguments to update many Amenities.
     * @example
     * // Update many Amenities
     * const amenity = await prisma.amenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Amenities and only return the `id`
     * const amenityWithIdOnly = await prisma.amenity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, AmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Amenity.
     * @param {AmenityUpsertArgs} args - Arguments to update or create a Amenity.
     * @example
     * // Update or create a Amenity
     * const amenity = await prisma.amenity.upsert({
     *   create: {
     *     // ... data to create a Amenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amenity we want to update
     *   }
     * })
     */
    upsert<T extends AmenityUpsertArgs>(args: SelectSubset<T, AmenityUpsertArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityCountArgs} args - Arguments to filter Amenities to count.
     * @example
     * // Count the number of Amenities
     * const count = await prisma.amenity.count({
     *   where: {
     *     // ... the filter for the Amenities we want to count
     *   }
     * })
    **/
    count<T extends AmenityCountArgs>(
      args?: Subset<T, AmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenityAggregateArgs>(args: Subset<T, AmenityAggregateArgs>): Prisma.PrismaPromise<GetAmenityAggregateType<T>>

    /**
     * Group by Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenityGroupByArgs['orderBy'] }
        : { orderBy?: AmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Amenity model
   */
  readonly fields: AmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Amenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit_amenities<T extends Amenity$unit_amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Amenity$unit_amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Amenity model
   */
  interface AmenityFieldRefs {
    readonly id: FieldRef<"Amenity", 'String'>
    readonly code: FieldRef<"Amenity", 'String'>
    readonly name: FieldRef<"Amenity", 'String'>
    readonly description: FieldRef<"Amenity", 'String'>
    readonly icon: FieldRef<"Amenity", 'String'>
    readonly is_predefined: FieldRef<"Amenity", 'Boolean'>
    readonly is_active: FieldRef<"Amenity", 'Boolean'>
    readonly created_at: FieldRef<"Amenity", 'DateTime'>
    readonly updated_at: FieldRef<"Amenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Amenity findUnique
   */
  export type AmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findUniqueOrThrow
   */
  export type AmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findFirst
   */
  export type AmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findFirstOrThrow
   */
  export type AmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findMany
   */
  export type AmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity create
   */
  export type AmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a Amenity.
     */
    data: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
  }

  /**
   * Amenity createMany
   */
  export type AmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Amenities.
     */
    data: AmenityCreateManyInput | AmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenity createManyAndReturn
   */
  export type AmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * The data used to create many Amenities.
     */
    data: AmenityCreateManyInput | AmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenity update
   */
  export type AmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a Amenity.
     */
    data: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
    /**
     * Choose, which Amenity to update.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity updateMany
   */
  export type AmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenity updateManyAndReturn
   */
  export type AmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenity upsert
   */
  export type AmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the Amenity to update in case it exists.
     */
    where: AmenityWhereUniqueInput
    /**
     * In case the Amenity found by the `where` argument doesn't exist, create a new Amenity with this data.
     */
    create: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
    /**
     * In case the Amenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
  }

  /**
   * Amenity delete
   */
  export type AmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter which Amenity to delete.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity deleteMany
   */
  export type AmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to delete
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to delete.
     */
    limit?: number
  }

  /**
   * Amenity.unit_amenities
   */
  export type Amenity$unit_amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAmenity
     */
    select?: UnitAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAmenity
     */
    omit?: UnitAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAmenityInclude<ExtArgs> | null
    where?: UnitAmenityWhereInput
    orderBy?: UnitAmenityOrderByWithRelationInput | UnitAmenityOrderByWithRelationInput[]
    cursor?: UnitAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitAmenityScalarFieldEnum | UnitAmenityScalarFieldEnum[]
  }

  /**
   * Amenity without action
   */
  export type AmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    default_duration_minutes: number | null
    default_price_cents: number | null
  }

  export type ServiceSumAggregateOutputType = {
    default_duration_minutes: number | null
    default_price_cents: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    specialty_id: string | null
    code: string | null
    name: string | null
    description: string | null
    default_duration_minutes: number | null
    default_price_cents: number | null
    is_predefined: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    specialty_id: string | null
    code: string | null
    name: string | null
    description: string | null
    default_duration_minutes: number | null
    default_price_cents: number | null
    is_predefined: boolean | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    specialty_id: number
    code: number
    name: number
    description: number
    default_duration_minutes: number
    default_price_cents: number
    is_predefined: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    default_duration_minutes?: true
    default_price_cents?: true
  }

  export type ServiceSumAggregateInputType = {
    default_duration_minutes?: true
    default_price_cents?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    specialty_id?: true
    code?: true
    name?: true
    description?: true
    default_duration_minutes?: true
    default_price_cents?: true
    is_predefined?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    specialty_id?: true
    code?: true
    name?: true
    description?: true
    default_duration_minutes?: true
    default_price_cents?: true
    is_predefined?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    specialty_id?: true
    code?: true
    name?: true
    description?: true
    default_duration_minutes?: true
    default_price_cents?: true
    is_predefined?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    specialty_id: string
    code: string
    name: string
    description: string | null
    default_duration_minutes: number
    default_price_cents: number
    is_predefined: boolean
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    specialty_id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    default_duration_minutes?: boolean
    default_price_cents?: boolean
    is_predefined?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
    unit_services?: boolean | Service$unit_servicesArgs<ExtArgs>
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    specialty_id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    default_duration_minutes?: boolean
    default_price_cents?: boolean
    is_predefined?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    specialty_id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    default_duration_minutes?: boolean
    default_price_cents?: boolean
    is_predefined?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    specialty_id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    default_duration_minutes?: boolean
    default_price_cents?: boolean
    is_predefined?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "specialty_id" | "code" | "name" | "description" | "default_duration_minutes" | "default_price_cents" | "is_predefined" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
    unit_services?: boolean | Service$unit_servicesArgs<ExtArgs>
    bookings?: boolean | Service$bookingsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      specialty: Prisma.$SpecialtyPayload<ExtArgs>
      unit_services: Prisma.$UnitServicePayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      specialty_id: string
      code: string
      name: string
      description: string | null
      default_duration_minutes: number
      default_price_cents: number
      is_predefined: boolean
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    specialty<T extends SpecialtyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecialtyDefaultArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit_services<T extends Service$unit_servicesArgs<ExtArgs> = {}>(args?: Subset<T, Service$unit_servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends Service$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Service$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly specialty_id: FieldRef<"Service", 'String'>
    readonly code: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly default_duration_minutes: FieldRef<"Service", 'Int'>
    readonly default_price_cents: FieldRef<"Service", 'Int'>
    readonly is_predefined: FieldRef<"Service", 'Boolean'>
    readonly is_active: FieldRef<"Service", 'Boolean'>
    readonly created_at: FieldRef<"Service", 'DateTime'>
    readonly updated_at: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.unit_services
   */
  export type Service$unit_servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitService
     */
    select?: UnitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitService
     */
    omit?: UnitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceInclude<ExtArgs> | null
    where?: UnitServiceWhereInput
    orderBy?: UnitServiceOrderByWithRelationInput | UnitServiceOrderByWithRelationInput[]
    cursor?: UnitServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitServiceScalarFieldEnum | UnitServiceScalarFieldEnum[]
  }

  /**
   * Service.bookings
   */
  export type Service$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model UnitSpecialty
   */

  export type AggregateUnitSpecialty = {
    _count: UnitSpecialtyCountAggregateOutputType | null
    _min: UnitSpecialtyMinAggregateOutputType | null
    _max: UnitSpecialtyMaxAggregateOutputType | null
  }

  export type UnitSpecialtyMinAggregateOutputType = {
    id: string | null
    unit_id: string | null
    specialty_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UnitSpecialtyMaxAggregateOutputType = {
    id: string | null
    unit_id: string | null
    specialty_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UnitSpecialtyCountAggregateOutputType = {
    id: number
    unit_id: number
    specialty_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UnitSpecialtyMinAggregateInputType = {
    id?: true
    unit_id?: true
    specialty_id?: true
    created_at?: true
    updated_at?: true
  }

  export type UnitSpecialtyMaxAggregateInputType = {
    id?: true
    unit_id?: true
    specialty_id?: true
    created_at?: true
    updated_at?: true
  }

  export type UnitSpecialtyCountAggregateInputType = {
    id?: true
    unit_id?: true
    specialty_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UnitSpecialtyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitSpecialty to aggregate.
     */
    where?: UnitSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitSpecialties to fetch.
     */
    orderBy?: UnitSpecialtyOrderByWithRelationInput | UnitSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitSpecialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitSpecialties
    **/
    _count?: true | UnitSpecialtyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitSpecialtyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitSpecialtyMaxAggregateInputType
  }

  export type GetUnitSpecialtyAggregateType<T extends UnitSpecialtyAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitSpecialty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitSpecialty[P]>
      : GetScalarType<T[P], AggregateUnitSpecialty[P]>
  }




  export type UnitSpecialtyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitSpecialtyWhereInput
    orderBy?: UnitSpecialtyOrderByWithAggregationInput | UnitSpecialtyOrderByWithAggregationInput[]
    by: UnitSpecialtyScalarFieldEnum[] | UnitSpecialtyScalarFieldEnum
    having?: UnitSpecialtyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitSpecialtyCountAggregateInputType | true
    _min?: UnitSpecialtyMinAggregateInputType
    _max?: UnitSpecialtyMaxAggregateInputType
  }

  export type UnitSpecialtyGroupByOutputType = {
    id: string
    unit_id: string
    specialty_id: string
    created_at: Date
    updated_at: Date
    _count: UnitSpecialtyCountAggregateOutputType | null
    _min: UnitSpecialtyMinAggregateOutputType | null
    _max: UnitSpecialtyMaxAggregateOutputType | null
  }

  type GetUnitSpecialtyGroupByPayload<T extends UnitSpecialtyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitSpecialtyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitSpecialtyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitSpecialtyGroupByOutputType[P]>
            : GetScalarType<T[P], UnitSpecialtyGroupByOutputType[P]>
        }
      >
    >


  export type UnitSpecialtySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    specialty_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitSpecialty"]>

  export type UnitSpecialtySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    specialty_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitSpecialty"]>

  export type UnitSpecialtySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    specialty_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitSpecialty"]>

  export type UnitSpecialtySelectScalar = {
    id?: boolean
    unit_id?: boolean
    specialty_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UnitSpecialtyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unit_id" | "specialty_id" | "created_at" | "updated_at", ExtArgs["result"]["unitSpecialty"]>
  export type UnitSpecialtyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }
  export type UnitSpecialtyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }
  export type UnitSpecialtyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    specialty?: boolean | SpecialtyDefaultArgs<ExtArgs>
  }

  export type $UnitSpecialtyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitSpecialty"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
      specialty: Prisma.$SpecialtyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unit_id: string
      specialty_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["unitSpecialty"]>
    composites: {}
  }

  type UnitSpecialtyGetPayload<S extends boolean | null | undefined | UnitSpecialtyDefaultArgs> = $Result.GetResult<Prisma.$UnitSpecialtyPayload, S>

  type UnitSpecialtyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitSpecialtyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitSpecialtyCountAggregateInputType | true
    }

  export interface UnitSpecialtyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitSpecialty'], meta: { name: 'UnitSpecialty' } }
    /**
     * Find zero or one UnitSpecialty that matches the filter.
     * @param {UnitSpecialtyFindUniqueArgs} args - Arguments to find a UnitSpecialty
     * @example
     * // Get one UnitSpecialty
     * const unitSpecialty = await prisma.unitSpecialty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitSpecialtyFindUniqueArgs>(args: SelectSubset<T, UnitSpecialtyFindUniqueArgs<ExtArgs>>): Prisma__UnitSpecialtyClient<$Result.GetResult<Prisma.$UnitSpecialtyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitSpecialty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitSpecialtyFindUniqueOrThrowArgs} args - Arguments to find a UnitSpecialty
     * @example
     * // Get one UnitSpecialty
     * const unitSpecialty = await prisma.unitSpecialty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitSpecialtyFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitSpecialtyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitSpecialtyClient<$Result.GetResult<Prisma.$UnitSpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitSpecialty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitSpecialtyFindFirstArgs} args - Arguments to find a UnitSpecialty
     * @example
     * // Get one UnitSpecialty
     * const unitSpecialty = await prisma.unitSpecialty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitSpecialtyFindFirstArgs>(args?: SelectSubset<T, UnitSpecialtyFindFirstArgs<ExtArgs>>): Prisma__UnitSpecialtyClient<$Result.GetResult<Prisma.$UnitSpecialtyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitSpecialty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitSpecialtyFindFirstOrThrowArgs} args - Arguments to find a UnitSpecialty
     * @example
     * // Get one UnitSpecialty
     * const unitSpecialty = await prisma.unitSpecialty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitSpecialtyFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitSpecialtyFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitSpecialtyClient<$Result.GetResult<Prisma.$UnitSpecialtyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitSpecialties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitSpecialtyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitSpecialties
     * const unitSpecialties = await prisma.unitSpecialty.findMany()
     * 
     * // Get first 10 UnitSpecialties
     * const unitSpecialties = await prisma.unitSpecialty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitSpecialtyWithIdOnly = await prisma.unitSpecialty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitSpecialtyFindManyArgs>(args?: SelectSubset<T, UnitSpecialtyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitSpecialtyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitSpecialty.
     * @param {UnitSpecialtyCreateArgs} args - Arguments to create a UnitSpecialty.
     * @example
     * // Create one UnitSpecialty
     * const UnitSpecialty = await prisma.unitSpecialty.create({
     *   data: {
     *     // ... data to create a UnitSpecialty
     *   }
     * })
     * 
     */
    create<T extends UnitSpecialtyCreateArgs>(args: SelectSubset<T, UnitSpecialtyCreateArgs<ExtArgs>>): Prisma__UnitSpecialtyClient<$Result.GetResult<Prisma.$UnitSpecialtyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitSpecialties.
     * @param {UnitSpecialtyCreateManyArgs} args - Arguments to create many UnitSpecialties.
     * @example
     * // Create many UnitSpecialties
     * const unitSpecialty = await prisma.unitSpecialty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitSpecialtyCreateManyArgs>(args?: SelectSubset<T, UnitSpecialtyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitSpecialties and returns the data saved in the database.
     * @param {UnitSpecialtyCreateManyAndReturnArgs} args - Arguments to create many UnitSpecialties.
     * @example
     * // Create many UnitSpecialties
     * const unitSpecialty = await prisma.unitSpecialty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitSpecialties and only return the `id`
     * const unitSpecialtyWithIdOnly = await prisma.unitSpecialty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitSpecialtyCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitSpecialtyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitSpecialtyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitSpecialty.
     * @param {UnitSpecialtyDeleteArgs} args - Arguments to delete one UnitSpecialty.
     * @example
     * // Delete one UnitSpecialty
     * const UnitSpecialty = await prisma.unitSpecialty.delete({
     *   where: {
     *     // ... filter to delete one UnitSpecialty
     *   }
     * })
     * 
     */
    delete<T extends UnitSpecialtyDeleteArgs>(args: SelectSubset<T, UnitSpecialtyDeleteArgs<ExtArgs>>): Prisma__UnitSpecialtyClient<$Result.GetResult<Prisma.$UnitSpecialtyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitSpecialty.
     * @param {UnitSpecialtyUpdateArgs} args - Arguments to update one UnitSpecialty.
     * @example
     * // Update one UnitSpecialty
     * const unitSpecialty = await prisma.unitSpecialty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitSpecialtyUpdateArgs>(args: SelectSubset<T, UnitSpecialtyUpdateArgs<ExtArgs>>): Prisma__UnitSpecialtyClient<$Result.GetResult<Prisma.$UnitSpecialtyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitSpecialties.
     * @param {UnitSpecialtyDeleteManyArgs} args - Arguments to filter UnitSpecialties to delete.
     * @example
     * // Delete a few UnitSpecialties
     * const { count } = await prisma.unitSpecialty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitSpecialtyDeleteManyArgs>(args?: SelectSubset<T, UnitSpecialtyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitSpecialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitSpecialtyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitSpecialties
     * const unitSpecialty = await prisma.unitSpecialty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitSpecialtyUpdateManyArgs>(args: SelectSubset<T, UnitSpecialtyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitSpecialties and returns the data updated in the database.
     * @param {UnitSpecialtyUpdateManyAndReturnArgs} args - Arguments to update many UnitSpecialties.
     * @example
     * // Update many UnitSpecialties
     * const unitSpecialty = await prisma.unitSpecialty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitSpecialties and only return the `id`
     * const unitSpecialtyWithIdOnly = await prisma.unitSpecialty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitSpecialtyUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitSpecialtyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitSpecialtyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitSpecialty.
     * @param {UnitSpecialtyUpsertArgs} args - Arguments to update or create a UnitSpecialty.
     * @example
     * // Update or create a UnitSpecialty
     * const unitSpecialty = await prisma.unitSpecialty.upsert({
     *   create: {
     *     // ... data to create a UnitSpecialty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitSpecialty we want to update
     *   }
     * })
     */
    upsert<T extends UnitSpecialtyUpsertArgs>(args: SelectSubset<T, UnitSpecialtyUpsertArgs<ExtArgs>>): Prisma__UnitSpecialtyClient<$Result.GetResult<Prisma.$UnitSpecialtyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitSpecialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitSpecialtyCountArgs} args - Arguments to filter UnitSpecialties to count.
     * @example
     * // Count the number of UnitSpecialties
     * const count = await prisma.unitSpecialty.count({
     *   where: {
     *     // ... the filter for the UnitSpecialties we want to count
     *   }
     * })
    **/
    count<T extends UnitSpecialtyCountArgs>(
      args?: Subset<T, UnitSpecialtyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitSpecialtyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitSpecialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitSpecialtyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitSpecialtyAggregateArgs>(args: Subset<T, UnitSpecialtyAggregateArgs>): Prisma.PrismaPromise<GetUnitSpecialtyAggregateType<T>>

    /**
     * Group by UnitSpecialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitSpecialtyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitSpecialtyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitSpecialtyGroupByArgs['orderBy'] }
        : { orderBy?: UnitSpecialtyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitSpecialtyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitSpecialtyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitSpecialty model
   */
  readonly fields: UnitSpecialtyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitSpecialty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitSpecialtyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    specialty<T extends SpecialtyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpecialtyDefaultArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitSpecialty model
   */
  interface UnitSpecialtyFieldRefs {
    readonly id: FieldRef<"UnitSpecialty", 'String'>
    readonly unit_id: FieldRef<"UnitSpecialty", 'String'>
    readonly specialty_id: FieldRef<"UnitSpecialty", 'String'>
    readonly created_at: FieldRef<"UnitSpecialty", 'DateTime'>
    readonly updated_at: FieldRef<"UnitSpecialty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitSpecialty findUnique
   */
  export type UnitSpecialtyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitSpecialty
     */
    select?: UnitSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitSpecialty
     */
    omit?: UnitSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which UnitSpecialty to fetch.
     */
    where: UnitSpecialtyWhereUniqueInput
  }

  /**
   * UnitSpecialty findUniqueOrThrow
   */
  export type UnitSpecialtyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitSpecialty
     */
    select?: UnitSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitSpecialty
     */
    omit?: UnitSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which UnitSpecialty to fetch.
     */
    where: UnitSpecialtyWhereUniqueInput
  }

  /**
   * UnitSpecialty findFirst
   */
  export type UnitSpecialtyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitSpecialty
     */
    select?: UnitSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitSpecialty
     */
    omit?: UnitSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which UnitSpecialty to fetch.
     */
    where?: UnitSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitSpecialties to fetch.
     */
    orderBy?: UnitSpecialtyOrderByWithRelationInput | UnitSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitSpecialties.
     */
    cursor?: UnitSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitSpecialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitSpecialties.
     */
    distinct?: UnitSpecialtyScalarFieldEnum | UnitSpecialtyScalarFieldEnum[]
  }

  /**
   * UnitSpecialty findFirstOrThrow
   */
  export type UnitSpecialtyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitSpecialty
     */
    select?: UnitSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitSpecialty
     */
    omit?: UnitSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which UnitSpecialty to fetch.
     */
    where?: UnitSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitSpecialties to fetch.
     */
    orderBy?: UnitSpecialtyOrderByWithRelationInput | UnitSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitSpecialties.
     */
    cursor?: UnitSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitSpecialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitSpecialties.
     */
    distinct?: UnitSpecialtyScalarFieldEnum | UnitSpecialtyScalarFieldEnum[]
  }

  /**
   * UnitSpecialty findMany
   */
  export type UnitSpecialtyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitSpecialty
     */
    select?: UnitSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitSpecialty
     */
    omit?: UnitSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitSpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which UnitSpecialties to fetch.
     */
    where?: UnitSpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitSpecialties to fetch.
     */
    orderBy?: UnitSpecialtyOrderByWithRelationInput | UnitSpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitSpecialties.
     */
    cursor?: UnitSpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitSpecialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitSpecialties.
     */
    skip?: number
    distinct?: UnitSpecialtyScalarFieldEnum | UnitSpecialtyScalarFieldEnum[]
  }

  /**
   * UnitSpecialty create
   */
  export type UnitSpecialtyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitSpecialty
     */
    select?: UnitSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitSpecialty
     */
    omit?: UnitSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitSpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitSpecialty.
     */
    data: XOR<UnitSpecialtyCreateInput, UnitSpecialtyUncheckedCreateInput>
  }

  /**
   * UnitSpecialty createMany
   */
  export type UnitSpecialtyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitSpecialties.
     */
    data: UnitSpecialtyCreateManyInput | UnitSpecialtyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitSpecialty createManyAndReturn
   */
  export type UnitSpecialtyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitSpecialty
     */
    select?: UnitSpecialtySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitSpecialty
     */
    omit?: UnitSpecialtyOmit<ExtArgs> | null
    /**
     * The data used to create many UnitSpecialties.
     */
    data: UnitSpecialtyCreateManyInput | UnitSpecialtyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitSpecialtyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitSpecialty update
   */
  export type UnitSpecialtyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitSpecialty
     */
    select?: UnitSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitSpecialty
     */
    omit?: UnitSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitSpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitSpecialty.
     */
    data: XOR<UnitSpecialtyUpdateInput, UnitSpecialtyUncheckedUpdateInput>
    /**
     * Choose, which UnitSpecialty to update.
     */
    where: UnitSpecialtyWhereUniqueInput
  }

  /**
   * UnitSpecialty updateMany
   */
  export type UnitSpecialtyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitSpecialties.
     */
    data: XOR<UnitSpecialtyUpdateManyMutationInput, UnitSpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which UnitSpecialties to update
     */
    where?: UnitSpecialtyWhereInput
    /**
     * Limit how many UnitSpecialties to update.
     */
    limit?: number
  }

  /**
   * UnitSpecialty updateManyAndReturn
   */
  export type UnitSpecialtyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitSpecialty
     */
    select?: UnitSpecialtySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitSpecialty
     */
    omit?: UnitSpecialtyOmit<ExtArgs> | null
    /**
     * The data used to update UnitSpecialties.
     */
    data: XOR<UnitSpecialtyUpdateManyMutationInput, UnitSpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which UnitSpecialties to update
     */
    where?: UnitSpecialtyWhereInput
    /**
     * Limit how many UnitSpecialties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitSpecialtyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitSpecialty upsert
   */
  export type UnitSpecialtyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitSpecialty
     */
    select?: UnitSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitSpecialty
     */
    omit?: UnitSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitSpecialtyInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitSpecialty to update in case it exists.
     */
    where: UnitSpecialtyWhereUniqueInput
    /**
     * In case the UnitSpecialty found by the `where` argument doesn't exist, create a new UnitSpecialty with this data.
     */
    create: XOR<UnitSpecialtyCreateInput, UnitSpecialtyUncheckedCreateInput>
    /**
     * In case the UnitSpecialty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitSpecialtyUpdateInput, UnitSpecialtyUncheckedUpdateInput>
  }

  /**
   * UnitSpecialty delete
   */
  export type UnitSpecialtyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitSpecialty
     */
    select?: UnitSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitSpecialty
     */
    omit?: UnitSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitSpecialtyInclude<ExtArgs> | null
    /**
     * Filter which UnitSpecialty to delete.
     */
    where: UnitSpecialtyWhereUniqueInput
  }

  /**
   * UnitSpecialty deleteMany
   */
  export type UnitSpecialtyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitSpecialties to delete
     */
    where?: UnitSpecialtyWhereInput
    /**
     * Limit how many UnitSpecialties to delete.
     */
    limit?: number
  }

  /**
   * UnitSpecialty without action
   */
  export type UnitSpecialtyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitSpecialty
     */
    select?: UnitSpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitSpecialty
     */
    omit?: UnitSpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitSpecialtyInclude<ExtArgs> | null
  }


  /**
   * Model UnitAmenity
   */

  export type AggregateUnitAmenity = {
    _count: UnitAmenityCountAggregateOutputType | null
    _min: UnitAmenityMinAggregateOutputType | null
    _max: UnitAmenityMaxAggregateOutputType | null
  }

  export type UnitAmenityMinAggregateOutputType = {
    id: string | null
    unit_id: string | null
    amenity_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UnitAmenityMaxAggregateOutputType = {
    id: string | null
    unit_id: string | null
    amenity_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UnitAmenityCountAggregateOutputType = {
    id: number
    unit_id: number
    amenity_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UnitAmenityMinAggregateInputType = {
    id?: true
    unit_id?: true
    amenity_id?: true
    created_at?: true
    updated_at?: true
  }

  export type UnitAmenityMaxAggregateInputType = {
    id?: true
    unit_id?: true
    amenity_id?: true
    created_at?: true
    updated_at?: true
  }

  export type UnitAmenityCountAggregateInputType = {
    id?: true
    unit_id?: true
    amenity_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UnitAmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitAmenity to aggregate.
     */
    where?: UnitAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAmenities to fetch.
     */
    orderBy?: UnitAmenityOrderByWithRelationInput | UnitAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitAmenities
    **/
    _count?: true | UnitAmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitAmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitAmenityMaxAggregateInputType
  }

  export type GetUnitAmenityAggregateType<T extends UnitAmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitAmenity[P]>
      : GetScalarType<T[P], AggregateUnitAmenity[P]>
  }




  export type UnitAmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitAmenityWhereInput
    orderBy?: UnitAmenityOrderByWithAggregationInput | UnitAmenityOrderByWithAggregationInput[]
    by: UnitAmenityScalarFieldEnum[] | UnitAmenityScalarFieldEnum
    having?: UnitAmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitAmenityCountAggregateInputType | true
    _min?: UnitAmenityMinAggregateInputType
    _max?: UnitAmenityMaxAggregateInputType
  }

  export type UnitAmenityGroupByOutputType = {
    id: string
    unit_id: string
    amenity_id: string
    created_at: Date
    updated_at: Date
    _count: UnitAmenityCountAggregateOutputType | null
    _min: UnitAmenityMinAggregateOutputType | null
    _max: UnitAmenityMaxAggregateOutputType | null
  }

  type GetUnitAmenityGroupByPayload<T extends UnitAmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitAmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitAmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitAmenityGroupByOutputType[P]>
            : GetScalarType<T[P], UnitAmenityGroupByOutputType[P]>
        }
      >
    >


  export type UnitAmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    amenity_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitAmenity"]>

  export type UnitAmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    amenity_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitAmenity"]>

  export type UnitAmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    amenity_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitAmenity"]>

  export type UnitAmenitySelectScalar = {
    id?: boolean
    unit_id?: boolean
    amenity_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UnitAmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unit_id" | "amenity_id" | "created_at" | "updated_at", ExtArgs["result"]["unitAmenity"]>
  export type UnitAmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }
  export type UnitAmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }
  export type UnitAmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }

  export type $UnitAmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitAmenity"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
      amenity: Prisma.$AmenityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unit_id: string
      amenity_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["unitAmenity"]>
    composites: {}
  }

  type UnitAmenityGetPayload<S extends boolean | null | undefined | UnitAmenityDefaultArgs> = $Result.GetResult<Prisma.$UnitAmenityPayload, S>

  type UnitAmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitAmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitAmenityCountAggregateInputType | true
    }

  export interface UnitAmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitAmenity'], meta: { name: 'UnitAmenity' } }
    /**
     * Find zero or one UnitAmenity that matches the filter.
     * @param {UnitAmenityFindUniqueArgs} args - Arguments to find a UnitAmenity
     * @example
     * // Get one UnitAmenity
     * const unitAmenity = await prisma.unitAmenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitAmenityFindUniqueArgs>(args: SelectSubset<T, UnitAmenityFindUniqueArgs<ExtArgs>>): Prisma__UnitAmenityClient<$Result.GetResult<Prisma.$UnitAmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitAmenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitAmenityFindUniqueOrThrowArgs} args - Arguments to find a UnitAmenity
     * @example
     * // Get one UnitAmenity
     * const unitAmenity = await prisma.unitAmenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitAmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitAmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitAmenityClient<$Result.GetResult<Prisma.$UnitAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitAmenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAmenityFindFirstArgs} args - Arguments to find a UnitAmenity
     * @example
     * // Get one UnitAmenity
     * const unitAmenity = await prisma.unitAmenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitAmenityFindFirstArgs>(args?: SelectSubset<T, UnitAmenityFindFirstArgs<ExtArgs>>): Prisma__UnitAmenityClient<$Result.GetResult<Prisma.$UnitAmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitAmenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAmenityFindFirstOrThrowArgs} args - Arguments to find a UnitAmenity
     * @example
     * // Get one UnitAmenity
     * const unitAmenity = await prisma.unitAmenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitAmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitAmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitAmenityClient<$Result.GetResult<Prisma.$UnitAmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitAmenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitAmenities
     * const unitAmenities = await prisma.unitAmenity.findMany()
     * 
     * // Get first 10 UnitAmenities
     * const unitAmenities = await prisma.unitAmenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitAmenityWithIdOnly = await prisma.unitAmenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitAmenityFindManyArgs>(args?: SelectSubset<T, UnitAmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitAmenity.
     * @param {UnitAmenityCreateArgs} args - Arguments to create a UnitAmenity.
     * @example
     * // Create one UnitAmenity
     * const UnitAmenity = await prisma.unitAmenity.create({
     *   data: {
     *     // ... data to create a UnitAmenity
     *   }
     * })
     * 
     */
    create<T extends UnitAmenityCreateArgs>(args: SelectSubset<T, UnitAmenityCreateArgs<ExtArgs>>): Prisma__UnitAmenityClient<$Result.GetResult<Prisma.$UnitAmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitAmenities.
     * @param {UnitAmenityCreateManyArgs} args - Arguments to create many UnitAmenities.
     * @example
     * // Create many UnitAmenities
     * const unitAmenity = await prisma.unitAmenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitAmenityCreateManyArgs>(args?: SelectSubset<T, UnitAmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitAmenities and returns the data saved in the database.
     * @param {UnitAmenityCreateManyAndReturnArgs} args - Arguments to create many UnitAmenities.
     * @example
     * // Create many UnitAmenities
     * const unitAmenity = await prisma.unitAmenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitAmenities and only return the `id`
     * const unitAmenityWithIdOnly = await prisma.unitAmenity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitAmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitAmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitAmenity.
     * @param {UnitAmenityDeleteArgs} args - Arguments to delete one UnitAmenity.
     * @example
     * // Delete one UnitAmenity
     * const UnitAmenity = await prisma.unitAmenity.delete({
     *   where: {
     *     // ... filter to delete one UnitAmenity
     *   }
     * })
     * 
     */
    delete<T extends UnitAmenityDeleteArgs>(args: SelectSubset<T, UnitAmenityDeleteArgs<ExtArgs>>): Prisma__UnitAmenityClient<$Result.GetResult<Prisma.$UnitAmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitAmenity.
     * @param {UnitAmenityUpdateArgs} args - Arguments to update one UnitAmenity.
     * @example
     * // Update one UnitAmenity
     * const unitAmenity = await prisma.unitAmenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitAmenityUpdateArgs>(args: SelectSubset<T, UnitAmenityUpdateArgs<ExtArgs>>): Prisma__UnitAmenityClient<$Result.GetResult<Prisma.$UnitAmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitAmenities.
     * @param {UnitAmenityDeleteManyArgs} args - Arguments to filter UnitAmenities to delete.
     * @example
     * // Delete a few UnitAmenities
     * const { count } = await prisma.unitAmenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitAmenityDeleteManyArgs>(args?: SelectSubset<T, UnitAmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitAmenities
     * const unitAmenity = await prisma.unitAmenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitAmenityUpdateManyArgs>(args: SelectSubset<T, UnitAmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitAmenities and returns the data updated in the database.
     * @param {UnitAmenityUpdateManyAndReturnArgs} args - Arguments to update many UnitAmenities.
     * @example
     * // Update many UnitAmenities
     * const unitAmenity = await prisma.unitAmenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitAmenities and only return the `id`
     * const unitAmenityWithIdOnly = await prisma.unitAmenity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitAmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitAmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitAmenity.
     * @param {UnitAmenityUpsertArgs} args - Arguments to update or create a UnitAmenity.
     * @example
     * // Update or create a UnitAmenity
     * const unitAmenity = await prisma.unitAmenity.upsert({
     *   create: {
     *     // ... data to create a UnitAmenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitAmenity we want to update
     *   }
     * })
     */
    upsert<T extends UnitAmenityUpsertArgs>(args: SelectSubset<T, UnitAmenityUpsertArgs<ExtArgs>>): Prisma__UnitAmenityClient<$Result.GetResult<Prisma.$UnitAmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAmenityCountArgs} args - Arguments to filter UnitAmenities to count.
     * @example
     * // Count the number of UnitAmenities
     * const count = await prisma.unitAmenity.count({
     *   where: {
     *     // ... the filter for the UnitAmenities we want to count
     *   }
     * })
    **/
    count<T extends UnitAmenityCountArgs>(
      args?: Subset<T, UnitAmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitAmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAmenityAggregateArgs>(args: Subset<T, UnitAmenityAggregateArgs>): Prisma.PrismaPromise<GetUnitAmenityAggregateType<T>>

    /**
     * Group by UnitAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitAmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitAmenityGroupByArgs['orderBy'] }
        : { orderBy?: UnitAmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitAmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitAmenity model
   */
  readonly fields: UnitAmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitAmenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitAmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    amenity<T extends AmenityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AmenityDefaultArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitAmenity model
   */
  interface UnitAmenityFieldRefs {
    readonly id: FieldRef<"UnitAmenity", 'String'>
    readonly unit_id: FieldRef<"UnitAmenity", 'String'>
    readonly amenity_id: FieldRef<"UnitAmenity", 'String'>
    readonly created_at: FieldRef<"UnitAmenity", 'DateTime'>
    readonly updated_at: FieldRef<"UnitAmenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitAmenity findUnique
   */
  export type UnitAmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAmenity
     */
    select?: UnitAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAmenity
     */
    omit?: UnitAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAmenityInclude<ExtArgs> | null
    /**
     * Filter, which UnitAmenity to fetch.
     */
    where: UnitAmenityWhereUniqueInput
  }

  /**
   * UnitAmenity findUniqueOrThrow
   */
  export type UnitAmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAmenity
     */
    select?: UnitAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAmenity
     */
    omit?: UnitAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAmenityInclude<ExtArgs> | null
    /**
     * Filter, which UnitAmenity to fetch.
     */
    where: UnitAmenityWhereUniqueInput
  }

  /**
   * UnitAmenity findFirst
   */
  export type UnitAmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAmenity
     */
    select?: UnitAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAmenity
     */
    omit?: UnitAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAmenityInclude<ExtArgs> | null
    /**
     * Filter, which UnitAmenity to fetch.
     */
    where?: UnitAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAmenities to fetch.
     */
    orderBy?: UnitAmenityOrderByWithRelationInput | UnitAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitAmenities.
     */
    cursor?: UnitAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitAmenities.
     */
    distinct?: UnitAmenityScalarFieldEnum | UnitAmenityScalarFieldEnum[]
  }

  /**
   * UnitAmenity findFirstOrThrow
   */
  export type UnitAmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAmenity
     */
    select?: UnitAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAmenity
     */
    omit?: UnitAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAmenityInclude<ExtArgs> | null
    /**
     * Filter, which UnitAmenity to fetch.
     */
    where?: UnitAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAmenities to fetch.
     */
    orderBy?: UnitAmenityOrderByWithRelationInput | UnitAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitAmenities.
     */
    cursor?: UnitAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitAmenities.
     */
    distinct?: UnitAmenityScalarFieldEnum | UnitAmenityScalarFieldEnum[]
  }

  /**
   * UnitAmenity findMany
   */
  export type UnitAmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAmenity
     */
    select?: UnitAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAmenity
     */
    omit?: UnitAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAmenityInclude<ExtArgs> | null
    /**
     * Filter, which UnitAmenities to fetch.
     */
    where?: UnitAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAmenities to fetch.
     */
    orderBy?: UnitAmenityOrderByWithRelationInput | UnitAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitAmenities.
     */
    cursor?: UnitAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAmenities.
     */
    skip?: number
    distinct?: UnitAmenityScalarFieldEnum | UnitAmenityScalarFieldEnum[]
  }

  /**
   * UnitAmenity create
   */
  export type UnitAmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAmenity
     */
    select?: UnitAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAmenity
     */
    omit?: UnitAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitAmenity.
     */
    data: XOR<UnitAmenityCreateInput, UnitAmenityUncheckedCreateInput>
  }

  /**
   * UnitAmenity createMany
   */
  export type UnitAmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitAmenities.
     */
    data: UnitAmenityCreateManyInput | UnitAmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitAmenity createManyAndReturn
   */
  export type UnitAmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAmenity
     */
    select?: UnitAmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAmenity
     */
    omit?: UnitAmenityOmit<ExtArgs> | null
    /**
     * The data used to create many UnitAmenities.
     */
    data: UnitAmenityCreateManyInput | UnitAmenityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAmenityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitAmenity update
   */
  export type UnitAmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAmenity
     */
    select?: UnitAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAmenity
     */
    omit?: UnitAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitAmenity.
     */
    data: XOR<UnitAmenityUpdateInput, UnitAmenityUncheckedUpdateInput>
    /**
     * Choose, which UnitAmenity to update.
     */
    where: UnitAmenityWhereUniqueInput
  }

  /**
   * UnitAmenity updateMany
   */
  export type UnitAmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitAmenities.
     */
    data: XOR<UnitAmenityUpdateManyMutationInput, UnitAmenityUncheckedUpdateManyInput>
    /**
     * Filter which UnitAmenities to update
     */
    where?: UnitAmenityWhereInput
    /**
     * Limit how many UnitAmenities to update.
     */
    limit?: number
  }

  /**
   * UnitAmenity updateManyAndReturn
   */
  export type UnitAmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAmenity
     */
    select?: UnitAmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAmenity
     */
    omit?: UnitAmenityOmit<ExtArgs> | null
    /**
     * The data used to update UnitAmenities.
     */
    data: XOR<UnitAmenityUpdateManyMutationInput, UnitAmenityUncheckedUpdateManyInput>
    /**
     * Filter which UnitAmenities to update
     */
    where?: UnitAmenityWhereInput
    /**
     * Limit how many UnitAmenities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAmenityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitAmenity upsert
   */
  export type UnitAmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAmenity
     */
    select?: UnitAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAmenity
     */
    omit?: UnitAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitAmenity to update in case it exists.
     */
    where: UnitAmenityWhereUniqueInput
    /**
     * In case the UnitAmenity found by the `where` argument doesn't exist, create a new UnitAmenity with this data.
     */
    create: XOR<UnitAmenityCreateInput, UnitAmenityUncheckedCreateInput>
    /**
     * In case the UnitAmenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitAmenityUpdateInput, UnitAmenityUncheckedUpdateInput>
  }

  /**
   * UnitAmenity delete
   */
  export type UnitAmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAmenity
     */
    select?: UnitAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAmenity
     */
    omit?: UnitAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAmenityInclude<ExtArgs> | null
    /**
     * Filter which UnitAmenity to delete.
     */
    where: UnitAmenityWhereUniqueInput
  }

  /**
   * UnitAmenity deleteMany
   */
  export type UnitAmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitAmenities to delete
     */
    where?: UnitAmenityWhereInput
    /**
     * Limit how many UnitAmenities to delete.
     */
    limit?: number
  }

  /**
   * UnitAmenity without action
   */
  export type UnitAmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAmenity
     */
    select?: UnitAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAmenity
     */
    omit?: UnitAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAmenityInclude<ExtArgs> | null
  }


  /**
   * Model UnitService
   */

  export type AggregateUnitService = {
    _count: UnitServiceCountAggregateOutputType | null
    _avg: UnitServiceAvgAggregateOutputType | null
    _sum: UnitServiceSumAggregateOutputType | null
    _min: UnitServiceMinAggregateOutputType | null
    _max: UnitServiceMaxAggregateOutputType | null
  }

  export type UnitServiceAvgAggregateOutputType = {
    custom_price_cents: number | null
    custom_duration_minutes: number | null
  }

  export type UnitServiceSumAggregateOutputType = {
    custom_price_cents: number | null
    custom_duration_minutes: number | null
  }

  export type UnitServiceMinAggregateOutputType = {
    id: string | null
    unit_id: string | null
    service_id: string | null
    custom_price_cents: number | null
    custom_duration_minutes: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UnitServiceMaxAggregateOutputType = {
    id: string | null
    unit_id: string | null
    service_id: string | null
    custom_price_cents: number | null
    custom_duration_minutes: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UnitServiceCountAggregateOutputType = {
    id: number
    unit_id: number
    service_id: number
    custom_price_cents: number
    custom_duration_minutes: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UnitServiceAvgAggregateInputType = {
    custom_price_cents?: true
    custom_duration_minutes?: true
  }

  export type UnitServiceSumAggregateInputType = {
    custom_price_cents?: true
    custom_duration_minutes?: true
  }

  export type UnitServiceMinAggregateInputType = {
    id?: true
    unit_id?: true
    service_id?: true
    custom_price_cents?: true
    custom_duration_minutes?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type UnitServiceMaxAggregateInputType = {
    id?: true
    unit_id?: true
    service_id?: true
    custom_price_cents?: true
    custom_duration_minutes?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type UnitServiceCountAggregateInputType = {
    id?: true
    unit_id?: true
    service_id?: true
    custom_price_cents?: true
    custom_duration_minutes?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UnitServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitService to aggregate.
     */
    where?: UnitServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitServices to fetch.
     */
    orderBy?: UnitServiceOrderByWithRelationInput | UnitServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitServices
    **/
    _count?: true | UnitServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitServiceMaxAggregateInputType
  }

  export type GetUnitServiceAggregateType<T extends UnitServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitService[P]>
      : GetScalarType<T[P], AggregateUnitService[P]>
  }




  export type UnitServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitServiceWhereInput
    orderBy?: UnitServiceOrderByWithAggregationInput | UnitServiceOrderByWithAggregationInput[]
    by: UnitServiceScalarFieldEnum[] | UnitServiceScalarFieldEnum
    having?: UnitServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitServiceCountAggregateInputType | true
    _avg?: UnitServiceAvgAggregateInputType
    _sum?: UnitServiceSumAggregateInputType
    _min?: UnitServiceMinAggregateInputType
    _max?: UnitServiceMaxAggregateInputType
  }

  export type UnitServiceGroupByOutputType = {
    id: string
    unit_id: string
    service_id: string
    custom_price_cents: number | null
    custom_duration_minutes: number | null
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: UnitServiceCountAggregateOutputType | null
    _avg: UnitServiceAvgAggregateOutputType | null
    _sum: UnitServiceSumAggregateOutputType | null
    _min: UnitServiceMinAggregateOutputType | null
    _max: UnitServiceMaxAggregateOutputType | null
  }

  type GetUnitServiceGroupByPayload<T extends UnitServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitServiceGroupByOutputType[P]>
            : GetScalarType<T[P], UnitServiceGroupByOutputType[P]>
        }
      >
    >


  export type UnitServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    service_id?: boolean
    custom_price_cents?: boolean
    custom_duration_minutes?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitService"]>

  export type UnitServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    service_id?: boolean
    custom_price_cents?: boolean
    custom_duration_minutes?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitService"]>

  export type UnitServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    service_id?: boolean
    custom_price_cents?: boolean
    custom_duration_minutes?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitService"]>

  export type UnitServiceSelectScalar = {
    id?: boolean
    unit_id?: boolean
    service_id?: boolean
    custom_price_cents?: boolean
    custom_duration_minutes?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UnitServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unit_id" | "service_id" | "custom_price_cents" | "custom_duration_minutes" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["unitService"]>
  export type UnitServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type UnitServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type UnitServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $UnitServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitService"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unit_id: string
      service_id: string
      custom_price_cents: number | null
      custom_duration_minutes: number | null
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["unitService"]>
    composites: {}
  }

  type UnitServiceGetPayload<S extends boolean | null | undefined | UnitServiceDefaultArgs> = $Result.GetResult<Prisma.$UnitServicePayload, S>

  type UnitServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitServiceCountAggregateInputType | true
    }

  export interface UnitServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitService'], meta: { name: 'UnitService' } }
    /**
     * Find zero or one UnitService that matches the filter.
     * @param {UnitServiceFindUniqueArgs} args - Arguments to find a UnitService
     * @example
     * // Get one UnitService
     * const unitService = await prisma.unitService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitServiceFindUniqueArgs>(args: SelectSubset<T, UnitServiceFindUniqueArgs<ExtArgs>>): Prisma__UnitServiceClient<$Result.GetResult<Prisma.$UnitServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitServiceFindUniqueOrThrowArgs} args - Arguments to find a UnitService
     * @example
     * // Get one UnitService
     * const unitService = await prisma.unitService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitServiceClient<$Result.GetResult<Prisma.$UnitServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitServiceFindFirstArgs} args - Arguments to find a UnitService
     * @example
     * // Get one UnitService
     * const unitService = await prisma.unitService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitServiceFindFirstArgs>(args?: SelectSubset<T, UnitServiceFindFirstArgs<ExtArgs>>): Prisma__UnitServiceClient<$Result.GetResult<Prisma.$UnitServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitServiceFindFirstOrThrowArgs} args - Arguments to find a UnitService
     * @example
     * // Get one UnitService
     * const unitService = await prisma.unitService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitServiceClient<$Result.GetResult<Prisma.$UnitServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitServices
     * const unitServices = await prisma.unitService.findMany()
     * 
     * // Get first 10 UnitServices
     * const unitServices = await prisma.unitService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitServiceWithIdOnly = await prisma.unitService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitServiceFindManyArgs>(args?: SelectSubset<T, UnitServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitService.
     * @param {UnitServiceCreateArgs} args - Arguments to create a UnitService.
     * @example
     * // Create one UnitService
     * const UnitService = await prisma.unitService.create({
     *   data: {
     *     // ... data to create a UnitService
     *   }
     * })
     * 
     */
    create<T extends UnitServiceCreateArgs>(args: SelectSubset<T, UnitServiceCreateArgs<ExtArgs>>): Prisma__UnitServiceClient<$Result.GetResult<Prisma.$UnitServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitServices.
     * @param {UnitServiceCreateManyArgs} args - Arguments to create many UnitServices.
     * @example
     * // Create many UnitServices
     * const unitService = await prisma.unitService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitServiceCreateManyArgs>(args?: SelectSubset<T, UnitServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitServices and returns the data saved in the database.
     * @param {UnitServiceCreateManyAndReturnArgs} args - Arguments to create many UnitServices.
     * @example
     * // Create many UnitServices
     * const unitService = await prisma.unitService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitServices and only return the `id`
     * const unitServiceWithIdOnly = await prisma.unitService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitService.
     * @param {UnitServiceDeleteArgs} args - Arguments to delete one UnitService.
     * @example
     * // Delete one UnitService
     * const UnitService = await prisma.unitService.delete({
     *   where: {
     *     // ... filter to delete one UnitService
     *   }
     * })
     * 
     */
    delete<T extends UnitServiceDeleteArgs>(args: SelectSubset<T, UnitServiceDeleteArgs<ExtArgs>>): Prisma__UnitServiceClient<$Result.GetResult<Prisma.$UnitServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitService.
     * @param {UnitServiceUpdateArgs} args - Arguments to update one UnitService.
     * @example
     * // Update one UnitService
     * const unitService = await prisma.unitService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitServiceUpdateArgs>(args: SelectSubset<T, UnitServiceUpdateArgs<ExtArgs>>): Prisma__UnitServiceClient<$Result.GetResult<Prisma.$UnitServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitServices.
     * @param {UnitServiceDeleteManyArgs} args - Arguments to filter UnitServices to delete.
     * @example
     * // Delete a few UnitServices
     * const { count } = await prisma.unitService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitServiceDeleteManyArgs>(args?: SelectSubset<T, UnitServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitServices
     * const unitService = await prisma.unitService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitServiceUpdateManyArgs>(args: SelectSubset<T, UnitServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitServices and returns the data updated in the database.
     * @param {UnitServiceUpdateManyAndReturnArgs} args - Arguments to update many UnitServices.
     * @example
     * // Update many UnitServices
     * const unitService = await prisma.unitService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitServices and only return the `id`
     * const unitServiceWithIdOnly = await prisma.unitService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitService.
     * @param {UnitServiceUpsertArgs} args - Arguments to update or create a UnitService.
     * @example
     * // Update or create a UnitService
     * const unitService = await prisma.unitService.upsert({
     *   create: {
     *     // ... data to create a UnitService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitService we want to update
     *   }
     * })
     */
    upsert<T extends UnitServiceUpsertArgs>(args: SelectSubset<T, UnitServiceUpsertArgs<ExtArgs>>): Prisma__UnitServiceClient<$Result.GetResult<Prisma.$UnitServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitServiceCountArgs} args - Arguments to filter UnitServices to count.
     * @example
     * // Count the number of UnitServices
     * const count = await prisma.unitService.count({
     *   where: {
     *     // ... the filter for the UnitServices we want to count
     *   }
     * })
    **/
    count<T extends UnitServiceCountArgs>(
      args?: Subset<T, UnitServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitServiceAggregateArgs>(args: Subset<T, UnitServiceAggregateArgs>): Prisma.PrismaPromise<GetUnitServiceAggregateType<T>>

    /**
     * Group by UnitService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitServiceGroupByArgs['orderBy'] }
        : { orderBy?: UnitServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitService model
   */
  readonly fields: UnitServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitService model
   */
  interface UnitServiceFieldRefs {
    readonly id: FieldRef<"UnitService", 'String'>
    readonly unit_id: FieldRef<"UnitService", 'String'>
    readonly service_id: FieldRef<"UnitService", 'String'>
    readonly custom_price_cents: FieldRef<"UnitService", 'Int'>
    readonly custom_duration_minutes: FieldRef<"UnitService", 'Int'>
    readonly is_active: FieldRef<"UnitService", 'Boolean'>
    readonly created_at: FieldRef<"UnitService", 'DateTime'>
    readonly updated_at: FieldRef<"UnitService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitService findUnique
   */
  export type UnitServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitService
     */
    select?: UnitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitService
     */
    omit?: UnitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceInclude<ExtArgs> | null
    /**
     * Filter, which UnitService to fetch.
     */
    where: UnitServiceWhereUniqueInput
  }

  /**
   * UnitService findUniqueOrThrow
   */
  export type UnitServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitService
     */
    select?: UnitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitService
     */
    omit?: UnitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceInclude<ExtArgs> | null
    /**
     * Filter, which UnitService to fetch.
     */
    where: UnitServiceWhereUniqueInput
  }

  /**
   * UnitService findFirst
   */
  export type UnitServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitService
     */
    select?: UnitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitService
     */
    omit?: UnitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceInclude<ExtArgs> | null
    /**
     * Filter, which UnitService to fetch.
     */
    where?: UnitServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitServices to fetch.
     */
    orderBy?: UnitServiceOrderByWithRelationInput | UnitServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitServices.
     */
    cursor?: UnitServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitServices.
     */
    distinct?: UnitServiceScalarFieldEnum | UnitServiceScalarFieldEnum[]
  }

  /**
   * UnitService findFirstOrThrow
   */
  export type UnitServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitService
     */
    select?: UnitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitService
     */
    omit?: UnitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceInclude<ExtArgs> | null
    /**
     * Filter, which UnitService to fetch.
     */
    where?: UnitServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitServices to fetch.
     */
    orderBy?: UnitServiceOrderByWithRelationInput | UnitServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitServices.
     */
    cursor?: UnitServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitServices.
     */
    distinct?: UnitServiceScalarFieldEnum | UnitServiceScalarFieldEnum[]
  }

  /**
   * UnitService findMany
   */
  export type UnitServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitService
     */
    select?: UnitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitService
     */
    omit?: UnitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceInclude<ExtArgs> | null
    /**
     * Filter, which UnitServices to fetch.
     */
    where?: UnitServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitServices to fetch.
     */
    orderBy?: UnitServiceOrderByWithRelationInput | UnitServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitServices.
     */
    cursor?: UnitServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitServices.
     */
    skip?: number
    distinct?: UnitServiceScalarFieldEnum | UnitServiceScalarFieldEnum[]
  }

  /**
   * UnitService create
   */
  export type UnitServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitService
     */
    select?: UnitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitService
     */
    omit?: UnitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitService.
     */
    data: XOR<UnitServiceCreateInput, UnitServiceUncheckedCreateInput>
  }

  /**
   * UnitService createMany
   */
  export type UnitServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitServices.
     */
    data: UnitServiceCreateManyInput | UnitServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitService createManyAndReturn
   */
  export type UnitServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitService
     */
    select?: UnitServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitService
     */
    omit?: UnitServiceOmit<ExtArgs> | null
    /**
     * The data used to create many UnitServices.
     */
    data: UnitServiceCreateManyInput | UnitServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitService update
   */
  export type UnitServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitService
     */
    select?: UnitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitService
     */
    omit?: UnitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitService.
     */
    data: XOR<UnitServiceUpdateInput, UnitServiceUncheckedUpdateInput>
    /**
     * Choose, which UnitService to update.
     */
    where: UnitServiceWhereUniqueInput
  }

  /**
   * UnitService updateMany
   */
  export type UnitServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitServices.
     */
    data: XOR<UnitServiceUpdateManyMutationInput, UnitServiceUncheckedUpdateManyInput>
    /**
     * Filter which UnitServices to update
     */
    where?: UnitServiceWhereInput
    /**
     * Limit how many UnitServices to update.
     */
    limit?: number
  }

  /**
   * UnitService updateManyAndReturn
   */
  export type UnitServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitService
     */
    select?: UnitServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitService
     */
    omit?: UnitServiceOmit<ExtArgs> | null
    /**
     * The data used to update UnitServices.
     */
    data: XOR<UnitServiceUpdateManyMutationInput, UnitServiceUncheckedUpdateManyInput>
    /**
     * Filter which UnitServices to update
     */
    where?: UnitServiceWhereInput
    /**
     * Limit how many UnitServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitService upsert
   */
  export type UnitServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitService
     */
    select?: UnitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitService
     */
    omit?: UnitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitService to update in case it exists.
     */
    where: UnitServiceWhereUniqueInput
    /**
     * In case the UnitService found by the `where` argument doesn't exist, create a new UnitService with this data.
     */
    create: XOR<UnitServiceCreateInput, UnitServiceUncheckedCreateInput>
    /**
     * In case the UnitService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitServiceUpdateInput, UnitServiceUncheckedUpdateInput>
  }

  /**
   * UnitService delete
   */
  export type UnitServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitService
     */
    select?: UnitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitService
     */
    omit?: UnitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceInclude<ExtArgs> | null
    /**
     * Filter which UnitService to delete.
     */
    where: UnitServiceWhereUniqueInput
  }

  /**
   * UnitService deleteMany
   */
  export type UnitServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitServices to delete
     */
    where?: UnitServiceWhereInput
    /**
     * Limit how many UnitServices to delete.
     */
    limit?: number
  }

  /**
   * UnitService without action
   */
  export type UnitServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitService
     */
    select?: UnitServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitService
     */
    omit?: UnitServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitServiceInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    price_cents: number | null
  }

  export type BookingSumAggregateOutputType = {
    price_cents: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    client_id: string | null
    unit_id: string | null
    service_id: string | null
    price_cents: number | null
    notes: string | null
    start_at: Date | null
    end_at: Date | null
    status: $Enums.BookingStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    client_id: string | null
    unit_id: string | null
    service_id: string | null
    price_cents: number | null
    notes: string | null
    start_at: Date | null
    end_at: Date | null
    status: $Enums.BookingStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    user_id: number
    client_id: number
    unit_id: number
    service_id: number
    price_cents: number
    notes: number
    start_at: number
    end_at: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    price_cents?: true
  }

  export type BookingSumAggregateInputType = {
    price_cents?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    user_id?: true
    client_id?: true
    unit_id?: true
    service_id?: true
    price_cents?: true
    notes?: true
    start_at?: true
    end_at?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    user_id?: true
    client_id?: true
    unit_id?: true
    service_id?: true
    price_cents?: true
    notes?: true
    start_at?: true
    end_at?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    user_id?: true
    client_id?: true
    unit_id?: true
    service_id?: true
    price_cents?: true
    notes?: true
    start_at?: true
    end_at?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    user_id: string
    client_id: string
    unit_id: string
    service_id: string | null
    price_cents: number | null
    notes: string | null
    start_at: Date
    end_at: Date
    status: $Enums.BookingStatus
    created_at: Date
    updated_at: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    client_id?: boolean
    unit_id?: boolean
    service_id?: boolean
    price_cents?: boolean
    notes?: boolean
    start_at?: boolean
    end_at?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    service?: boolean | Booking$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    client_id?: boolean
    unit_id?: boolean
    service_id?: boolean
    price_cents?: boolean
    notes?: boolean
    start_at?: boolean
    end_at?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    service?: boolean | Booking$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    client_id?: boolean
    unit_id?: boolean
    service_id?: boolean
    price_cents?: boolean
    notes?: boolean
    start_at?: boolean
    end_at?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    service?: boolean | Booking$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    user_id?: boolean
    client_id?: boolean
    unit_id?: boolean
    service_id?: boolean
    price_cents?: boolean
    notes?: boolean
    start_at?: boolean
    end_at?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "client_id" | "unit_id" | "service_id" | "price_cents" | "notes" | "start_at" | "end_at" | "status" | "created_at" | "updated_at", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    service?: boolean | Booking$serviceArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    service?: boolean | Booking$serviceArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    service?: boolean | Booking$serviceArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      client: Prisma.$UserPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      client_id: string
      unit_id: string
      service_id: string | null
      price_cents: number | null
      notes: string | null
      start_at: Date
      end_at: Date
      status: $Enums.BookingStatus
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends Booking$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Booking$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly user_id: FieldRef<"Booking", 'String'>
    readonly client_id: FieldRef<"Booking", 'String'>
    readonly unit_id: FieldRef<"Booking", 'String'>
    readonly service_id: FieldRef<"Booking", 'String'>
    readonly price_cents: FieldRef<"Booking", 'Int'>
    readonly notes: FieldRef<"Booking", 'String'>
    readonly start_at: FieldRef<"Booking", 'DateTime'>
    readonly end_at: FieldRef<"Booking", 'DateTime'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly created_at: FieldRef<"Booking", 'DateTime'>
    readonly updated_at: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.service
   */
  export type Booking$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    unit_id: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    unit_id: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    user_id: number
    unit_id: number
    notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    user_id?: true
    unit_id?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    user_id?: true
    unit_id?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    user_id?: true
    unit_id?: true
    notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    user_id: string
    unit_id: string
    notes: string | null
    created_at: Date
    updated_at: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    unit_id?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    unit_id?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    unit_id?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    user_id?: boolean
    unit_id?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "unit_id" | "notes" | "created_at" | "updated_at", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      unit_id: string
      notes: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly user_id: FieldRef<"Customer", 'String'>
    readonly unit_id: FieldRef<"Customer", 'String'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly created_at: FieldRef<"Customer", 'DateTime'>
    readonly updated_at: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model BookingRule
   */

  export type AggregateBookingRule = {
    _count: BookingRuleCountAggregateOutputType | null
    _avg: BookingRuleAvgAggregateOutputType | null
    _sum: BookingRuleSumAggregateOutputType | null
    _min: BookingRuleMinAggregateOutputType | null
    _max: BookingRuleMaxAggregateOutputType | null
  }

  export type BookingRuleAvgAggregateOutputType = {
    weekday: number | null
    slot_duration_minutes: number | null
    min_advance_minutes: number | null
    max_duration_minutes: number | null
    max_bookings_per_day: number | null
    max_bookings_per_client_per_day: number | null
  }

  export type BookingRuleSumAggregateOutputType = {
    weekday: number | null
    slot_duration_minutes: number | null
    min_advance_minutes: number | null
    max_duration_minutes: number | null
    max_bookings_per_day: number | null
    max_bookings_per_client_per_day: number | null
  }

  export type BookingRuleMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    type: $Enums.BookingRuleType | null
    weekday: number | null
    date: string | null
    start_time: Date | null
    end_time: Date | null
    slot_duration_minutes: number | null
    min_advance_minutes: number | null
    max_duration_minutes: number | null
    max_bookings_per_day: number | null
    max_bookings_per_client_per_day: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BookingRuleMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    type: $Enums.BookingRuleType | null
    weekday: number | null
    date: string | null
    start_time: Date | null
    end_time: Date | null
    slot_duration_minutes: number | null
    min_advance_minutes: number | null
    max_duration_minutes: number | null
    max_bookings_per_day: number | null
    max_bookings_per_client_per_day: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BookingRuleCountAggregateOutputType = {
    id: number
    user_id: number
    type: number
    weekday: number
    date: number
    start_time: number
    end_time: number
    slot_duration_minutes: number
    min_advance_minutes: number
    max_duration_minutes: number
    max_bookings_per_day: number
    max_bookings_per_client_per_day: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BookingRuleAvgAggregateInputType = {
    weekday?: true
    slot_duration_minutes?: true
    min_advance_minutes?: true
    max_duration_minutes?: true
    max_bookings_per_day?: true
    max_bookings_per_client_per_day?: true
  }

  export type BookingRuleSumAggregateInputType = {
    weekday?: true
    slot_duration_minutes?: true
    min_advance_minutes?: true
    max_duration_minutes?: true
    max_bookings_per_day?: true
    max_bookings_per_client_per_day?: true
  }

  export type BookingRuleMinAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    weekday?: true
    date?: true
    start_time?: true
    end_time?: true
    slot_duration_minutes?: true
    min_advance_minutes?: true
    max_duration_minutes?: true
    max_bookings_per_day?: true
    max_bookings_per_client_per_day?: true
    created_at?: true
    updated_at?: true
  }

  export type BookingRuleMaxAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    weekday?: true
    date?: true
    start_time?: true
    end_time?: true
    slot_duration_minutes?: true
    min_advance_minutes?: true
    max_duration_minutes?: true
    max_bookings_per_day?: true
    max_bookings_per_client_per_day?: true
    created_at?: true
    updated_at?: true
  }

  export type BookingRuleCountAggregateInputType = {
    id?: true
    user_id?: true
    type?: true
    weekday?: true
    date?: true
    start_time?: true
    end_time?: true
    slot_duration_minutes?: true
    min_advance_minutes?: true
    max_duration_minutes?: true
    max_bookings_per_day?: true
    max_bookings_per_client_per_day?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BookingRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingRule to aggregate.
     */
    where?: BookingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRules to fetch.
     */
    orderBy?: BookingRuleOrderByWithRelationInput | BookingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingRules
    **/
    _count?: true | BookingRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingRuleMaxAggregateInputType
  }

  export type GetBookingRuleAggregateType<T extends BookingRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingRule[P]>
      : GetScalarType<T[P], AggregateBookingRule[P]>
  }




  export type BookingRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRuleWhereInput
    orderBy?: BookingRuleOrderByWithAggregationInput | BookingRuleOrderByWithAggregationInput[]
    by: BookingRuleScalarFieldEnum[] | BookingRuleScalarFieldEnum
    having?: BookingRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingRuleCountAggregateInputType | true
    _avg?: BookingRuleAvgAggregateInputType
    _sum?: BookingRuleSumAggregateInputType
    _min?: BookingRuleMinAggregateInputType
    _max?: BookingRuleMaxAggregateInputType
  }

  export type BookingRuleGroupByOutputType = {
    id: string
    user_id: string
    type: $Enums.BookingRuleType
    weekday: number | null
    date: string | null
    start_time: Date
    end_time: Date
    slot_duration_minutes: number
    min_advance_minutes: number | null
    max_duration_minutes: number | null
    max_bookings_per_day: number | null
    max_bookings_per_client_per_day: number | null
    metadata: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: BookingRuleCountAggregateOutputType | null
    _avg: BookingRuleAvgAggregateOutputType | null
    _sum: BookingRuleSumAggregateOutputType | null
    _min: BookingRuleMinAggregateOutputType | null
    _max: BookingRuleMaxAggregateOutputType | null
  }

  type GetBookingRuleGroupByPayload<T extends BookingRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingRuleGroupByOutputType[P]>
            : GetScalarType<T[P], BookingRuleGroupByOutputType[P]>
        }
      >
    >


  export type BookingRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    weekday?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    min_advance_minutes?: boolean
    max_duration_minutes?: boolean
    max_bookings_per_day?: boolean
    max_bookings_per_client_per_day?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingRule"]>

  export type BookingRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    weekday?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    min_advance_minutes?: boolean
    max_duration_minutes?: boolean
    max_bookings_per_day?: boolean
    max_bookings_per_client_per_day?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingRule"]>

  export type BookingRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    type?: boolean
    weekday?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    min_advance_minutes?: boolean
    max_duration_minutes?: boolean
    max_bookings_per_day?: boolean
    max_bookings_per_client_per_day?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingRule"]>

  export type BookingRuleSelectScalar = {
    id?: boolean
    user_id?: boolean
    type?: boolean
    weekday?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    min_advance_minutes?: boolean
    max_duration_minutes?: boolean
    max_bookings_per_day?: boolean
    max_bookings_per_client_per_day?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BookingRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "type" | "weekday" | "date" | "start_time" | "end_time" | "slot_duration_minutes" | "min_advance_minutes" | "max_duration_minutes" | "max_bookings_per_day" | "max_bookings_per_client_per_day" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["bookingRule"]>
  export type BookingRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BookingRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingRule"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      type: $Enums.BookingRuleType
      weekday: number | null
      date: string | null
      start_time: Date
      end_time: Date
      slot_duration_minutes: number
      min_advance_minutes: number | null
      max_duration_minutes: number | null
      max_bookings_per_day: number | null
      max_bookings_per_client_per_day: number | null
      metadata: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["bookingRule"]>
    composites: {}
  }

  type BookingRuleGetPayload<S extends boolean | null | undefined | BookingRuleDefaultArgs> = $Result.GetResult<Prisma.$BookingRulePayload, S>

  type BookingRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingRuleCountAggregateInputType | true
    }

  export interface BookingRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingRule'], meta: { name: 'BookingRule' } }
    /**
     * Find zero or one BookingRule that matches the filter.
     * @param {BookingRuleFindUniqueArgs} args - Arguments to find a BookingRule
     * @example
     * // Get one BookingRule
     * const bookingRule = await prisma.bookingRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingRuleFindUniqueArgs>(args: SelectSubset<T, BookingRuleFindUniqueArgs<ExtArgs>>): Prisma__BookingRuleClient<$Result.GetResult<Prisma.$BookingRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingRuleFindUniqueOrThrowArgs} args - Arguments to find a BookingRule
     * @example
     * // Get one BookingRule
     * const bookingRule = await prisma.bookingRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingRuleClient<$Result.GetResult<Prisma.$BookingRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRuleFindFirstArgs} args - Arguments to find a BookingRule
     * @example
     * // Get one BookingRule
     * const bookingRule = await prisma.bookingRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingRuleFindFirstArgs>(args?: SelectSubset<T, BookingRuleFindFirstArgs<ExtArgs>>): Prisma__BookingRuleClient<$Result.GetResult<Prisma.$BookingRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRuleFindFirstOrThrowArgs} args - Arguments to find a BookingRule
     * @example
     * // Get one BookingRule
     * const bookingRule = await prisma.bookingRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingRuleClient<$Result.GetResult<Prisma.$BookingRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingRules
     * const bookingRules = await prisma.bookingRule.findMany()
     * 
     * // Get first 10 BookingRules
     * const bookingRules = await prisma.bookingRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingRuleWithIdOnly = await prisma.bookingRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingRuleFindManyArgs>(args?: SelectSubset<T, BookingRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingRule.
     * @param {BookingRuleCreateArgs} args - Arguments to create a BookingRule.
     * @example
     * // Create one BookingRule
     * const BookingRule = await prisma.bookingRule.create({
     *   data: {
     *     // ... data to create a BookingRule
     *   }
     * })
     * 
     */
    create<T extends BookingRuleCreateArgs>(args: SelectSubset<T, BookingRuleCreateArgs<ExtArgs>>): Prisma__BookingRuleClient<$Result.GetResult<Prisma.$BookingRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingRules.
     * @param {BookingRuleCreateManyArgs} args - Arguments to create many BookingRules.
     * @example
     * // Create many BookingRules
     * const bookingRule = await prisma.bookingRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingRuleCreateManyArgs>(args?: SelectSubset<T, BookingRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingRules and returns the data saved in the database.
     * @param {BookingRuleCreateManyAndReturnArgs} args - Arguments to create many BookingRules.
     * @example
     * // Create many BookingRules
     * const bookingRule = await prisma.bookingRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingRules and only return the `id`
     * const bookingRuleWithIdOnly = await prisma.bookingRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingRule.
     * @param {BookingRuleDeleteArgs} args - Arguments to delete one BookingRule.
     * @example
     * // Delete one BookingRule
     * const BookingRule = await prisma.bookingRule.delete({
     *   where: {
     *     // ... filter to delete one BookingRule
     *   }
     * })
     * 
     */
    delete<T extends BookingRuleDeleteArgs>(args: SelectSubset<T, BookingRuleDeleteArgs<ExtArgs>>): Prisma__BookingRuleClient<$Result.GetResult<Prisma.$BookingRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingRule.
     * @param {BookingRuleUpdateArgs} args - Arguments to update one BookingRule.
     * @example
     * // Update one BookingRule
     * const bookingRule = await prisma.bookingRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingRuleUpdateArgs>(args: SelectSubset<T, BookingRuleUpdateArgs<ExtArgs>>): Prisma__BookingRuleClient<$Result.GetResult<Prisma.$BookingRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingRules.
     * @param {BookingRuleDeleteManyArgs} args - Arguments to filter BookingRules to delete.
     * @example
     * // Delete a few BookingRules
     * const { count } = await prisma.bookingRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingRuleDeleteManyArgs>(args?: SelectSubset<T, BookingRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingRules
     * const bookingRule = await prisma.bookingRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingRuleUpdateManyArgs>(args: SelectSubset<T, BookingRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingRules and returns the data updated in the database.
     * @param {BookingRuleUpdateManyAndReturnArgs} args - Arguments to update many BookingRules.
     * @example
     * // Update many BookingRules
     * const bookingRule = await prisma.bookingRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingRules and only return the `id`
     * const bookingRuleWithIdOnly = await prisma.bookingRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingRule.
     * @param {BookingRuleUpsertArgs} args - Arguments to update or create a BookingRule.
     * @example
     * // Update or create a BookingRule
     * const bookingRule = await prisma.bookingRule.upsert({
     *   create: {
     *     // ... data to create a BookingRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingRule we want to update
     *   }
     * })
     */
    upsert<T extends BookingRuleUpsertArgs>(args: SelectSubset<T, BookingRuleUpsertArgs<ExtArgs>>): Prisma__BookingRuleClient<$Result.GetResult<Prisma.$BookingRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRuleCountArgs} args - Arguments to filter BookingRules to count.
     * @example
     * // Count the number of BookingRules
     * const count = await prisma.bookingRule.count({
     *   where: {
     *     // ... the filter for the BookingRules we want to count
     *   }
     * })
    **/
    count<T extends BookingRuleCountArgs>(
      args?: Subset<T, BookingRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingRuleAggregateArgs>(args: Subset<T, BookingRuleAggregateArgs>): Prisma.PrismaPromise<GetBookingRuleAggregateType<T>>

    /**
     * Group by BookingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingRuleGroupByArgs['orderBy'] }
        : { orderBy?: BookingRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingRule model
   */
  readonly fields: BookingRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingRule model
   */
  interface BookingRuleFieldRefs {
    readonly id: FieldRef<"BookingRule", 'String'>
    readonly user_id: FieldRef<"BookingRule", 'String'>
    readonly type: FieldRef<"BookingRule", 'BookingRuleType'>
    readonly weekday: FieldRef<"BookingRule", 'Int'>
    readonly date: FieldRef<"BookingRule", 'String'>
    readonly start_time: FieldRef<"BookingRule", 'DateTime'>
    readonly end_time: FieldRef<"BookingRule", 'DateTime'>
    readonly slot_duration_minutes: FieldRef<"BookingRule", 'Int'>
    readonly min_advance_minutes: FieldRef<"BookingRule", 'Int'>
    readonly max_duration_minutes: FieldRef<"BookingRule", 'Int'>
    readonly max_bookings_per_day: FieldRef<"BookingRule", 'Int'>
    readonly max_bookings_per_client_per_day: FieldRef<"BookingRule", 'Int'>
    readonly metadata: FieldRef<"BookingRule", 'Json'>
    readonly created_at: FieldRef<"BookingRule", 'DateTime'>
    readonly updated_at: FieldRef<"BookingRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingRule findUnique
   */
  export type BookingRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRule
     */
    select?: BookingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRule
     */
    omit?: BookingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRuleInclude<ExtArgs> | null
    /**
     * Filter, which BookingRule to fetch.
     */
    where: BookingRuleWhereUniqueInput
  }

  /**
   * BookingRule findUniqueOrThrow
   */
  export type BookingRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRule
     */
    select?: BookingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRule
     */
    omit?: BookingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRuleInclude<ExtArgs> | null
    /**
     * Filter, which BookingRule to fetch.
     */
    where: BookingRuleWhereUniqueInput
  }

  /**
   * BookingRule findFirst
   */
  export type BookingRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRule
     */
    select?: BookingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRule
     */
    omit?: BookingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRuleInclude<ExtArgs> | null
    /**
     * Filter, which BookingRule to fetch.
     */
    where?: BookingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRules to fetch.
     */
    orderBy?: BookingRuleOrderByWithRelationInput | BookingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingRules.
     */
    cursor?: BookingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingRules.
     */
    distinct?: BookingRuleScalarFieldEnum | BookingRuleScalarFieldEnum[]
  }

  /**
   * BookingRule findFirstOrThrow
   */
  export type BookingRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRule
     */
    select?: BookingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRule
     */
    omit?: BookingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRuleInclude<ExtArgs> | null
    /**
     * Filter, which BookingRule to fetch.
     */
    where?: BookingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRules to fetch.
     */
    orderBy?: BookingRuleOrderByWithRelationInput | BookingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingRules.
     */
    cursor?: BookingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingRules.
     */
    distinct?: BookingRuleScalarFieldEnum | BookingRuleScalarFieldEnum[]
  }

  /**
   * BookingRule findMany
   */
  export type BookingRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRule
     */
    select?: BookingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRule
     */
    omit?: BookingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRuleInclude<ExtArgs> | null
    /**
     * Filter, which BookingRules to fetch.
     */
    where?: BookingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRules to fetch.
     */
    orderBy?: BookingRuleOrderByWithRelationInput | BookingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingRules.
     */
    cursor?: BookingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRules.
     */
    skip?: number
    distinct?: BookingRuleScalarFieldEnum | BookingRuleScalarFieldEnum[]
  }

  /**
   * BookingRule create
   */
  export type BookingRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRule
     */
    select?: BookingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRule
     */
    omit?: BookingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingRule.
     */
    data: XOR<BookingRuleCreateInput, BookingRuleUncheckedCreateInput>
  }

  /**
   * BookingRule createMany
   */
  export type BookingRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingRules.
     */
    data: BookingRuleCreateManyInput | BookingRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingRule createManyAndReturn
   */
  export type BookingRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRule
     */
    select?: BookingRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRule
     */
    omit?: BookingRuleOmit<ExtArgs> | null
    /**
     * The data used to create many BookingRules.
     */
    data: BookingRuleCreateManyInput | BookingRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingRule update
   */
  export type BookingRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRule
     */
    select?: BookingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRule
     */
    omit?: BookingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingRule.
     */
    data: XOR<BookingRuleUpdateInput, BookingRuleUncheckedUpdateInput>
    /**
     * Choose, which BookingRule to update.
     */
    where: BookingRuleWhereUniqueInput
  }

  /**
   * BookingRule updateMany
   */
  export type BookingRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingRules.
     */
    data: XOR<BookingRuleUpdateManyMutationInput, BookingRuleUncheckedUpdateManyInput>
    /**
     * Filter which BookingRules to update
     */
    where?: BookingRuleWhereInput
    /**
     * Limit how many BookingRules to update.
     */
    limit?: number
  }

  /**
   * BookingRule updateManyAndReturn
   */
  export type BookingRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRule
     */
    select?: BookingRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRule
     */
    omit?: BookingRuleOmit<ExtArgs> | null
    /**
     * The data used to update BookingRules.
     */
    data: XOR<BookingRuleUpdateManyMutationInput, BookingRuleUncheckedUpdateManyInput>
    /**
     * Filter which BookingRules to update
     */
    where?: BookingRuleWhereInput
    /**
     * Limit how many BookingRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingRule upsert
   */
  export type BookingRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRule
     */
    select?: BookingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRule
     */
    omit?: BookingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingRule to update in case it exists.
     */
    where: BookingRuleWhereUniqueInput
    /**
     * In case the BookingRule found by the `where` argument doesn't exist, create a new BookingRule with this data.
     */
    create: XOR<BookingRuleCreateInput, BookingRuleUncheckedCreateInput>
    /**
     * In case the BookingRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingRuleUpdateInput, BookingRuleUncheckedUpdateInput>
  }

  /**
   * BookingRule delete
   */
  export type BookingRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRule
     */
    select?: BookingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRule
     */
    omit?: BookingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRuleInclude<ExtArgs> | null
    /**
     * Filter which BookingRule to delete.
     */
    where: BookingRuleWhereUniqueInput
  }

  /**
   * BookingRule deleteMany
   */
  export type BookingRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingRules to delete
     */
    where?: BookingRuleWhereInput
    /**
     * Limit how many BookingRules to delete.
     */
    limit?: number
  }

  /**
   * BookingRule without action
   */
  export type BookingRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRule
     */
    select?: BookingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRule
     */
    omit?: BookingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRuleInclude<ExtArgs> | null
  }


  /**
   * Model BookingException
   */

  export type AggregateBookingException = {
    _count: BookingExceptionCountAggregateOutputType | null
    _avg: BookingExceptionAvgAggregateOutputType | null
    _sum: BookingExceptionSumAggregateOutputType | null
    _min: BookingExceptionMinAggregateOutputType | null
    _max: BookingExceptionMaxAggregateOutputType | null
  }

  export type BookingExceptionAvgAggregateOutputType = {
    slot_duration_minutes: number | null
  }

  export type BookingExceptionSumAggregateOutputType = {
    slot_duration_minutes: number | null
  }

  export type BookingExceptionMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    date: string | null
    type: $Enums.BookingExceptionType | null
    start_time: Date | null
    end_time: Date | null
    slot_duration_minutes: number | null
    reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BookingExceptionMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    date: string | null
    type: $Enums.BookingExceptionType | null
    start_time: Date | null
    end_time: Date | null
    slot_duration_minutes: number | null
    reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BookingExceptionCountAggregateOutputType = {
    id: number
    user_id: number
    date: number
    type: number
    start_time: number
    end_time: number
    slot_duration_minutes: number
    reason: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BookingExceptionAvgAggregateInputType = {
    slot_duration_minutes?: true
  }

  export type BookingExceptionSumAggregateInputType = {
    slot_duration_minutes?: true
  }

  export type BookingExceptionMinAggregateInputType = {
    id?: true
    user_id?: true
    date?: true
    type?: true
    start_time?: true
    end_time?: true
    slot_duration_minutes?: true
    reason?: true
    created_at?: true
    updated_at?: true
  }

  export type BookingExceptionMaxAggregateInputType = {
    id?: true
    user_id?: true
    date?: true
    type?: true
    start_time?: true
    end_time?: true
    slot_duration_minutes?: true
    reason?: true
    created_at?: true
    updated_at?: true
  }

  export type BookingExceptionCountAggregateInputType = {
    id?: true
    user_id?: true
    date?: true
    type?: true
    start_time?: true
    end_time?: true
    slot_duration_minutes?: true
    reason?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BookingExceptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingException to aggregate.
     */
    where?: BookingExceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingExceptions to fetch.
     */
    orderBy?: BookingExceptionOrderByWithRelationInput | BookingExceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingExceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingExceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingExceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingExceptions
    **/
    _count?: true | BookingExceptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingExceptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingExceptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingExceptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingExceptionMaxAggregateInputType
  }

  export type GetBookingExceptionAggregateType<T extends BookingExceptionAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingException]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingException[P]>
      : GetScalarType<T[P], AggregateBookingException[P]>
  }




  export type BookingExceptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingExceptionWhereInput
    orderBy?: BookingExceptionOrderByWithAggregationInput | BookingExceptionOrderByWithAggregationInput[]
    by: BookingExceptionScalarFieldEnum[] | BookingExceptionScalarFieldEnum
    having?: BookingExceptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingExceptionCountAggregateInputType | true
    _avg?: BookingExceptionAvgAggregateInputType
    _sum?: BookingExceptionSumAggregateInputType
    _min?: BookingExceptionMinAggregateInputType
    _max?: BookingExceptionMaxAggregateInputType
  }

  export type BookingExceptionGroupByOutputType = {
    id: string
    user_id: string
    date: string
    type: $Enums.BookingExceptionType
    start_time: Date | null
    end_time: Date | null
    slot_duration_minutes: number | null
    reason: string | null
    created_at: Date
    updated_at: Date
    _count: BookingExceptionCountAggregateOutputType | null
    _avg: BookingExceptionAvgAggregateOutputType | null
    _sum: BookingExceptionSumAggregateOutputType | null
    _min: BookingExceptionMinAggregateOutputType | null
    _max: BookingExceptionMaxAggregateOutputType | null
  }

  type GetBookingExceptionGroupByPayload<T extends BookingExceptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingExceptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingExceptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingExceptionGroupByOutputType[P]>
            : GetScalarType<T[P], BookingExceptionGroupByOutputType[P]>
        }
      >
    >


  export type BookingExceptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    date?: boolean
    type?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingException"]>

  export type BookingExceptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    date?: boolean
    type?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingException"]>

  export type BookingExceptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    date?: boolean
    type?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingException"]>

  export type BookingExceptionSelectScalar = {
    id?: boolean
    user_id?: boolean
    date?: boolean
    type?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BookingExceptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "date" | "type" | "start_time" | "end_time" | "slot_duration_minutes" | "reason" | "created_at" | "updated_at", ExtArgs["result"]["bookingException"]>
  export type BookingExceptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingExceptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingExceptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BookingExceptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingException"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      date: string
      type: $Enums.BookingExceptionType
      start_time: Date | null
      end_time: Date | null
      slot_duration_minutes: number | null
      reason: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["bookingException"]>
    composites: {}
  }

  type BookingExceptionGetPayload<S extends boolean | null | undefined | BookingExceptionDefaultArgs> = $Result.GetResult<Prisma.$BookingExceptionPayload, S>

  type BookingExceptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingExceptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingExceptionCountAggregateInputType | true
    }

  export interface BookingExceptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingException'], meta: { name: 'BookingException' } }
    /**
     * Find zero or one BookingException that matches the filter.
     * @param {BookingExceptionFindUniqueArgs} args - Arguments to find a BookingException
     * @example
     * // Get one BookingException
     * const bookingException = await prisma.bookingException.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingExceptionFindUniqueArgs>(args: SelectSubset<T, BookingExceptionFindUniqueArgs<ExtArgs>>): Prisma__BookingExceptionClient<$Result.GetResult<Prisma.$BookingExceptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingException that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingExceptionFindUniqueOrThrowArgs} args - Arguments to find a BookingException
     * @example
     * // Get one BookingException
     * const bookingException = await prisma.bookingException.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingExceptionFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingExceptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingExceptionClient<$Result.GetResult<Prisma.$BookingExceptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingException that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingExceptionFindFirstArgs} args - Arguments to find a BookingException
     * @example
     * // Get one BookingException
     * const bookingException = await prisma.bookingException.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingExceptionFindFirstArgs>(args?: SelectSubset<T, BookingExceptionFindFirstArgs<ExtArgs>>): Prisma__BookingExceptionClient<$Result.GetResult<Prisma.$BookingExceptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingException that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingExceptionFindFirstOrThrowArgs} args - Arguments to find a BookingException
     * @example
     * // Get one BookingException
     * const bookingException = await prisma.bookingException.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingExceptionFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingExceptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingExceptionClient<$Result.GetResult<Prisma.$BookingExceptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingExceptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingExceptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingExceptions
     * const bookingExceptions = await prisma.bookingException.findMany()
     * 
     * // Get first 10 BookingExceptions
     * const bookingExceptions = await prisma.bookingException.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingExceptionWithIdOnly = await prisma.bookingException.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingExceptionFindManyArgs>(args?: SelectSubset<T, BookingExceptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingExceptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingException.
     * @param {BookingExceptionCreateArgs} args - Arguments to create a BookingException.
     * @example
     * // Create one BookingException
     * const BookingException = await prisma.bookingException.create({
     *   data: {
     *     // ... data to create a BookingException
     *   }
     * })
     * 
     */
    create<T extends BookingExceptionCreateArgs>(args: SelectSubset<T, BookingExceptionCreateArgs<ExtArgs>>): Prisma__BookingExceptionClient<$Result.GetResult<Prisma.$BookingExceptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingExceptions.
     * @param {BookingExceptionCreateManyArgs} args - Arguments to create many BookingExceptions.
     * @example
     * // Create many BookingExceptions
     * const bookingException = await prisma.bookingException.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingExceptionCreateManyArgs>(args?: SelectSubset<T, BookingExceptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingExceptions and returns the data saved in the database.
     * @param {BookingExceptionCreateManyAndReturnArgs} args - Arguments to create many BookingExceptions.
     * @example
     * // Create many BookingExceptions
     * const bookingException = await prisma.bookingException.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingExceptions and only return the `id`
     * const bookingExceptionWithIdOnly = await prisma.bookingException.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingExceptionCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingExceptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingExceptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingException.
     * @param {BookingExceptionDeleteArgs} args - Arguments to delete one BookingException.
     * @example
     * // Delete one BookingException
     * const BookingException = await prisma.bookingException.delete({
     *   where: {
     *     // ... filter to delete one BookingException
     *   }
     * })
     * 
     */
    delete<T extends BookingExceptionDeleteArgs>(args: SelectSubset<T, BookingExceptionDeleteArgs<ExtArgs>>): Prisma__BookingExceptionClient<$Result.GetResult<Prisma.$BookingExceptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingException.
     * @param {BookingExceptionUpdateArgs} args - Arguments to update one BookingException.
     * @example
     * // Update one BookingException
     * const bookingException = await prisma.bookingException.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingExceptionUpdateArgs>(args: SelectSubset<T, BookingExceptionUpdateArgs<ExtArgs>>): Prisma__BookingExceptionClient<$Result.GetResult<Prisma.$BookingExceptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingExceptions.
     * @param {BookingExceptionDeleteManyArgs} args - Arguments to filter BookingExceptions to delete.
     * @example
     * // Delete a few BookingExceptions
     * const { count } = await prisma.bookingException.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingExceptionDeleteManyArgs>(args?: SelectSubset<T, BookingExceptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingExceptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingExceptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingExceptions
     * const bookingException = await prisma.bookingException.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingExceptionUpdateManyArgs>(args: SelectSubset<T, BookingExceptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingExceptions and returns the data updated in the database.
     * @param {BookingExceptionUpdateManyAndReturnArgs} args - Arguments to update many BookingExceptions.
     * @example
     * // Update many BookingExceptions
     * const bookingException = await prisma.bookingException.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingExceptions and only return the `id`
     * const bookingExceptionWithIdOnly = await prisma.bookingException.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingExceptionUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingExceptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingExceptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingException.
     * @param {BookingExceptionUpsertArgs} args - Arguments to update or create a BookingException.
     * @example
     * // Update or create a BookingException
     * const bookingException = await prisma.bookingException.upsert({
     *   create: {
     *     // ... data to create a BookingException
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingException we want to update
     *   }
     * })
     */
    upsert<T extends BookingExceptionUpsertArgs>(args: SelectSubset<T, BookingExceptionUpsertArgs<ExtArgs>>): Prisma__BookingExceptionClient<$Result.GetResult<Prisma.$BookingExceptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingExceptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingExceptionCountArgs} args - Arguments to filter BookingExceptions to count.
     * @example
     * // Count the number of BookingExceptions
     * const count = await prisma.bookingException.count({
     *   where: {
     *     // ... the filter for the BookingExceptions we want to count
     *   }
     * })
    **/
    count<T extends BookingExceptionCountArgs>(
      args?: Subset<T, BookingExceptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingExceptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingException.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingExceptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingExceptionAggregateArgs>(args: Subset<T, BookingExceptionAggregateArgs>): Prisma.PrismaPromise<GetBookingExceptionAggregateType<T>>

    /**
     * Group by BookingException.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingExceptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingExceptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingExceptionGroupByArgs['orderBy'] }
        : { orderBy?: BookingExceptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingExceptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingExceptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingException model
   */
  readonly fields: BookingExceptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingException.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingExceptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingException model
   */
  interface BookingExceptionFieldRefs {
    readonly id: FieldRef<"BookingException", 'String'>
    readonly user_id: FieldRef<"BookingException", 'String'>
    readonly date: FieldRef<"BookingException", 'String'>
    readonly type: FieldRef<"BookingException", 'BookingExceptionType'>
    readonly start_time: FieldRef<"BookingException", 'DateTime'>
    readonly end_time: FieldRef<"BookingException", 'DateTime'>
    readonly slot_duration_minutes: FieldRef<"BookingException", 'Int'>
    readonly reason: FieldRef<"BookingException", 'String'>
    readonly created_at: FieldRef<"BookingException", 'DateTime'>
    readonly updated_at: FieldRef<"BookingException", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingException findUnique
   */
  export type BookingExceptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingException
     */
    select?: BookingExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingException
     */
    omit?: BookingExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExceptionInclude<ExtArgs> | null
    /**
     * Filter, which BookingException to fetch.
     */
    where: BookingExceptionWhereUniqueInput
  }

  /**
   * BookingException findUniqueOrThrow
   */
  export type BookingExceptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingException
     */
    select?: BookingExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingException
     */
    omit?: BookingExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExceptionInclude<ExtArgs> | null
    /**
     * Filter, which BookingException to fetch.
     */
    where: BookingExceptionWhereUniqueInput
  }

  /**
   * BookingException findFirst
   */
  export type BookingExceptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingException
     */
    select?: BookingExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingException
     */
    omit?: BookingExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExceptionInclude<ExtArgs> | null
    /**
     * Filter, which BookingException to fetch.
     */
    where?: BookingExceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingExceptions to fetch.
     */
    orderBy?: BookingExceptionOrderByWithRelationInput | BookingExceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingExceptions.
     */
    cursor?: BookingExceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingExceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingExceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingExceptions.
     */
    distinct?: BookingExceptionScalarFieldEnum | BookingExceptionScalarFieldEnum[]
  }

  /**
   * BookingException findFirstOrThrow
   */
  export type BookingExceptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingException
     */
    select?: BookingExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingException
     */
    omit?: BookingExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExceptionInclude<ExtArgs> | null
    /**
     * Filter, which BookingException to fetch.
     */
    where?: BookingExceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingExceptions to fetch.
     */
    orderBy?: BookingExceptionOrderByWithRelationInput | BookingExceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingExceptions.
     */
    cursor?: BookingExceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingExceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingExceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingExceptions.
     */
    distinct?: BookingExceptionScalarFieldEnum | BookingExceptionScalarFieldEnum[]
  }

  /**
   * BookingException findMany
   */
  export type BookingExceptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingException
     */
    select?: BookingExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingException
     */
    omit?: BookingExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExceptionInclude<ExtArgs> | null
    /**
     * Filter, which BookingExceptions to fetch.
     */
    where?: BookingExceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingExceptions to fetch.
     */
    orderBy?: BookingExceptionOrderByWithRelationInput | BookingExceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingExceptions.
     */
    cursor?: BookingExceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingExceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingExceptions.
     */
    skip?: number
    distinct?: BookingExceptionScalarFieldEnum | BookingExceptionScalarFieldEnum[]
  }

  /**
   * BookingException create
   */
  export type BookingExceptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingException
     */
    select?: BookingExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingException
     */
    omit?: BookingExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExceptionInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingException.
     */
    data: XOR<BookingExceptionCreateInput, BookingExceptionUncheckedCreateInput>
  }

  /**
   * BookingException createMany
   */
  export type BookingExceptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingExceptions.
     */
    data: BookingExceptionCreateManyInput | BookingExceptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingException createManyAndReturn
   */
  export type BookingExceptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingException
     */
    select?: BookingExceptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingException
     */
    omit?: BookingExceptionOmit<ExtArgs> | null
    /**
     * The data used to create many BookingExceptions.
     */
    data: BookingExceptionCreateManyInput | BookingExceptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExceptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingException update
   */
  export type BookingExceptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingException
     */
    select?: BookingExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingException
     */
    omit?: BookingExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExceptionInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingException.
     */
    data: XOR<BookingExceptionUpdateInput, BookingExceptionUncheckedUpdateInput>
    /**
     * Choose, which BookingException to update.
     */
    where: BookingExceptionWhereUniqueInput
  }

  /**
   * BookingException updateMany
   */
  export type BookingExceptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingExceptions.
     */
    data: XOR<BookingExceptionUpdateManyMutationInput, BookingExceptionUncheckedUpdateManyInput>
    /**
     * Filter which BookingExceptions to update
     */
    where?: BookingExceptionWhereInput
    /**
     * Limit how many BookingExceptions to update.
     */
    limit?: number
  }

  /**
   * BookingException updateManyAndReturn
   */
  export type BookingExceptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingException
     */
    select?: BookingExceptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingException
     */
    omit?: BookingExceptionOmit<ExtArgs> | null
    /**
     * The data used to update BookingExceptions.
     */
    data: XOR<BookingExceptionUpdateManyMutationInput, BookingExceptionUncheckedUpdateManyInput>
    /**
     * Filter which BookingExceptions to update
     */
    where?: BookingExceptionWhereInput
    /**
     * Limit how many BookingExceptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExceptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingException upsert
   */
  export type BookingExceptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingException
     */
    select?: BookingExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingException
     */
    omit?: BookingExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExceptionInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingException to update in case it exists.
     */
    where: BookingExceptionWhereUniqueInput
    /**
     * In case the BookingException found by the `where` argument doesn't exist, create a new BookingException with this data.
     */
    create: XOR<BookingExceptionCreateInput, BookingExceptionUncheckedCreateInput>
    /**
     * In case the BookingException was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingExceptionUpdateInput, BookingExceptionUncheckedUpdateInput>
  }

  /**
   * BookingException delete
   */
  export type BookingExceptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingException
     */
    select?: BookingExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingException
     */
    omit?: BookingExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExceptionInclude<ExtArgs> | null
    /**
     * Filter which BookingException to delete.
     */
    where: BookingExceptionWhereUniqueInput
  }

  /**
   * BookingException deleteMany
   */
  export type BookingExceptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingExceptions to delete
     */
    where?: BookingExceptionWhereInput
    /**
     * Limit how many BookingExceptions to delete.
     */
    limit?: number
  }

  /**
   * BookingException without action
   */
  export type BookingExceptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingException
     */
    select?: BookingExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingException
     */
    omit?: BookingExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingExceptionInclude<ExtArgs> | null
  }


  /**
   * Model UnitAvailabilityRule
   */

  export type AggregateUnitAvailabilityRule = {
    _count: UnitAvailabilityRuleCountAggregateOutputType | null
    _avg: UnitAvailabilityRuleAvgAggregateOutputType | null
    _sum: UnitAvailabilityRuleSumAggregateOutputType | null
    _min: UnitAvailabilityRuleMinAggregateOutputType | null
    _max: UnitAvailabilityRuleMaxAggregateOutputType | null
  }

  export type UnitAvailabilityRuleAvgAggregateOutputType = {
    weekday: number | null
    slot_duration_minutes: number | null
  }

  export type UnitAvailabilityRuleSumAggregateOutputType = {
    weekday: number | null
    slot_duration_minutes: number | null
  }

  export type UnitAvailabilityRuleMinAggregateOutputType = {
    id: string | null
    unit_id: string | null
    type: $Enums.UnitAvailabilityRuleType | null
    weekday: number | null
    date: string | null
    start_time: string | null
    end_time: string | null
    slot_duration_minutes: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UnitAvailabilityRuleMaxAggregateOutputType = {
    id: string | null
    unit_id: string | null
    type: $Enums.UnitAvailabilityRuleType | null
    weekday: number | null
    date: string | null
    start_time: string | null
    end_time: string | null
    slot_duration_minutes: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UnitAvailabilityRuleCountAggregateOutputType = {
    id: number
    unit_id: number
    type: number
    weekday: number
    date: number
    start_time: number
    end_time: number
    slot_duration_minutes: number
    is_active: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UnitAvailabilityRuleAvgAggregateInputType = {
    weekday?: true
    slot_duration_minutes?: true
  }

  export type UnitAvailabilityRuleSumAggregateInputType = {
    weekday?: true
    slot_duration_minutes?: true
  }

  export type UnitAvailabilityRuleMinAggregateInputType = {
    id?: true
    unit_id?: true
    type?: true
    weekday?: true
    date?: true
    start_time?: true
    end_time?: true
    slot_duration_minutes?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type UnitAvailabilityRuleMaxAggregateInputType = {
    id?: true
    unit_id?: true
    type?: true
    weekday?: true
    date?: true
    start_time?: true
    end_time?: true
    slot_duration_minutes?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type UnitAvailabilityRuleCountAggregateInputType = {
    id?: true
    unit_id?: true
    type?: true
    weekday?: true
    date?: true
    start_time?: true
    end_time?: true
    slot_duration_minutes?: true
    is_active?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UnitAvailabilityRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitAvailabilityRule to aggregate.
     */
    where?: UnitAvailabilityRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAvailabilityRules to fetch.
     */
    orderBy?: UnitAvailabilityRuleOrderByWithRelationInput | UnitAvailabilityRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitAvailabilityRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAvailabilityRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAvailabilityRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitAvailabilityRules
    **/
    _count?: true | UnitAvailabilityRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvailabilityRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitAvailabilityRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitAvailabilityRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitAvailabilityRuleMaxAggregateInputType
  }

  export type GetUnitAvailabilityRuleAggregateType<T extends UnitAvailabilityRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitAvailabilityRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitAvailabilityRule[P]>
      : GetScalarType<T[P], AggregateUnitAvailabilityRule[P]>
  }




  export type UnitAvailabilityRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitAvailabilityRuleWhereInput
    orderBy?: UnitAvailabilityRuleOrderByWithAggregationInput | UnitAvailabilityRuleOrderByWithAggregationInput[]
    by: UnitAvailabilityRuleScalarFieldEnum[] | UnitAvailabilityRuleScalarFieldEnum
    having?: UnitAvailabilityRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitAvailabilityRuleCountAggregateInputType | true
    _avg?: UnitAvailabilityRuleAvgAggregateInputType
    _sum?: UnitAvailabilityRuleSumAggregateInputType
    _min?: UnitAvailabilityRuleMinAggregateInputType
    _max?: UnitAvailabilityRuleMaxAggregateInputType
  }

  export type UnitAvailabilityRuleGroupByOutputType = {
    id: string
    unit_id: string
    type: $Enums.UnitAvailabilityRuleType
    weekday: number | null
    date: string | null
    start_time: string
    end_time: string
    slot_duration_minutes: number
    is_active: boolean
    metadata: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: UnitAvailabilityRuleCountAggregateOutputType | null
    _avg: UnitAvailabilityRuleAvgAggregateOutputType | null
    _sum: UnitAvailabilityRuleSumAggregateOutputType | null
    _min: UnitAvailabilityRuleMinAggregateOutputType | null
    _max: UnitAvailabilityRuleMaxAggregateOutputType | null
  }

  type GetUnitAvailabilityRuleGroupByPayload<T extends UnitAvailabilityRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitAvailabilityRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitAvailabilityRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitAvailabilityRuleGroupByOutputType[P]>
            : GetScalarType<T[P], UnitAvailabilityRuleGroupByOutputType[P]>
        }
      >
    >


  export type UnitAvailabilityRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    type?: boolean
    weekday?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitAvailabilityRule"]>

  export type UnitAvailabilityRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    type?: boolean
    weekday?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitAvailabilityRule"]>

  export type UnitAvailabilityRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    type?: boolean
    weekday?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitAvailabilityRule"]>

  export type UnitAvailabilityRuleSelectScalar = {
    id?: boolean
    unit_id?: boolean
    type?: boolean
    weekday?: boolean
    date?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UnitAvailabilityRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unit_id" | "type" | "weekday" | "date" | "start_time" | "end_time" | "slot_duration_minutes" | "is_active" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["unitAvailabilityRule"]>
  export type UnitAvailabilityRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type UnitAvailabilityRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type UnitAvailabilityRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $UnitAvailabilityRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitAvailabilityRule"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unit_id: string
      type: $Enums.UnitAvailabilityRuleType
      weekday: number | null
      date: string | null
      start_time: string
      end_time: string
      slot_duration_minutes: number
      is_active: boolean
      metadata: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["unitAvailabilityRule"]>
    composites: {}
  }

  type UnitAvailabilityRuleGetPayload<S extends boolean | null | undefined | UnitAvailabilityRuleDefaultArgs> = $Result.GetResult<Prisma.$UnitAvailabilityRulePayload, S>

  type UnitAvailabilityRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitAvailabilityRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitAvailabilityRuleCountAggregateInputType | true
    }

  export interface UnitAvailabilityRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitAvailabilityRule'], meta: { name: 'UnitAvailabilityRule' } }
    /**
     * Find zero or one UnitAvailabilityRule that matches the filter.
     * @param {UnitAvailabilityRuleFindUniqueArgs} args - Arguments to find a UnitAvailabilityRule
     * @example
     * // Get one UnitAvailabilityRule
     * const unitAvailabilityRule = await prisma.unitAvailabilityRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitAvailabilityRuleFindUniqueArgs>(args: SelectSubset<T, UnitAvailabilityRuleFindUniqueArgs<ExtArgs>>): Prisma__UnitAvailabilityRuleClient<$Result.GetResult<Prisma.$UnitAvailabilityRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitAvailabilityRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitAvailabilityRuleFindUniqueOrThrowArgs} args - Arguments to find a UnitAvailabilityRule
     * @example
     * // Get one UnitAvailabilityRule
     * const unitAvailabilityRule = await prisma.unitAvailabilityRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitAvailabilityRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitAvailabilityRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitAvailabilityRuleClient<$Result.GetResult<Prisma.$UnitAvailabilityRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitAvailabilityRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAvailabilityRuleFindFirstArgs} args - Arguments to find a UnitAvailabilityRule
     * @example
     * // Get one UnitAvailabilityRule
     * const unitAvailabilityRule = await prisma.unitAvailabilityRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitAvailabilityRuleFindFirstArgs>(args?: SelectSubset<T, UnitAvailabilityRuleFindFirstArgs<ExtArgs>>): Prisma__UnitAvailabilityRuleClient<$Result.GetResult<Prisma.$UnitAvailabilityRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitAvailabilityRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAvailabilityRuleFindFirstOrThrowArgs} args - Arguments to find a UnitAvailabilityRule
     * @example
     * // Get one UnitAvailabilityRule
     * const unitAvailabilityRule = await prisma.unitAvailabilityRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitAvailabilityRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitAvailabilityRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitAvailabilityRuleClient<$Result.GetResult<Prisma.$UnitAvailabilityRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitAvailabilityRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAvailabilityRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitAvailabilityRules
     * const unitAvailabilityRules = await prisma.unitAvailabilityRule.findMany()
     * 
     * // Get first 10 UnitAvailabilityRules
     * const unitAvailabilityRules = await prisma.unitAvailabilityRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitAvailabilityRuleWithIdOnly = await prisma.unitAvailabilityRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitAvailabilityRuleFindManyArgs>(args?: SelectSubset<T, UnitAvailabilityRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAvailabilityRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitAvailabilityRule.
     * @param {UnitAvailabilityRuleCreateArgs} args - Arguments to create a UnitAvailabilityRule.
     * @example
     * // Create one UnitAvailabilityRule
     * const UnitAvailabilityRule = await prisma.unitAvailabilityRule.create({
     *   data: {
     *     // ... data to create a UnitAvailabilityRule
     *   }
     * })
     * 
     */
    create<T extends UnitAvailabilityRuleCreateArgs>(args: SelectSubset<T, UnitAvailabilityRuleCreateArgs<ExtArgs>>): Prisma__UnitAvailabilityRuleClient<$Result.GetResult<Prisma.$UnitAvailabilityRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitAvailabilityRules.
     * @param {UnitAvailabilityRuleCreateManyArgs} args - Arguments to create many UnitAvailabilityRules.
     * @example
     * // Create many UnitAvailabilityRules
     * const unitAvailabilityRule = await prisma.unitAvailabilityRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitAvailabilityRuleCreateManyArgs>(args?: SelectSubset<T, UnitAvailabilityRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitAvailabilityRules and returns the data saved in the database.
     * @param {UnitAvailabilityRuleCreateManyAndReturnArgs} args - Arguments to create many UnitAvailabilityRules.
     * @example
     * // Create many UnitAvailabilityRules
     * const unitAvailabilityRule = await prisma.unitAvailabilityRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitAvailabilityRules and only return the `id`
     * const unitAvailabilityRuleWithIdOnly = await prisma.unitAvailabilityRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitAvailabilityRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitAvailabilityRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAvailabilityRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitAvailabilityRule.
     * @param {UnitAvailabilityRuleDeleteArgs} args - Arguments to delete one UnitAvailabilityRule.
     * @example
     * // Delete one UnitAvailabilityRule
     * const UnitAvailabilityRule = await prisma.unitAvailabilityRule.delete({
     *   where: {
     *     // ... filter to delete one UnitAvailabilityRule
     *   }
     * })
     * 
     */
    delete<T extends UnitAvailabilityRuleDeleteArgs>(args: SelectSubset<T, UnitAvailabilityRuleDeleteArgs<ExtArgs>>): Prisma__UnitAvailabilityRuleClient<$Result.GetResult<Prisma.$UnitAvailabilityRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitAvailabilityRule.
     * @param {UnitAvailabilityRuleUpdateArgs} args - Arguments to update one UnitAvailabilityRule.
     * @example
     * // Update one UnitAvailabilityRule
     * const unitAvailabilityRule = await prisma.unitAvailabilityRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitAvailabilityRuleUpdateArgs>(args: SelectSubset<T, UnitAvailabilityRuleUpdateArgs<ExtArgs>>): Prisma__UnitAvailabilityRuleClient<$Result.GetResult<Prisma.$UnitAvailabilityRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitAvailabilityRules.
     * @param {UnitAvailabilityRuleDeleteManyArgs} args - Arguments to filter UnitAvailabilityRules to delete.
     * @example
     * // Delete a few UnitAvailabilityRules
     * const { count } = await prisma.unitAvailabilityRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitAvailabilityRuleDeleteManyArgs>(args?: SelectSubset<T, UnitAvailabilityRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitAvailabilityRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAvailabilityRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitAvailabilityRules
     * const unitAvailabilityRule = await prisma.unitAvailabilityRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitAvailabilityRuleUpdateManyArgs>(args: SelectSubset<T, UnitAvailabilityRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitAvailabilityRules and returns the data updated in the database.
     * @param {UnitAvailabilityRuleUpdateManyAndReturnArgs} args - Arguments to update many UnitAvailabilityRules.
     * @example
     * // Update many UnitAvailabilityRules
     * const unitAvailabilityRule = await prisma.unitAvailabilityRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitAvailabilityRules and only return the `id`
     * const unitAvailabilityRuleWithIdOnly = await prisma.unitAvailabilityRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitAvailabilityRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitAvailabilityRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAvailabilityRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitAvailabilityRule.
     * @param {UnitAvailabilityRuleUpsertArgs} args - Arguments to update or create a UnitAvailabilityRule.
     * @example
     * // Update or create a UnitAvailabilityRule
     * const unitAvailabilityRule = await prisma.unitAvailabilityRule.upsert({
     *   create: {
     *     // ... data to create a UnitAvailabilityRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitAvailabilityRule we want to update
     *   }
     * })
     */
    upsert<T extends UnitAvailabilityRuleUpsertArgs>(args: SelectSubset<T, UnitAvailabilityRuleUpsertArgs<ExtArgs>>): Prisma__UnitAvailabilityRuleClient<$Result.GetResult<Prisma.$UnitAvailabilityRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitAvailabilityRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAvailabilityRuleCountArgs} args - Arguments to filter UnitAvailabilityRules to count.
     * @example
     * // Count the number of UnitAvailabilityRules
     * const count = await prisma.unitAvailabilityRule.count({
     *   where: {
     *     // ... the filter for the UnitAvailabilityRules we want to count
     *   }
     * })
    **/
    count<T extends UnitAvailabilityRuleCountArgs>(
      args?: Subset<T, UnitAvailabilityRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitAvailabilityRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitAvailabilityRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAvailabilityRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAvailabilityRuleAggregateArgs>(args: Subset<T, UnitAvailabilityRuleAggregateArgs>): Prisma.PrismaPromise<GetUnitAvailabilityRuleAggregateType<T>>

    /**
     * Group by UnitAvailabilityRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAvailabilityRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitAvailabilityRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitAvailabilityRuleGroupByArgs['orderBy'] }
        : { orderBy?: UnitAvailabilityRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitAvailabilityRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitAvailabilityRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitAvailabilityRule model
   */
  readonly fields: UnitAvailabilityRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitAvailabilityRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitAvailabilityRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitAvailabilityRule model
   */
  interface UnitAvailabilityRuleFieldRefs {
    readonly id: FieldRef<"UnitAvailabilityRule", 'String'>
    readonly unit_id: FieldRef<"UnitAvailabilityRule", 'String'>
    readonly type: FieldRef<"UnitAvailabilityRule", 'UnitAvailabilityRuleType'>
    readonly weekday: FieldRef<"UnitAvailabilityRule", 'Int'>
    readonly date: FieldRef<"UnitAvailabilityRule", 'String'>
    readonly start_time: FieldRef<"UnitAvailabilityRule", 'String'>
    readonly end_time: FieldRef<"UnitAvailabilityRule", 'String'>
    readonly slot_duration_minutes: FieldRef<"UnitAvailabilityRule", 'Int'>
    readonly is_active: FieldRef<"UnitAvailabilityRule", 'Boolean'>
    readonly metadata: FieldRef<"UnitAvailabilityRule", 'Json'>
    readonly created_at: FieldRef<"UnitAvailabilityRule", 'DateTime'>
    readonly updated_at: FieldRef<"UnitAvailabilityRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitAvailabilityRule findUnique
   */
  export type UnitAvailabilityRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityRule
     */
    select?: UnitAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityRule
     */
    omit?: UnitAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityRuleInclude<ExtArgs> | null
    /**
     * Filter, which UnitAvailabilityRule to fetch.
     */
    where: UnitAvailabilityRuleWhereUniqueInput
  }

  /**
   * UnitAvailabilityRule findUniqueOrThrow
   */
  export type UnitAvailabilityRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityRule
     */
    select?: UnitAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityRule
     */
    omit?: UnitAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityRuleInclude<ExtArgs> | null
    /**
     * Filter, which UnitAvailabilityRule to fetch.
     */
    where: UnitAvailabilityRuleWhereUniqueInput
  }

  /**
   * UnitAvailabilityRule findFirst
   */
  export type UnitAvailabilityRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityRule
     */
    select?: UnitAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityRule
     */
    omit?: UnitAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityRuleInclude<ExtArgs> | null
    /**
     * Filter, which UnitAvailabilityRule to fetch.
     */
    where?: UnitAvailabilityRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAvailabilityRules to fetch.
     */
    orderBy?: UnitAvailabilityRuleOrderByWithRelationInput | UnitAvailabilityRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitAvailabilityRules.
     */
    cursor?: UnitAvailabilityRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAvailabilityRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAvailabilityRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitAvailabilityRules.
     */
    distinct?: UnitAvailabilityRuleScalarFieldEnum | UnitAvailabilityRuleScalarFieldEnum[]
  }

  /**
   * UnitAvailabilityRule findFirstOrThrow
   */
  export type UnitAvailabilityRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityRule
     */
    select?: UnitAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityRule
     */
    omit?: UnitAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityRuleInclude<ExtArgs> | null
    /**
     * Filter, which UnitAvailabilityRule to fetch.
     */
    where?: UnitAvailabilityRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAvailabilityRules to fetch.
     */
    orderBy?: UnitAvailabilityRuleOrderByWithRelationInput | UnitAvailabilityRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitAvailabilityRules.
     */
    cursor?: UnitAvailabilityRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAvailabilityRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAvailabilityRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitAvailabilityRules.
     */
    distinct?: UnitAvailabilityRuleScalarFieldEnum | UnitAvailabilityRuleScalarFieldEnum[]
  }

  /**
   * UnitAvailabilityRule findMany
   */
  export type UnitAvailabilityRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityRule
     */
    select?: UnitAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityRule
     */
    omit?: UnitAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityRuleInclude<ExtArgs> | null
    /**
     * Filter, which UnitAvailabilityRules to fetch.
     */
    where?: UnitAvailabilityRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAvailabilityRules to fetch.
     */
    orderBy?: UnitAvailabilityRuleOrderByWithRelationInput | UnitAvailabilityRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitAvailabilityRules.
     */
    cursor?: UnitAvailabilityRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAvailabilityRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAvailabilityRules.
     */
    skip?: number
    distinct?: UnitAvailabilityRuleScalarFieldEnum | UnitAvailabilityRuleScalarFieldEnum[]
  }

  /**
   * UnitAvailabilityRule create
   */
  export type UnitAvailabilityRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityRule
     */
    select?: UnitAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityRule
     */
    omit?: UnitAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitAvailabilityRule.
     */
    data: XOR<UnitAvailabilityRuleCreateInput, UnitAvailabilityRuleUncheckedCreateInput>
  }

  /**
   * UnitAvailabilityRule createMany
   */
  export type UnitAvailabilityRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitAvailabilityRules.
     */
    data: UnitAvailabilityRuleCreateManyInput | UnitAvailabilityRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitAvailabilityRule createManyAndReturn
   */
  export type UnitAvailabilityRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityRule
     */
    select?: UnitAvailabilityRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityRule
     */
    omit?: UnitAvailabilityRuleOmit<ExtArgs> | null
    /**
     * The data used to create many UnitAvailabilityRules.
     */
    data: UnitAvailabilityRuleCreateManyInput | UnitAvailabilityRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitAvailabilityRule update
   */
  export type UnitAvailabilityRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityRule
     */
    select?: UnitAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityRule
     */
    omit?: UnitAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitAvailabilityRule.
     */
    data: XOR<UnitAvailabilityRuleUpdateInput, UnitAvailabilityRuleUncheckedUpdateInput>
    /**
     * Choose, which UnitAvailabilityRule to update.
     */
    where: UnitAvailabilityRuleWhereUniqueInput
  }

  /**
   * UnitAvailabilityRule updateMany
   */
  export type UnitAvailabilityRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitAvailabilityRules.
     */
    data: XOR<UnitAvailabilityRuleUpdateManyMutationInput, UnitAvailabilityRuleUncheckedUpdateManyInput>
    /**
     * Filter which UnitAvailabilityRules to update
     */
    where?: UnitAvailabilityRuleWhereInput
    /**
     * Limit how many UnitAvailabilityRules to update.
     */
    limit?: number
  }

  /**
   * UnitAvailabilityRule updateManyAndReturn
   */
  export type UnitAvailabilityRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityRule
     */
    select?: UnitAvailabilityRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityRule
     */
    omit?: UnitAvailabilityRuleOmit<ExtArgs> | null
    /**
     * The data used to update UnitAvailabilityRules.
     */
    data: XOR<UnitAvailabilityRuleUpdateManyMutationInput, UnitAvailabilityRuleUncheckedUpdateManyInput>
    /**
     * Filter which UnitAvailabilityRules to update
     */
    where?: UnitAvailabilityRuleWhereInput
    /**
     * Limit how many UnitAvailabilityRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitAvailabilityRule upsert
   */
  export type UnitAvailabilityRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityRule
     */
    select?: UnitAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityRule
     */
    omit?: UnitAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitAvailabilityRule to update in case it exists.
     */
    where: UnitAvailabilityRuleWhereUniqueInput
    /**
     * In case the UnitAvailabilityRule found by the `where` argument doesn't exist, create a new UnitAvailabilityRule with this data.
     */
    create: XOR<UnitAvailabilityRuleCreateInput, UnitAvailabilityRuleUncheckedCreateInput>
    /**
     * In case the UnitAvailabilityRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitAvailabilityRuleUpdateInput, UnitAvailabilityRuleUncheckedUpdateInput>
  }

  /**
   * UnitAvailabilityRule delete
   */
  export type UnitAvailabilityRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityRule
     */
    select?: UnitAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityRule
     */
    omit?: UnitAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityRuleInclude<ExtArgs> | null
    /**
     * Filter which UnitAvailabilityRule to delete.
     */
    where: UnitAvailabilityRuleWhereUniqueInput
  }

  /**
   * UnitAvailabilityRule deleteMany
   */
  export type UnitAvailabilityRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitAvailabilityRules to delete
     */
    where?: UnitAvailabilityRuleWhereInput
    /**
     * Limit how many UnitAvailabilityRules to delete.
     */
    limit?: number
  }

  /**
   * UnitAvailabilityRule without action
   */
  export type UnitAvailabilityRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityRule
     */
    select?: UnitAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityRule
     */
    omit?: UnitAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityRuleInclude<ExtArgs> | null
  }


  /**
   * Model UnitAvailabilityException
   */

  export type AggregateUnitAvailabilityException = {
    _count: UnitAvailabilityExceptionCountAggregateOutputType | null
    _avg: UnitAvailabilityExceptionAvgAggregateOutputType | null
    _sum: UnitAvailabilityExceptionSumAggregateOutputType | null
    _min: UnitAvailabilityExceptionMinAggregateOutputType | null
    _max: UnitAvailabilityExceptionMaxAggregateOutputType | null
  }

  export type UnitAvailabilityExceptionAvgAggregateOutputType = {
    slot_duration_minutes: number | null
  }

  export type UnitAvailabilityExceptionSumAggregateOutputType = {
    slot_duration_minutes: number | null
  }

  export type UnitAvailabilityExceptionMinAggregateOutputType = {
    id: string | null
    unit_id: string | null
    date: string | null
    type: $Enums.UnitAvailabilityExceptionType | null
    start_time: string | null
    end_time: string | null
    slot_duration_minutes: number | null
    reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UnitAvailabilityExceptionMaxAggregateOutputType = {
    id: string | null
    unit_id: string | null
    date: string | null
    type: $Enums.UnitAvailabilityExceptionType | null
    start_time: string | null
    end_time: string | null
    slot_duration_minutes: number | null
    reason: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UnitAvailabilityExceptionCountAggregateOutputType = {
    id: number
    unit_id: number
    date: number
    type: number
    start_time: number
    end_time: number
    slot_duration_minutes: number
    reason: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UnitAvailabilityExceptionAvgAggregateInputType = {
    slot_duration_minutes?: true
  }

  export type UnitAvailabilityExceptionSumAggregateInputType = {
    slot_duration_minutes?: true
  }

  export type UnitAvailabilityExceptionMinAggregateInputType = {
    id?: true
    unit_id?: true
    date?: true
    type?: true
    start_time?: true
    end_time?: true
    slot_duration_minutes?: true
    reason?: true
    created_at?: true
    updated_at?: true
  }

  export type UnitAvailabilityExceptionMaxAggregateInputType = {
    id?: true
    unit_id?: true
    date?: true
    type?: true
    start_time?: true
    end_time?: true
    slot_duration_minutes?: true
    reason?: true
    created_at?: true
    updated_at?: true
  }

  export type UnitAvailabilityExceptionCountAggregateInputType = {
    id?: true
    unit_id?: true
    date?: true
    type?: true
    start_time?: true
    end_time?: true
    slot_duration_minutes?: true
    reason?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UnitAvailabilityExceptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitAvailabilityException to aggregate.
     */
    where?: UnitAvailabilityExceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAvailabilityExceptions to fetch.
     */
    orderBy?: UnitAvailabilityExceptionOrderByWithRelationInput | UnitAvailabilityExceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitAvailabilityExceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAvailabilityExceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAvailabilityExceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitAvailabilityExceptions
    **/
    _count?: true | UnitAvailabilityExceptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvailabilityExceptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitAvailabilityExceptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitAvailabilityExceptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitAvailabilityExceptionMaxAggregateInputType
  }

  export type GetUnitAvailabilityExceptionAggregateType<T extends UnitAvailabilityExceptionAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitAvailabilityException]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitAvailabilityException[P]>
      : GetScalarType<T[P], AggregateUnitAvailabilityException[P]>
  }




  export type UnitAvailabilityExceptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitAvailabilityExceptionWhereInput
    orderBy?: UnitAvailabilityExceptionOrderByWithAggregationInput | UnitAvailabilityExceptionOrderByWithAggregationInput[]
    by: UnitAvailabilityExceptionScalarFieldEnum[] | UnitAvailabilityExceptionScalarFieldEnum
    having?: UnitAvailabilityExceptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitAvailabilityExceptionCountAggregateInputType | true
    _avg?: UnitAvailabilityExceptionAvgAggregateInputType
    _sum?: UnitAvailabilityExceptionSumAggregateInputType
    _min?: UnitAvailabilityExceptionMinAggregateInputType
    _max?: UnitAvailabilityExceptionMaxAggregateInputType
  }

  export type UnitAvailabilityExceptionGroupByOutputType = {
    id: string
    unit_id: string
    date: string
    type: $Enums.UnitAvailabilityExceptionType
    start_time: string | null
    end_time: string | null
    slot_duration_minutes: number | null
    reason: string | null
    created_at: Date
    updated_at: Date
    _count: UnitAvailabilityExceptionCountAggregateOutputType | null
    _avg: UnitAvailabilityExceptionAvgAggregateOutputType | null
    _sum: UnitAvailabilityExceptionSumAggregateOutputType | null
    _min: UnitAvailabilityExceptionMinAggregateOutputType | null
    _max: UnitAvailabilityExceptionMaxAggregateOutputType | null
  }

  type GetUnitAvailabilityExceptionGroupByPayload<T extends UnitAvailabilityExceptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitAvailabilityExceptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitAvailabilityExceptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitAvailabilityExceptionGroupByOutputType[P]>
            : GetScalarType<T[P], UnitAvailabilityExceptionGroupByOutputType[P]>
        }
      >
    >


  export type UnitAvailabilityExceptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    date?: boolean
    type?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitAvailabilityException"]>

  export type UnitAvailabilityExceptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    date?: boolean
    type?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitAvailabilityException"]>

  export type UnitAvailabilityExceptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    date?: boolean
    type?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitAvailabilityException"]>

  export type UnitAvailabilityExceptionSelectScalar = {
    id?: boolean
    unit_id?: boolean
    date?: boolean
    type?: boolean
    start_time?: boolean
    end_time?: boolean
    slot_duration_minutes?: boolean
    reason?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UnitAvailabilityExceptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unit_id" | "date" | "type" | "start_time" | "end_time" | "slot_duration_minutes" | "reason" | "created_at" | "updated_at", ExtArgs["result"]["unitAvailabilityException"]>
  export type UnitAvailabilityExceptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type UnitAvailabilityExceptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type UnitAvailabilityExceptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $UnitAvailabilityExceptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitAvailabilityException"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unit_id: string
      date: string
      type: $Enums.UnitAvailabilityExceptionType
      start_time: string | null
      end_time: string | null
      slot_duration_minutes: number | null
      reason: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["unitAvailabilityException"]>
    composites: {}
  }

  type UnitAvailabilityExceptionGetPayload<S extends boolean | null | undefined | UnitAvailabilityExceptionDefaultArgs> = $Result.GetResult<Prisma.$UnitAvailabilityExceptionPayload, S>

  type UnitAvailabilityExceptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitAvailabilityExceptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitAvailabilityExceptionCountAggregateInputType | true
    }

  export interface UnitAvailabilityExceptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitAvailabilityException'], meta: { name: 'UnitAvailabilityException' } }
    /**
     * Find zero or one UnitAvailabilityException that matches the filter.
     * @param {UnitAvailabilityExceptionFindUniqueArgs} args - Arguments to find a UnitAvailabilityException
     * @example
     * // Get one UnitAvailabilityException
     * const unitAvailabilityException = await prisma.unitAvailabilityException.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitAvailabilityExceptionFindUniqueArgs>(args: SelectSubset<T, UnitAvailabilityExceptionFindUniqueArgs<ExtArgs>>): Prisma__UnitAvailabilityExceptionClient<$Result.GetResult<Prisma.$UnitAvailabilityExceptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitAvailabilityException that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitAvailabilityExceptionFindUniqueOrThrowArgs} args - Arguments to find a UnitAvailabilityException
     * @example
     * // Get one UnitAvailabilityException
     * const unitAvailabilityException = await prisma.unitAvailabilityException.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitAvailabilityExceptionFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitAvailabilityExceptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitAvailabilityExceptionClient<$Result.GetResult<Prisma.$UnitAvailabilityExceptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitAvailabilityException that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAvailabilityExceptionFindFirstArgs} args - Arguments to find a UnitAvailabilityException
     * @example
     * // Get one UnitAvailabilityException
     * const unitAvailabilityException = await prisma.unitAvailabilityException.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitAvailabilityExceptionFindFirstArgs>(args?: SelectSubset<T, UnitAvailabilityExceptionFindFirstArgs<ExtArgs>>): Prisma__UnitAvailabilityExceptionClient<$Result.GetResult<Prisma.$UnitAvailabilityExceptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitAvailabilityException that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAvailabilityExceptionFindFirstOrThrowArgs} args - Arguments to find a UnitAvailabilityException
     * @example
     * // Get one UnitAvailabilityException
     * const unitAvailabilityException = await prisma.unitAvailabilityException.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitAvailabilityExceptionFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitAvailabilityExceptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitAvailabilityExceptionClient<$Result.GetResult<Prisma.$UnitAvailabilityExceptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitAvailabilityExceptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAvailabilityExceptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitAvailabilityExceptions
     * const unitAvailabilityExceptions = await prisma.unitAvailabilityException.findMany()
     * 
     * // Get first 10 UnitAvailabilityExceptions
     * const unitAvailabilityExceptions = await prisma.unitAvailabilityException.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitAvailabilityExceptionWithIdOnly = await prisma.unitAvailabilityException.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitAvailabilityExceptionFindManyArgs>(args?: SelectSubset<T, UnitAvailabilityExceptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAvailabilityExceptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitAvailabilityException.
     * @param {UnitAvailabilityExceptionCreateArgs} args - Arguments to create a UnitAvailabilityException.
     * @example
     * // Create one UnitAvailabilityException
     * const UnitAvailabilityException = await prisma.unitAvailabilityException.create({
     *   data: {
     *     // ... data to create a UnitAvailabilityException
     *   }
     * })
     * 
     */
    create<T extends UnitAvailabilityExceptionCreateArgs>(args: SelectSubset<T, UnitAvailabilityExceptionCreateArgs<ExtArgs>>): Prisma__UnitAvailabilityExceptionClient<$Result.GetResult<Prisma.$UnitAvailabilityExceptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitAvailabilityExceptions.
     * @param {UnitAvailabilityExceptionCreateManyArgs} args - Arguments to create many UnitAvailabilityExceptions.
     * @example
     * // Create many UnitAvailabilityExceptions
     * const unitAvailabilityException = await prisma.unitAvailabilityException.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitAvailabilityExceptionCreateManyArgs>(args?: SelectSubset<T, UnitAvailabilityExceptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitAvailabilityExceptions and returns the data saved in the database.
     * @param {UnitAvailabilityExceptionCreateManyAndReturnArgs} args - Arguments to create many UnitAvailabilityExceptions.
     * @example
     * // Create many UnitAvailabilityExceptions
     * const unitAvailabilityException = await prisma.unitAvailabilityException.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitAvailabilityExceptions and only return the `id`
     * const unitAvailabilityExceptionWithIdOnly = await prisma.unitAvailabilityException.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitAvailabilityExceptionCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitAvailabilityExceptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAvailabilityExceptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitAvailabilityException.
     * @param {UnitAvailabilityExceptionDeleteArgs} args - Arguments to delete one UnitAvailabilityException.
     * @example
     * // Delete one UnitAvailabilityException
     * const UnitAvailabilityException = await prisma.unitAvailabilityException.delete({
     *   where: {
     *     // ... filter to delete one UnitAvailabilityException
     *   }
     * })
     * 
     */
    delete<T extends UnitAvailabilityExceptionDeleteArgs>(args: SelectSubset<T, UnitAvailabilityExceptionDeleteArgs<ExtArgs>>): Prisma__UnitAvailabilityExceptionClient<$Result.GetResult<Prisma.$UnitAvailabilityExceptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitAvailabilityException.
     * @param {UnitAvailabilityExceptionUpdateArgs} args - Arguments to update one UnitAvailabilityException.
     * @example
     * // Update one UnitAvailabilityException
     * const unitAvailabilityException = await prisma.unitAvailabilityException.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitAvailabilityExceptionUpdateArgs>(args: SelectSubset<T, UnitAvailabilityExceptionUpdateArgs<ExtArgs>>): Prisma__UnitAvailabilityExceptionClient<$Result.GetResult<Prisma.$UnitAvailabilityExceptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitAvailabilityExceptions.
     * @param {UnitAvailabilityExceptionDeleteManyArgs} args - Arguments to filter UnitAvailabilityExceptions to delete.
     * @example
     * // Delete a few UnitAvailabilityExceptions
     * const { count } = await prisma.unitAvailabilityException.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitAvailabilityExceptionDeleteManyArgs>(args?: SelectSubset<T, UnitAvailabilityExceptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitAvailabilityExceptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAvailabilityExceptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitAvailabilityExceptions
     * const unitAvailabilityException = await prisma.unitAvailabilityException.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitAvailabilityExceptionUpdateManyArgs>(args: SelectSubset<T, UnitAvailabilityExceptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitAvailabilityExceptions and returns the data updated in the database.
     * @param {UnitAvailabilityExceptionUpdateManyAndReturnArgs} args - Arguments to update many UnitAvailabilityExceptions.
     * @example
     * // Update many UnitAvailabilityExceptions
     * const unitAvailabilityException = await prisma.unitAvailabilityException.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitAvailabilityExceptions and only return the `id`
     * const unitAvailabilityExceptionWithIdOnly = await prisma.unitAvailabilityException.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitAvailabilityExceptionUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitAvailabilityExceptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitAvailabilityExceptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitAvailabilityException.
     * @param {UnitAvailabilityExceptionUpsertArgs} args - Arguments to update or create a UnitAvailabilityException.
     * @example
     * // Update or create a UnitAvailabilityException
     * const unitAvailabilityException = await prisma.unitAvailabilityException.upsert({
     *   create: {
     *     // ... data to create a UnitAvailabilityException
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitAvailabilityException we want to update
     *   }
     * })
     */
    upsert<T extends UnitAvailabilityExceptionUpsertArgs>(args: SelectSubset<T, UnitAvailabilityExceptionUpsertArgs<ExtArgs>>): Prisma__UnitAvailabilityExceptionClient<$Result.GetResult<Prisma.$UnitAvailabilityExceptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitAvailabilityExceptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAvailabilityExceptionCountArgs} args - Arguments to filter UnitAvailabilityExceptions to count.
     * @example
     * // Count the number of UnitAvailabilityExceptions
     * const count = await prisma.unitAvailabilityException.count({
     *   where: {
     *     // ... the filter for the UnitAvailabilityExceptions we want to count
     *   }
     * })
    **/
    count<T extends UnitAvailabilityExceptionCountArgs>(
      args?: Subset<T, UnitAvailabilityExceptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitAvailabilityExceptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitAvailabilityException.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAvailabilityExceptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAvailabilityExceptionAggregateArgs>(args: Subset<T, UnitAvailabilityExceptionAggregateArgs>): Prisma.PrismaPromise<GetUnitAvailabilityExceptionAggregateType<T>>

    /**
     * Group by UnitAvailabilityException.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAvailabilityExceptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitAvailabilityExceptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitAvailabilityExceptionGroupByArgs['orderBy'] }
        : { orderBy?: UnitAvailabilityExceptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitAvailabilityExceptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitAvailabilityExceptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitAvailabilityException model
   */
  readonly fields: UnitAvailabilityExceptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitAvailabilityException.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitAvailabilityExceptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitAvailabilityException model
   */
  interface UnitAvailabilityExceptionFieldRefs {
    readonly id: FieldRef<"UnitAvailabilityException", 'String'>
    readonly unit_id: FieldRef<"UnitAvailabilityException", 'String'>
    readonly date: FieldRef<"UnitAvailabilityException", 'String'>
    readonly type: FieldRef<"UnitAvailabilityException", 'UnitAvailabilityExceptionType'>
    readonly start_time: FieldRef<"UnitAvailabilityException", 'String'>
    readonly end_time: FieldRef<"UnitAvailabilityException", 'String'>
    readonly slot_duration_minutes: FieldRef<"UnitAvailabilityException", 'Int'>
    readonly reason: FieldRef<"UnitAvailabilityException", 'String'>
    readonly created_at: FieldRef<"UnitAvailabilityException", 'DateTime'>
    readonly updated_at: FieldRef<"UnitAvailabilityException", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitAvailabilityException findUnique
   */
  export type UnitAvailabilityExceptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityException
     */
    select?: UnitAvailabilityExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityException
     */
    omit?: UnitAvailabilityExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityExceptionInclude<ExtArgs> | null
    /**
     * Filter, which UnitAvailabilityException to fetch.
     */
    where: UnitAvailabilityExceptionWhereUniqueInput
  }

  /**
   * UnitAvailabilityException findUniqueOrThrow
   */
  export type UnitAvailabilityExceptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityException
     */
    select?: UnitAvailabilityExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityException
     */
    omit?: UnitAvailabilityExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityExceptionInclude<ExtArgs> | null
    /**
     * Filter, which UnitAvailabilityException to fetch.
     */
    where: UnitAvailabilityExceptionWhereUniqueInput
  }

  /**
   * UnitAvailabilityException findFirst
   */
  export type UnitAvailabilityExceptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityException
     */
    select?: UnitAvailabilityExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityException
     */
    omit?: UnitAvailabilityExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityExceptionInclude<ExtArgs> | null
    /**
     * Filter, which UnitAvailabilityException to fetch.
     */
    where?: UnitAvailabilityExceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAvailabilityExceptions to fetch.
     */
    orderBy?: UnitAvailabilityExceptionOrderByWithRelationInput | UnitAvailabilityExceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitAvailabilityExceptions.
     */
    cursor?: UnitAvailabilityExceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAvailabilityExceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAvailabilityExceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitAvailabilityExceptions.
     */
    distinct?: UnitAvailabilityExceptionScalarFieldEnum | UnitAvailabilityExceptionScalarFieldEnum[]
  }

  /**
   * UnitAvailabilityException findFirstOrThrow
   */
  export type UnitAvailabilityExceptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityException
     */
    select?: UnitAvailabilityExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityException
     */
    omit?: UnitAvailabilityExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityExceptionInclude<ExtArgs> | null
    /**
     * Filter, which UnitAvailabilityException to fetch.
     */
    where?: UnitAvailabilityExceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAvailabilityExceptions to fetch.
     */
    orderBy?: UnitAvailabilityExceptionOrderByWithRelationInput | UnitAvailabilityExceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitAvailabilityExceptions.
     */
    cursor?: UnitAvailabilityExceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAvailabilityExceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAvailabilityExceptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitAvailabilityExceptions.
     */
    distinct?: UnitAvailabilityExceptionScalarFieldEnum | UnitAvailabilityExceptionScalarFieldEnum[]
  }

  /**
   * UnitAvailabilityException findMany
   */
  export type UnitAvailabilityExceptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityException
     */
    select?: UnitAvailabilityExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityException
     */
    omit?: UnitAvailabilityExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityExceptionInclude<ExtArgs> | null
    /**
     * Filter, which UnitAvailabilityExceptions to fetch.
     */
    where?: UnitAvailabilityExceptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitAvailabilityExceptions to fetch.
     */
    orderBy?: UnitAvailabilityExceptionOrderByWithRelationInput | UnitAvailabilityExceptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitAvailabilityExceptions.
     */
    cursor?: UnitAvailabilityExceptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitAvailabilityExceptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitAvailabilityExceptions.
     */
    skip?: number
    distinct?: UnitAvailabilityExceptionScalarFieldEnum | UnitAvailabilityExceptionScalarFieldEnum[]
  }

  /**
   * UnitAvailabilityException create
   */
  export type UnitAvailabilityExceptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityException
     */
    select?: UnitAvailabilityExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityException
     */
    omit?: UnitAvailabilityExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityExceptionInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitAvailabilityException.
     */
    data: XOR<UnitAvailabilityExceptionCreateInput, UnitAvailabilityExceptionUncheckedCreateInput>
  }

  /**
   * UnitAvailabilityException createMany
   */
  export type UnitAvailabilityExceptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitAvailabilityExceptions.
     */
    data: UnitAvailabilityExceptionCreateManyInput | UnitAvailabilityExceptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitAvailabilityException createManyAndReturn
   */
  export type UnitAvailabilityExceptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityException
     */
    select?: UnitAvailabilityExceptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityException
     */
    omit?: UnitAvailabilityExceptionOmit<ExtArgs> | null
    /**
     * The data used to create many UnitAvailabilityExceptions.
     */
    data: UnitAvailabilityExceptionCreateManyInput | UnitAvailabilityExceptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityExceptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitAvailabilityException update
   */
  export type UnitAvailabilityExceptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityException
     */
    select?: UnitAvailabilityExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityException
     */
    omit?: UnitAvailabilityExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityExceptionInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitAvailabilityException.
     */
    data: XOR<UnitAvailabilityExceptionUpdateInput, UnitAvailabilityExceptionUncheckedUpdateInput>
    /**
     * Choose, which UnitAvailabilityException to update.
     */
    where: UnitAvailabilityExceptionWhereUniqueInput
  }

  /**
   * UnitAvailabilityException updateMany
   */
  export type UnitAvailabilityExceptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitAvailabilityExceptions.
     */
    data: XOR<UnitAvailabilityExceptionUpdateManyMutationInput, UnitAvailabilityExceptionUncheckedUpdateManyInput>
    /**
     * Filter which UnitAvailabilityExceptions to update
     */
    where?: UnitAvailabilityExceptionWhereInput
    /**
     * Limit how many UnitAvailabilityExceptions to update.
     */
    limit?: number
  }

  /**
   * UnitAvailabilityException updateManyAndReturn
   */
  export type UnitAvailabilityExceptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityException
     */
    select?: UnitAvailabilityExceptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityException
     */
    omit?: UnitAvailabilityExceptionOmit<ExtArgs> | null
    /**
     * The data used to update UnitAvailabilityExceptions.
     */
    data: XOR<UnitAvailabilityExceptionUpdateManyMutationInput, UnitAvailabilityExceptionUncheckedUpdateManyInput>
    /**
     * Filter which UnitAvailabilityExceptions to update
     */
    where?: UnitAvailabilityExceptionWhereInput
    /**
     * Limit how many UnitAvailabilityExceptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityExceptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitAvailabilityException upsert
   */
  export type UnitAvailabilityExceptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityException
     */
    select?: UnitAvailabilityExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityException
     */
    omit?: UnitAvailabilityExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityExceptionInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitAvailabilityException to update in case it exists.
     */
    where: UnitAvailabilityExceptionWhereUniqueInput
    /**
     * In case the UnitAvailabilityException found by the `where` argument doesn't exist, create a new UnitAvailabilityException with this data.
     */
    create: XOR<UnitAvailabilityExceptionCreateInput, UnitAvailabilityExceptionUncheckedCreateInput>
    /**
     * In case the UnitAvailabilityException was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitAvailabilityExceptionUpdateInput, UnitAvailabilityExceptionUncheckedUpdateInput>
  }

  /**
   * UnitAvailabilityException delete
   */
  export type UnitAvailabilityExceptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityException
     */
    select?: UnitAvailabilityExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityException
     */
    omit?: UnitAvailabilityExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityExceptionInclude<ExtArgs> | null
    /**
     * Filter which UnitAvailabilityException to delete.
     */
    where: UnitAvailabilityExceptionWhereUniqueInput
  }

  /**
   * UnitAvailabilityException deleteMany
   */
  export type UnitAvailabilityExceptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitAvailabilityExceptions to delete
     */
    where?: UnitAvailabilityExceptionWhereInput
    /**
     * Limit how many UnitAvailabilityExceptions to delete.
     */
    limit?: number
  }

  /**
   * UnitAvailabilityException without action
   */
  export type UnitAvailabilityExceptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitAvailabilityException
     */
    select?: UnitAvailabilityExceptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitAvailabilityException
     */
    omit?: UnitAvailabilityExceptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitAvailabilityExceptionInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    price: number | null
    trial_days: number | null
  }

  export type PlanSumAggregateOutputType = {
    price: number | null
    trial_days: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    currency: string | null
    interval: $Enums.RenewalInterval | null
    trial_days: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    currency: string | null
    interval: $Enums.RenewalInterval | null
    trial_days: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    currency: number
    interval: number
    features: number
    limits: number
    trial_days: number
    is_active: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    price?: true
    trial_days?: true
  }

  export type PlanSumAggregateInputType = {
    price?: true
    trial_days?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    trial_days?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    trial_days?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    currency?: true
    interval?: true
    features?: true
    limits?: true
    trial_days?: true
    is_active?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: number
    currency: string
    interval: $Enums.RenewalInterval
    features: JsonValue
    limits: JsonValue
    trial_days: number | null
    is_active: boolean
    metadata: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    features?: boolean
    limits?: boolean
    trial_days?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    features?: boolean
    limits?: boolean
    trial_days?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    features?: boolean
    limits?: boolean
    trial_days?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    currency?: boolean
    interval?: boolean
    features?: boolean
    limits?: boolean
    trial_days?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "currency" | "interval" | "features" | "limits" | "trial_days" | "is_active" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["plan"]>
  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: number
      currency: string
      interval: $Enums.RenewalInterval
      features: Prisma.JsonValue
      limits: Prisma.JsonValue
      trial_days: number | null
      is_active: boolean
      metadata: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans and returns the data updated in the database.
     * @param {PlanUpdateManyAndReturnArgs} args - Arguments to update many Plans.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends Plan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly description: FieldRef<"Plan", 'String'>
    readonly price: FieldRef<"Plan", 'Int'>
    readonly currency: FieldRef<"Plan", 'String'>
    readonly interval: FieldRef<"Plan", 'RenewalInterval'>
    readonly features: FieldRef<"Plan", 'Json'>
    readonly limits: FieldRef<"Plan", 'Json'>
    readonly trial_days: FieldRef<"Plan", 'Int'>
    readonly is_active: FieldRef<"Plan", 'Boolean'>
    readonly metadata: FieldRef<"Plan", 'Json'>
    readonly created_at: FieldRef<"Plan", 'DateTime'>
    readonly updated_at: FieldRef<"Plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan updateManyAndReturn
   */
  export type PlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to delete.
     */
    limit?: number
  }

  /**
   * Plan.subscriptions
   */
  export type Plan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    unit_id: string | null
    user_id: string | null
    plan_id: string | null
    status: $Enums.SubscriptionStatus | null
    start_date: Date | null
    current_period_start: Date | null
    current_period_end: Date | null
    cancel_at_period_end: boolean | null
    canceled_at: Date | null
    trial_end: Date | null
    renewal_interval: $Enums.RenewalInterval | null
    discount_id: string | null
    provider_subscription_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    unit_id: string | null
    user_id: string | null
    plan_id: string | null
    status: $Enums.SubscriptionStatus | null
    start_date: Date | null
    current_period_start: Date | null
    current_period_end: Date | null
    cancel_at_period_end: boolean | null
    canceled_at: Date | null
    trial_end: Date | null
    renewal_interval: $Enums.RenewalInterval | null
    discount_id: string | null
    provider_subscription_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    unit_id: number
    user_id: number
    plan_id: number
    status: number
    start_date: number
    current_period_start: number
    current_period_end: number
    cancel_at_period_end: number
    canceled_at: number
    trial_end: number
    renewal_interval: number
    discount_id: number
    provider_subscription_id: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    unit_id?: true
    user_id?: true
    plan_id?: true
    status?: true
    start_date?: true
    current_period_start?: true
    current_period_end?: true
    cancel_at_period_end?: true
    canceled_at?: true
    trial_end?: true
    renewal_interval?: true
    discount_id?: true
    provider_subscription_id?: true
    created_at?: true
    updated_at?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    unit_id?: true
    user_id?: true
    plan_id?: true
    status?: true
    start_date?: true
    current_period_start?: true
    current_period_end?: true
    cancel_at_period_end?: true
    canceled_at?: true
    trial_end?: true
    renewal_interval?: true
    discount_id?: true
    provider_subscription_id?: true
    created_at?: true
    updated_at?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    unit_id?: true
    user_id?: true
    plan_id?: true
    status?: true
    start_date?: true
    current_period_start?: true
    current_period_end?: true
    cancel_at_period_end?: true
    canceled_at?: true
    trial_end?: true
    renewal_interval?: true
    discount_id?: true
    provider_subscription_id?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    unit_id: string
    user_id: string
    plan_id: string
    status: $Enums.SubscriptionStatus
    start_date: Date
    current_period_start: Date
    current_period_end: Date
    cancel_at_period_end: boolean
    canceled_at: Date | null
    trial_end: Date | null
    renewal_interval: $Enums.RenewalInterval
    discount_id: string | null
    provider_subscription_id: string | null
    metadata: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    user_id?: boolean
    plan_id?: boolean
    status?: boolean
    start_date?: boolean
    current_period_start?: boolean
    current_period_end?: boolean
    cancel_at_period_end?: boolean
    canceled_at?: boolean
    trial_end?: boolean
    renewal_interval?: boolean
    discount_id?: boolean
    provider_subscription_id?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    discount?: boolean | Subscription$discountArgs<ExtArgs>
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>
    coupon_redemptions?: boolean | Subscription$coupon_redemptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    user_id?: boolean
    plan_id?: boolean
    status?: boolean
    start_date?: boolean
    current_period_start?: boolean
    current_period_end?: boolean
    cancel_at_period_end?: boolean
    canceled_at?: boolean
    trial_end?: boolean
    renewal_interval?: boolean
    discount_id?: boolean
    provider_subscription_id?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    discount?: boolean | Subscription$discountArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    unit_id?: boolean
    user_id?: boolean
    plan_id?: boolean
    status?: boolean
    start_date?: boolean
    current_period_start?: boolean
    current_period_end?: boolean
    cancel_at_period_end?: boolean
    canceled_at?: boolean
    trial_end?: boolean
    renewal_interval?: boolean
    discount_id?: boolean
    provider_subscription_id?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    discount?: boolean | Subscription$discountArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    unit_id?: boolean
    user_id?: boolean
    plan_id?: boolean
    status?: boolean
    start_date?: boolean
    current_period_start?: boolean
    current_period_end?: boolean
    cancel_at_period_end?: boolean
    canceled_at?: boolean
    trial_end?: boolean
    renewal_interval?: boolean
    discount_id?: boolean
    provider_subscription_id?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "unit_id" | "user_id" | "plan_id" | "status" | "start_date" | "current_period_start" | "current_period_end" | "cancel_at_period_end" | "canceled_at" | "trial_end" | "renewal_interval" | "discount_id" | "provider_subscription_id" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    discount?: boolean | Subscription$discountArgs<ExtArgs>
    invoices?: boolean | Subscription$invoicesArgs<ExtArgs>
    coupon_redemptions?: boolean | Subscription$coupon_redemptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    discount?: boolean | Subscription$discountArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    discount?: boolean | Subscription$discountArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      unit: Prisma.$UnitPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      plan: Prisma.$PlanPayload<ExtArgs>
      discount: Prisma.$DiscountPayload<ExtArgs> | null
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      coupon_redemptions: Prisma.$CouponRedemptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      unit_id: string
      user_id: string
      plan_id: string
      status: $Enums.SubscriptionStatus
      start_date: Date
      current_period_start: Date
      current_period_end: Date
      cancel_at_period_end: boolean
      canceled_at: Date | null
      trial_end: Date | null
      renewal_interval: $Enums.RenewalInterval
      discount_id: string | null
      provider_subscription_id: string | null
      metadata: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    discount<T extends Subscription$discountArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$discountArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoices<T extends Subscription$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coupon_redemptions<T extends Subscription$coupon_redemptionsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$coupon_redemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly unit_id: FieldRef<"Subscription", 'String'>
    readonly user_id: FieldRef<"Subscription", 'String'>
    readonly plan_id: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly start_date: FieldRef<"Subscription", 'DateTime'>
    readonly current_period_start: FieldRef<"Subscription", 'DateTime'>
    readonly current_period_end: FieldRef<"Subscription", 'DateTime'>
    readonly cancel_at_period_end: FieldRef<"Subscription", 'Boolean'>
    readonly canceled_at: FieldRef<"Subscription", 'DateTime'>
    readonly trial_end: FieldRef<"Subscription", 'DateTime'>
    readonly renewal_interval: FieldRef<"Subscription", 'RenewalInterval'>
    readonly discount_id: FieldRef<"Subscription", 'String'>
    readonly provider_subscription_id: FieldRef<"Subscription", 'String'>
    readonly metadata: FieldRef<"Subscription", 'Json'>
    readonly created_at: FieldRef<"Subscription", 'DateTime'>
    readonly updated_at: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.discount
   */
  export type Subscription$discountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    where?: DiscountWhereInput
  }

  /**
   * Subscription.invoices
   */
  export type Subscription$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Subscription.coupon_redemptions
   */
  export type Subscription$coupon_redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouponRedemption
     */
    omit?: CouponRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    where?: CouponRedemptionWhereInput
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    cursor?: CouponRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    subscription_id: string | null
    amount: number | null
    currency: string | null
    status: $Enums.InvoiceStatus | null
    due_date: Date | null
    paid_at: Date | null
    provider_invoice_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    subscription_id: string | null
    amount: number | null
    currency: string | null
    status: $Enums.InvoiceStatus | null
    due_date: Date | null
    paid_at: Date | null
    provider_invoice_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    user_id: number
    subscription_id: number
    amount: number
    currency: number
    status: number
    line_items: number
    due_date: number
    paid_at: number
    provider_invoice_id: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    user_id?: true
    subscription_id?: true
    amount?: true
    currency?: true
    status?: true
    due_date?: true
    paid_at?: true
    provider_invoice_id?: true
    created_at?: true
    updated_at?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    user_id?: true
    subscription_id?: true
    amount?: true
    currency?: true
    status?: true
    due_date?: true
    paid_at?: true
    provider_invoice_id?: true
    created_at?: true
    updated_at?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    user_id?: true
    subscription_id?: true
    amount?: true
    currency?: true
    status?: true
    line_items?: true
    due_date?: true
    paid_at?: true
    provider_invoice_id?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    user_id: string
    subscription_id: string
    amount: number
    currency: string
    status: $Enums.InvoiceStatus
    line_items: JsonValue
    due_date: Date
    paid_at: Date | null
    provider_invoice_id: string | null
    metadata: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    subscription_id?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    line_items?: boolean
    due_date?: boolean
    paid_at?: boolean
    provider_invoice_id?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    subscription_id?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    line_items?: boolean
    due_date?: boolean
    paid_at?: boolean
    provider_invoice_id?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    subscription_id?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    line_items?: boolean
    due_date?: boolean
    paid_at?: boolean
    provider_invoice_id?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    user_id?: boolean
    subscription_id?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    line_items?: boolean
    due_date?: boolean
    paid_at?: boolean
    provider_invoice_id?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "subscription_id" | "amount" | "currency" | "status" | "line_items" | "due_date" | "paid_at" | "provider_invoice_id" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      subscription_id: string
      amount: number
      currency: string
      status: $Enums.InvoiceStatus
      line_items: Prisma.JsonValue
      due_date: Date
      paid_at: Date | null
      provider_invoice_id: string | null
      metadata: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly user_id: FieldRef<"Invoice", 'String'>
    readonly subscription_id: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Int'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly line_items: FieldRef<"Invoice", 'Json'>
    readonly due_date: FieldRef<"Invoice", 'DateTime'>
    readonly paid_at: FieldRef<"Invoice", 'DateTime'>
    readonly provider_invoice_id: FieldRef<"Invoice", 'String'>
    readonly metadata: FieldRef<"Invoice", 'Json'>
    readonly created_at: FieldRef<"Invoice", 'DateTime'>
    readonly updated_at: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Discount
   */

  export type AggregateDiscount = {
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  export type DiscountAvgAggregateOutputType = {
    value: number | null
    repeating_count: number | null
    max_redemptions: number | null
    redemptions_count: number | null
  }

  export type DiscountSumAggregateOutputType = {
    value: number | null
    repeating_count: number | null
    max_redemptions: number | null
    redemptions_count: number | null
  }

  export type DiscountMinAggregateOutputType = {
    id: string | null
    code: string | null
    type: $Enums.DiscountType | null
    value: number | null
    duration: $Enums.DiscountDuration | null
    repeating_count: number | null
    assigned_to_user_id: string | null
    max_redemptions: number | null
    redemptions_count: number | null
    expires_at: Date | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DiscountMaxAggregateOutputType = {
    id: string | null
    code: string | null
    type: $Enums.DiscountType | null
    value: number | null
    duration: $Enums.DiscountDuration | null
    repeating_count: number | null
    assigned_to_user_id: string | null
    max_redemptions: number | null
    redemptions_count: number | null
    expires_at: Date | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DiscountCountAggregateOutputType = {
    id: number
    code: number
    type: number
    value: number
    duration: number
    repeating_count: number
    assigned_to_user_id: number
    max_redemptions: number
    redemptions_count: number
    expires_at: number
    is_active: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DiscountAvgAggregateInputType = {
    value?: true
    repeating_count?: true
    max_redemptions?: true
    redemptions_count?: true
  }

  export type DiscountSumAggregateInputType = {
    value?: true
    repeating_count?: true
    max_redemptions?: true
    redemptions_count?: true
  }

  export type DiscountMinAggregateInputType = {
    id?: true
    code?: true
    type?: true
    value?: true
    duration?: true
    repeating_count?: true
    assigned_to_user_id?: true
    max_redemptions?: true
    redemptions_count?: true
    expires_at?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type DiscountMaxAggregateInputType = {
    id?: true
    code?: true
    type?: true
    value?: true
    duration?: true
    repeating_count?: true
    assigned_to_user_id?: true
    max_redemptions?: true
    redemptions_count?: true
    expires_at?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type DiscountCountAggregateInputType = {
    id?: true
    code?: true
    type?: true
    value?: true
    duration?: true
    repeating_count?: true
    assigned_to_user_id?: true
    max_redemptions?: true
    redemptions_count?: true
    expires_at?: true
    is_active?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discount to aggregate.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Discounts
    **/
    _count?: true | DiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountMaxAggregateInputType
  }

  export type GetDiscountAggregateType<T extends DiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscount[P]>
      : GetScalarType<T[P], AggregateDiscount[P]>
  }




  export type DiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountWhereInput
    orderBy?: DiscountOrderByWithAggregationInput | DiscountOrderByWithAggregationInput[]
    by: DiscountScalarFieldEnum[] | DiscountScalarFieldEnum
    having?: DiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountCountAggregateInputType | true
    _avg?: DiscountAvgAggregateInputType
    _sum?: DiscountSumAggregateInputType
    _min?: DiscountMinAggregateInputType
    _max?: DiscountMaxAggregateInputType
  }

  export type DiscountGroupByOutputType = {
    id: string
    code: string
    type: $Enums.DiscountType
    value: number
    duration: $Enums.DiscountDuration
    repeating_count: number | null
    assigned_to_user_id: string | null
    max_redemptions: number | null
    redemptions_count: number
    expires_at: Date | null
    is_active: boolean
    metadata: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  type GetDiscountGroupByPayload<T extends DiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountGroupByOutputType[P]>
        }
      >
    >


  export type DiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    type?: boolean
    value?: boolean
    duration?: boolean
    repeating_count?: boolean
    assigned_to_user_id?: boolean
    max_redemptions?: boolean
    redemptions_count?: boolean
    expires_at?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    subscriptions?: boolean | Discount$subscriptionsArgs<ExtArgs>
    _count?: boolean | DiscountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    type?: boolean
    value?: boolean
    duration?: boolean
    repeating_count?: boolean
    assigned_to_user_id?: boolean
    max_redemptions?: boolean
    redemptions_count?: boolean
    expires_at?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    type?: boolean
    value?: boolean
    duration?: boolean
    repeating_count?: boolean
    assigned_to_user_id?: boolean
    max_redemptions?: boolean
    redemptions_count?: boolean
    expires_at?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectScalar = {
    id?: boolean
    code?: boolean
    type?: boolean
    value?: boolean
    duration?: boolean
    repeating_count?: boolean
    assigned_to_user_id?: boolean
    max_redemptions?: boolean
    redemptions_count?: boolean
    expires_at?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type DiscountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "type" | "value" | "duration" | "repeating_count" | "assigned_to_user_id" | "max_redemptions" | "redemptions_count" | "expires_at" | "is_active" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["discount"]>
  export type DiscountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | Discount$subscriptionsArgs<ExtArgs>
    _count?: boolean | DiscountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DiscountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DiscountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Discount"
    objects: {
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      type: $Enums.DiscountType
      value: number
      duration: $Enums.DiscountDuration
      repeating_count: number | null
      assigned_to_user_id: string | null
      max_redemptions: number | null
      redemptions_count: number
      expires_at: Date | null
      is_active: boolean
      metadata: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["discount"]>
    composites: {}
  }

  type DiscountGetPayload<S extends boolean | null | undefined | DiscountDefaultArgs> = $Result.GetResult<Prisma.$DiscountPayload, S>

  type DiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscountCountAggregateInputType | true
    }

  export interface DiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Discount'], meta: { name: 'Discount' } }
    /**
     * Find zero or one Discount that matches the filter.
     * @param {DiscountFindUniqueArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscountFindUniqueArgs>(args: SelectSubset<T, DiscountFindUniqueArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Discount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscountFindUniqueOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscountFindFirstArgs>(args?: SelectSubset<T, DiscountFindFirstArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Discounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discounts
     * const discounts = await prisma.discount.findMany()
     * 
     * // Get first 10 Discounts
     * const discounts = await prisma.discount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountWithIdOnly = await prisma.discount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscountFindManyArgs>(args?: SelectSubset<T, DiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Discount.
     * @param {DiscountCreateArgs} args - Arguments to create a Discount.
     * @example
     * // Create one Discount
     * const Discount = await prisma.discount.create({
     *   data: {
     *     // ... data to create a Discount
     *   }
     * })
     * 
     */
    create<T extends DiscountCreateArgs>(args: SelectSubset<T, DiscountCreateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Discounts.
     * @param {DiscountCreateManyArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscountCreateManyArgs>(args?: SelectSubset<T, DiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Discounts and returns the data saved in the database.
     * @param {DiscountCreateManyAndReturnArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Discounts and only return the `id`
     * const discountWithIdOnly = await prisma.discount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscountCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Discount.
     * @param {DiscountDeleteArgs} args - Arguments to delete one Discount.
     * @example
     * // Delete one Discount
     * const Discount = await prisma.discount.delete({
     *   where: {
     *     // ... filter to delete one Discount
     *   }
     * })
     * 
     */
    delete<T extends DiscountDeleteArgs>(args: SelectSubset<T, DiscountDeleteArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Discount.
     * @param {DiscountUpdateArgs} args - Arguments to update one Discount.
     * @example
     * // Update one Discount
     * const discount = await prisma.discount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscountUpdateArgs>(args: SelectSubset<T, DiscountUpdateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Discounts.
     * @param {DiscountDeleteManyArgs} args - Arguments to filter Discounts to delete.
     * @example
     * // Delete a few Discounts
     * const { count } = await prisma.discount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscountDeleteManyArgs>(args?: SelectSubset<T, DiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscountUpdateManyArgs>(args: SelectSubset<T, DiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts and returns the data updated in the database.
     * @param {DiscountUpdateManyAndReturnArgs} args - Arguments to update many Discounts.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Discounts and only return the `id`
     * const discountWithIdOnly = await prisma.discount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscountUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Discount.
     * @param {DiscountUpsertArgs} args - Arguments to update or create a Discount.
     * @example
     * // Update or create a Discount
     * const discount = await prisma.discount.upsert({
     *   create: {
     *     // ... data to create a Discount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discount we want to update
     *   }
     * })
     */
    upsert<T extends DiscountUpsertArgs>(args: SelectSubset<T, DiscountUpsertArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountCountArgs} args - Arguments to filter Discounts to count.
     * @example
     * // Count the number of Discounts
     * const count = await prisma.discount.count({
     *   where: {
     *     // ... the filter for the Discounts we want to count
     *   }
     * })
    **/
    count<T extends DiscountCountArgs>(
      args?: Subset<T, DiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountAggregateArgs>(args: Subset<T, DiscountAggregateArgs>): Prisma.PrismaPromise<GetDiscountAggregateType<T>>

    /**
     * Group by Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountGroupByArgs['orderBy'] }
        : { orderBy?: DiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Discount model
   */
  readonly fields: DiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Discount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscriptions<T extends Discount$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Discount$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Discount model
   */
  interface DiscountFieldRefs {
    readonly id: FieldRef<"Discount", 'String'>
    readonly code: FieldRef<"Discount", 'String'>
    readonly type: FieldRef<"Discount", 'DiscountType'>
    readonly value: FieldRef<"Discount", 'Int'>
    readonly duration: FieldRef<"Discount", 'DiscountDuration'>
    readonly repeating_count: FieldRef<"Discount", 'Int'>
    readonly assigned_to_user_id: FieldRef<"Discount", 'String'>
    readonly max_redemptions: FieldRef<"Discount", 'Int'>
    readonly redemptions_count: FieldRef<"Discount", 'Int'>
    readonly expires_at: FieldRef<"Discount", 'DateTime'>
    readonly is_active: FieldRef<"Discount", 'Boolean'>
    readonly metadata: FieldRef<"Discount", 'Json'>
    readonly created_at: FieldRef<"Discount", 'DateTime'>
    readonly updated_at: FieldRef<"Discount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Discount findUnique
   */
  export type DiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findUniqueOrThrow
   */
  export type DiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findFirst
   */
  export type DiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findFirstOrThrow
   */
  export type DiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findMany
   */
  export type DiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discounts to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount create
   */
  export type DiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The data needed to create a Discount.
     */
    data: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
  }

  /**
   * Discount createMany
   */
  export type DiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Discounts.
     */
    data: DiscountCreateManyInput | DiscountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Discount createManyAndReturn
   */
  export type DiscountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The data used to create many Discounts.
     */
    data: DiscountCreateManyInput | DiscountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Discount update
   */
  export type DiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The data needed to update a Discount.
     */
    data: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
    /**
     * Choose, which Discount to update.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount updateMany
   */
  export type DiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Discounts.
     */
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to update.
     */
    limit?: number
  }

  /**
   * Discount updateManyAndReturn
   */
  export type DiscountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The data used to update Discounts.
     */
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to update.
     */
    limit?: number
  }

  /**
   * Discount upsert
   */
  export type DiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The filter to search for the Discount to update in case it exists.
     */
    where: DiscountWhereUniqueInput
    /**
     * In case the Discount found by the `where` argument doesn't exist, create a new Discount with this data.
     */
    create: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
    /**
     * In case the Discount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
  }

  /**
   * Discount delete
   */
  export type DiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter which Discount to delete.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount deleteMany
   */
  export type DiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discounts to delete
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to delete.
     */
    limit?: number
  }

  /**
   * Discount.subscriptions
   */
  export type Discount$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Discount without action
   */
  export type DiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
  }


  /**
   * Model CouponRedemption
   */

  export type AggregateCouponRedemption = {
    _count: CouponRedemptionCountAggregateOutputType | null
    _min: CouponRedemptionMinAggregateOutputType | null
    _max: CouponRedemptionMaxAggregateOutputType | null
  }

  export type CouponRedemptionMinAggregateOutputType = {
    id: string | null
    coupon_id: string | null
    user_id: string | null
    subscription_id: string | null
    redeemed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CouponRedemptionMaxAggregateOutputType = {
    id: string | null
    coupon_id: string | null
    user_id: string | null
    subscription_id: string | null
    redeemed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CouponRedemptionCountAggregateOutputType = {
    id: number
    coupon_id: number
    user_id: number
    subscription_id: number
    redeemed_at: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CouponRedemptionMinAggregateInputType = {
    id?: true
    coupon_id?: true
    user_id?: true
    subscription_id?: true
    redeemed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type CouponRedemptionMaxAggregateInputType = {
    id?: true
    coupon_id?: true
    user_id?: true
    subscription_id?: true
    redeemed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type CouponRedemptionCountAggregateInputType = {
    id?: true
    coupon_id?: true
    user_id?: true
    subscription_id?: true
    redeemed_at?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CouponRedemptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CouponRedemption to aggregate.
     */
    where?: CouponRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouponRedemptions to fetch.
     */
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouponRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouponRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CouponRedemptions
    **/
    _count?: true | CouponRedemptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponRedemptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponRedemptionMaxAggregateInputType
  }

  export type GetCouponRedemptionAggregateType<T extends CouponRedemptionAggregateArgs> = {
        [P in keyof T & keyof AggregateCouponRedemption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCouponRedemption[P]>
      : GetScalarType<T[P], AggregateCouponRedemption[P]>
  }




  export type CouponRedemptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponRedemptionWhereInput
    orderBy?: CouponRedemptionOrderByWithAggregationInput | CouponRedemptionOrderByWithAggregationInput[]
    by: CouponRedemptionScalarFieldEnum[] | CouponRedemptionScalarFieldEnum
    having?: CouponRedemptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponRedemptionCountAggregateInputType | true
    _min?: CouponRedemptionMinAggregateInputType
    _max?: CouponRedemptionMaxAggregateInputType
  }

  export type CouponRedemptionGroupByOutputType = {
    id: string
    coupon_id: string
    user_id: string
    subscription_id: string
    redeemed_at: Date
    metadata: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: CouponRedemptionCountAggregateOutputType | null
    _min: CouponRedemptionMinAggregateOutputType | null
    _max: CouponRedemptionMaxAggregateOutputType | null
  }

  type GetCouponRedemptionGroupByPayload<T extends CouponRedemptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponRedemptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponRedemptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponRedemptionGroupByOutputType[P]>
            : GetScalarType<T[P], CouponRedemptionGroupByOutputType[P]>
        }
      >
    >


  export type CouponRedemptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coupon_id?: boolean
    user_id?: boolean
    subscription_id?: boolean
    redeemed_at?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["couponRedemption"]>

  export type CouponRedemptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coupon_id?: boolean
    user_id?: boolean
    subscription_id?: boolean
    redeemed_at?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["couponRedemption"]>

  export type CouponRedemptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coupon_id?: boolean
    user_id?: boolean
    subscription_id?: boolean
    redeemed_at?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["couponRedemption"]>

  export type CouponRedemptionSelectScalar = {
    id?: boolean
    coupon_id?: boolean
    user_id?: boolean
    subscription_id?: boolean
    redeemed_at?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CouponRedemptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "coupon_id" | "user_id" | "subscription_id" | "redeemed_at" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["couponRedemption"]>
  export type CouponRedemptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type CouponRedemptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type CouponRedemptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $CouponRedemptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CouponRedemption"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coupon_id: string
      user_id: string
      subscription_id: string
      redeemed_at: Date
      metadata: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["couponRedemption"]>
    composites: {}
  }

  type CouponRedemptionGetPayload<S extends boolean | null | undefined | CouponRedemptionDefaultArgs> = $Result.GetResult<Prisma.$CouponRedemptionPayload, S>

  type CouponRedemptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CouponRedemptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponRedemptionCountAggregateInputType | true
    }

  export interface CouponRedemptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CouponRedemption'], meta: { name: 'CouponRedemption' } }
    /**
     * Find zero or one CouponRedemption that matches the filter.
     * @param {CouponRedemptionFindUniqueArgs} args - Arguments to find a CouponRedemption
     * @example
     * // Get one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponRedemptionFindUniqueArgs>(args: SelectSubset<T, CouponRedemptionFindUniqueArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CouponRedemption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouponRedemptionFindUniqueOrThrowArgs} args - Arguments to find a CouponRedemption
     * @example
     * // Get one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponRedemptionFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponRedemptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CouponRedemption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionFindFirstArgs} args - Arguments to find a CouponRedemption
     * @example
     * // Get one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponRedemptionFindFirstArgs>(args?: SelectSubset<T, CouponRedemptionFindFirstArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CouponRedemption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionFindFirstOrThrowArgs} args - Arguments to find a CouponRedemption
     * @example
     * // Get one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponRedemptionFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponRedemptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CouponRedemptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CouponRedemptions
     * const couponRedemptions = await prisma.couponRedemption.findMany()
     * 
     * // Get first 10 CouponRedemptions
     * const couponRedemptions = await prisma.couponRedemption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponRedemptionWithIdOnly = await prisma.couponRedemption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponRedemptionFindManyArgs>(args?: SelectSubset<T, CouponRedemptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CouponRedemption.
     * @param {CouponRedemptionCreateArgs} args - Arguments to create a CouponRedemption.
     * @example
     * // Create one CouponRedemption
     * const CouponRedemption = await prisma.couponRedemption.create({
     *   data: {
     *     // ... data to create a CouponRedemption
     *   }
     * })
     * 
     */
    create<T extends CouponRedemptionCreateArgs>(args: SelectSubset<T, CouponRedemptionCreateArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CouponRedemptions.
     * @param {CouponRedemptionCreateManyArgs} args - Arguments to create many CouponRedemptions.
     * @example
     * // Create many CouponRedemptions
     * const couponRedemption = await prisma.couponRedemption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponRedemptionCreateManyArgs>(args?: SelectSubset<T, CouponRedemptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CouponRedemptions and returns the data saved in the database.
     * @param {CouponRedemptionCreateManyAndReturnArgs} args - Arguments to create many CouponRedemptions.
     * @example
     * // Create many CouponRedemptions
     * const couponRedemption = await prisma.couponRedemption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CouponRedemptions and only return the `id`
     * const couponRedemptionWithIdOnly = await prisma.couponRedemption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponRedemptionCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponRedemptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CouponRedemption.
     * @param {CouponRedemptionDeleteArgs} args - Arguments to delete one CouponRedemption.
     * @example
     * // Delete one CouponRedemption
     * const CouponRedemption = await prisma.couponRedemption.delete({
     *   where: {
     *     // ... filter to delete one CouponRedemption
     *   }
     * })
     * 
     */
    delete<T extends CouponRedemptionDeleteArgs>(args: SelectSubset<T, CouponRedemptionDeleteArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CouponRedemption.
     * @param {CouponRedemptionUpdateArgs} args - Arguments to update one CouponRedemption.
     * @example
     * // Update one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponRedemptionUpdateArgs>(args: SelectSubset<T, CouponRedemptionUpdateArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CouponRedemptions.
     * @param {CouponRedemptionDeleteManyArgs} args - Arguments to filter CouponRedemptions to delete.
     * @example
     * // Delete a few CouponRedemptions
     * const { count } = await prisma.couponRedemption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponRedemptionDeleteManyArgs>(args?: SelectSubset<T, CouponRedemptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CouponRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CouponRedemptions
     * const couponRedemption = await prisma.couponRedemption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponRedemptionUpdateManyArgs>(args: SelectSubset<T, CouponRedemptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CouponRedemptions and returns the data updated in the database.
     * @param {CouponRedemptionUpdateManyAndReturnArgs} args - Arguments to update many CouponRedemptions.
     * @example
     * // Update many CouponRedemptions
     * const couponRedemption = await prisma.couponRedemption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CouponRedemptions and only return the `id`
     * const couponRedemptionWithIdOnly = await prisma.couponRedemption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CouponRedemptionUpdateManyAndReturnArgs>(args: SelectSubset<T, CouponRedemptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CouponRedemption.
     * @param {CouponRedemptionUpsertArgs} args - Arguments to update or create a CouponRedemption.
     * @example
     * // Update or create a CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.upsert({
     *   create: {
     *     // ... data to create a CouponRedemption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CouponRedemption we want to update
     *   }
     * })
     */
    upsert<T extends CouponRedemptionUpsertArgs>(args: SelectSubset<T, CouponRedemptionUpsertArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CouponRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionCountArgs} args - Arguments to filter CouponRedemptions to count.
     * @example
     * // Count the number of CouponRedemptions
     * const count = await prisma.couponRedemption.count({
     *   where: {
     *     // ... the filter for the CouponRedemptions we want to count
     *   }
     * })
    **/
    count<T extends CouponRedemptionCountArgs>(
      args?: Subset<T, CouponRedemptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponRedemptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CouponRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponRedemptionAggregateArgs>(args: Subset<T, CouponRedemptionAggregateArgs>): Prisma.PrismaPromise<GetCouponRedemptionAggregateType<T>>

    /**
     * Group by CouponRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponRedemptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponRedemptionGroupByArgs['orderBy'] }
        : { orderBy?: CouponRedemptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponRedemptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponRedemptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CouponRedemption model
   */
  readonly fields: CouponRedemptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CouponRedemption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponRedemptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CouponRedemption model
   */
  interface CouponRedemptionFieldRefs {
    readonly id: FieldRef<"CouponRedemption", 'String'>
    readonly coupon_id: FieldRef<"CouponRedemption", 'String'>
    readonly user_id: FieldRef<"CouponRedemption", 'String'>
    readonly subscription_id: FieldRef<"CouponRedemption", 'String'>
    readonly redeemed_at: FieldRef<"CouponRedemption", 'DateTime'>
    readonly metadata: FieldRef<"CouponRedemption", 'Json'>
    readonly created_at: FieldRef<"CouponRedemption", 'DateTime'>
    readonly updated_at: FieldRef<"CouponRedemption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CouponRedemption findUnique
   */
  export type CouponRedemptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouponRedemption
     */
    omit?: CouponRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemption to fetch.
     */
    where: CouponRedemptionWhereUniqueInput
  }

  /**
   * CouponRedemption findUniqueOrThrow
   */
  export type CouponRedemptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouponRedemption
     */
    omit?: CouponRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemption to fetch.
     */
    where: CouponRedemptionWhereUniqueInput
  }

  /**
   * CouponRedemption findFirst
   */
  export type CouponRedemptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouponRedemption
     */
    omit?: CouponRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemption to fetch.
     */
    where?: CouponRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouponRedemptions to fetch.
     */
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CouponRedemptions.
     */
    cursor?: CouponRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouponRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouponRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CouponRedemptions.
     */
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * CouponRedemption findFirstOrThrow
   */
  export type CouponRedemptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouponRedemption
     */
    omit?: CouponRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemption to fetch.
     */
    where?: CouponRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouponRedemptions to fetch.
     */
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CouponRedemptions.
     */
    cursor?: CouponRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouponRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouponRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CouponRedemptions.
     */
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * CouponRedemption findMany
   */
  export type CouponRedemptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouponRedemption
     */
    omit?: CouponRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemptions to fetch.
     */
    where?: CouponRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouponRedemptions to fetch.
     */
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CouponRedemptions.
     */
    cursor?: CouponRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouponRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouponRedemptions.
     */
    skip?: number
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * CouponRedemption create
   */
  export type CouponRedemptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouponRedemption
     */
    omit?: CouponRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to create a CouponRedemption.
     */
    data: XOR<CouponRedemptionCreateInput, CouponRedemptionUncheckedCreateInput>
  }

  /**
   * CouponRedemption createMany
   */
  export type CouponRedemptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CouponRedemptions.
     */
    data: CouponRedemptionCreateManyInput | CouponRedemptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CouponRedemption createManyAndReturn
   */
  export type CouponRedemptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CouponRedemption
     */
    omit?: CouponRedemptionOmit<ExtArgs> | null
    /**
     * The data used to create many CouponRedemptions.
     */
    data: CouponRedemptionCreateManyInput | CouponRedemptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CouponRedemption update
   */
  export type CouponRedemptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouponRedemption
     */
    omit?: CouponRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to update a CouponRedemption.
     */
    data: XOR<CouponRedemptionUpdateInput, CouponRedemptionUncheckedUpdateInput>
    /**
     * Choose, which CouponRedemption to update.
     */
    where: CouponRedemptionWhereUniqueInput
  }

  /**
   * CouponRedemption updateMany
   */
  export type CouponRedemptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CouponRedemptions.
     */
    data: XOR<CouponRedemptionUpdateManyMutationInput, CouponRedemptionUncheckedUpdateManyInput>
    /**
     * Filter which CouponRedemptions to update
     */
    where?: CouponRedemptionWhereInput
    /**
     * Limit how many CouponRedemptions to update.
     */
    limit?: number
  }

  /**
   * CouponRedemption updateManyAndReturn
   */
  export type CouponRedemptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CouponRedemption
     */
    omit?: CouponRedemptionOmit<ExtArgs> | null
    /**
     * The data used to update CouponRedemptions.
     */
    data: XOR<CouponRedemptionUpdateManyMutationInput, CouponRedemptionUncheckedUpdateManyInput>
    /**
     * Filter which CouponRedemptions to update
     */
    where?: CouponRedemptionWhereInput
    /**
     * Limit how many CouponRedemptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CouponRedemption upsert
   */
  export type CouponRedemptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouponRedemption
     */
    omit?: CouponRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * The filter to search for the CouponRedemption to update in case it exists.
     */
    where: CouponRedemptionWhereUniqueInput
    /**
     * In case the CouponRedemption found by the `where` argument doesn't exist, create a new CouponRedemption with this data.
     */
    create: XOR<CouponRedemptionCreateInput, CouponRedemptionUncheckedCreateInput>
    /**
     * In case the CouponRedemption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponRedemptionUpdateInput, CouponRedemptionUncheckedUpdateInput>
  }

  /**
   * CouponRedemption delete
   */
  export type CouponRedemptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouponRedemption
     */
    omit?: CouponRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter which CouponRedemption to delete.
     */
    where: CouponRedemptionWhereUniqueInput
  }

  /**
   * CouponRedemption deleteMany
   */
  export type CouponRedemptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CouponRedemptions to delete
     */
    where?: CouponRedemptionWhereInput
    /**
     * Limit how many CouponRedemptions to delete.
     */
    limit?: number
  }

  /**
   * CouponRedemption without action
   */
  export type CouponRedemptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CouponRedemption
     */
    omit?: CouponRedemptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    target_user_id: string | null
    channel: $Enums.NotificationChannel | null
    template_id: string | null
    priority: $Enums.NotificationPriority | null
    status: $Enums.NotificationStatus | null
    provider_id: string | null
    error_message: string | null
    message_id: string | null
    sent_at: Date | null
    delivered_at: Date | null
    read_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    target_user_id: string | null
    channel: $Enums.NotificationChannel | null
    template_id: string | null
    priority: $Enums.NotificationPriority | null
    status: $Enums.NotificationStatus | null
    provider_id: string | null
    error_message: string | null
    message_id: string | null
    sent_at: Date | null
    delivered_at: Date | null
    read_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    target_user_id: number
    channel: number
    template_id: number
    payload: number
    priority: number
    status: number
    provider_id: number
    error_message: number
    metadata: number
    message_id: number
    sent_at: number
    delivered_at: number
    read_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    target_user_id?: true
    channel?: true
    template_id?: true
    priority?: true
    status?: true
    provider_id?: true
    error_message?: true
    message_id?: true
    sent_at?: true
    delivered_at?: true
    read_at?: true
    created_at?: true
    updated_at?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    target_user_id?: true
    channel?: true
    template_id?: true
    priority?: true
    status?: true
    provider_id?: true
    error_message?: true
    message_id?: true
    sent_at?: true
    delivered_at?: true
    read_at?: true
    created_at?: true
    updated_at?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    target_user_id?: true
    channel?: true
    template_id?: true
    payload?: true
    priority?: true
    status?: true
    provider_id?: true
    error_message?: true
    metadata?: true
    message_id?: true
    sent_at?: true
    delivered_at?: true
    read_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    target_user_id: string
    channel: $Enums.NotificationChannel
    template_id: string
    payload: JsonValue
    priority: $Enums.NotificationPriority
    status: $Enums.NotificationStatus
    provider_id: string | null
    error_message: string | null
    metadata: JsonValue | null
    message_id: string
    sent_at: Date | null
    delivered_at: Date | null
    read_at: Date | null
    created_at: Date
    updated_at: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    target_user_id?: boolean
    channel?: boolean
    template_id?: boolean
    payload?: boolean
    priority?: boolean
    status?: boolean
    provider_id?: boolean
    error_message?: boolean
    metadata?: boolean
    message_id?: boolean
    sent_at?: boolean
    delivered_at?: boolean
    read_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | NotificationTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    target_user_id?: boolean
    channel?: boolean
    template_id?: boolean
    payload?: boolean
    priority?: boolean
    status?: boolean
    provider_id?: boolean
    error_message?: boolean
    metadata?: boolean
    message_id?: boolean
    sent_at?: boolean
    delivered_at?: boolean
    read_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | NotificationTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    target_user_id?: boolean
    channel?: boolean
    template_id?: boolean
    payload?: boolean
    priority?: boolean
    status?: boolean
    provider_id?: boolean
    error_message?: boolean
    metadata?: boolean
    message_id?: boolean
    sent_at?: boolean
    delivered_at?: boolean
    read_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | NotificationTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    target_user_id?: boolean
    channel?: boolean
    template_id?: boolean
    payload?: boolean
    priority?: boolean
    status?: boolean
    provider_id?: boolean
    error_message?: boolean
    metadata?: boolean
    message_id?: boolean
    sent_at?: boolean
    delivered_at?: boolean
    read_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "target_user_id" | "channel" | "template_id" | "payload" | "priority" | "status" | "provider_id" | "error_message" | "metadata" | "message_id" | "sent_at" | "delivered_at" | "read_at" | "created_at" | "updated_at", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | NotificationTemplateDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | NotificationTemplateDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | NotificationTemplateDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      template: Prisma.$NotificationTemplatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      target_user_id: string
      channel: $Enums.NotificationChannel
      template_id: string
      payload: Prisma.JsonValue
      priority: $Enums.NotificationPriority
      status: $Enums.NotificationStatus
      provider_id: string | null
      error_message: string | null
      metadata: Prisma.JsonValue | null
      message_id: string
      sent_at: Date | null
      delivered_at: Date | null
      read_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends NotificationTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationTemplateDefaultArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly target_user_id: FieldRef<"Notification", 'String'>
    readonly channel: FieldRef<"Notification", 'NotificationChannel'>
    readonly template_id: FieldRef<"Notification", 'String'>
    readonly payload: FieldRef<"Notification", 'Json'>
    readonly priority: FieldRef<"Notification", 'NotificationPriority'>
    readonly status: FieldRef<"Notification", 'NotificationStatus'>
    readonly provider_id: FieldRef<"Notification", 'String'>
    readonly error_message: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly message_id: FieldRef<"Notification", 'String'>
    readonly sent_at: FieldRef<"Notification", 'DateTime'>
    readonly delivered_at: FieldRef<"Notification", 'DateTime'>
    readonly read_at: FieldRef<"Notification", 'DateTime'>
    readonly created_at: FieldRef<"Notification", 'DateTime'>
    readonly updated_at: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationTemplate
   */

  export type AggregateNotificationTemplate = {
    _count: NotificationTemplateCountAggregateOutputType | null
    _avg: NotificationTemplateAvgAggregateOutputType | null
    _sum: NotificationTemplateSumAggregateOutputType | null
    _min: NotificationTemplateMinAggregateOutputType | null
    _max: NotificationTemplateMaxAggregateOutputType | null
  }

  export type NotificationTemplateAvgAggregateOutputType = {
    version: number | null
  }

  export type NotificationTemplateSumAggregateOutputType = {
    version: number | null
  }

  export type NotificationTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    channel: $Enums.NotificationTemplateChannel | null
    subject: string | null
    body_template: string | null
    title_template: string | null
    version: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type NotificationTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    channel: $Enums.NotificationTemplateChannel | null
    subject: string | null
    body_template: string | null
    title_template: string | null
    version: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type NotificationTemplateCountAggregateOutputType = {
    id: number
    name: number
    channel: number
    subject: number
    body_template: number
    title_template: number
    variables: number
    version: number
    is_active: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type NotificationTemplateAvgAggregateInputType = {
    version?: true
  }

  export type NotificationTemplateSumAggregateInputType = {
    version?: true
  }

  export type NotificationTemplateMinAggregateInputType = {
    id?: true
    name?: true
    channel?: true
    subject?: true
    body_template?: true
    title_template?: true
    version?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type NotificationTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    channel?: true
    subject?: true
    body_template?: true
    title_template?: true
    version?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type NotificationTemplateCountAggregateInputType = {
    id?: true
    name?: true
    channel?: true
    subject?: true
    body_template?: true
    title_template?: true
    variables?: true
    version?: true
    is_active?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type NotificationTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationTemplate to aggregate.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationTemplates
    **/
    _count?: true | NotificationTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationTemplateMaxAggregateInputType
  }

  export type GetNotificationTemplateAggregateType<T extends NotificationTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationTemplate[P]>
      : GetScalarType<T[P], AggregateNotificationTemplate[P]>
  }




  export type NotificationTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationTemplateWhereInput
    orderBy?: NotificationTemplateOrderByWithAggregationInput | NotificationTemplateOrderByWithAggregationInput[]
    by: NotificationTemplateScalarFieldEnum[] | NotificationTemplateScalarFieldEnum
    having?: NotificationTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationTemplateCountAggregateInputType | true
    _avg?: NotificationTemplateAvgAggregateInputType
    _sum?: NotificationTemplateSumAggregateInputType
    _min?: NotificationTemplateMinAggregateInputType
    _max?: NotificationTemplateMaxAggregateInputType
  }

  export type NotificationTemplateGroupByOutputType = {
    id: string
    name: string
    channel: $Enums.NotificationTemplateChannel
    subject: string | null
    body_template: string
    title_template: string | null
    variables: string[]
    version: number
    is_active: boolean
    metadata: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: NotificationTemplateCountAggregateOutputType | null
    _avg: NotificationTemplateAvgAggregateOutputType | null
    _sum: NotificationTemplateSumAggregateOutputType | null
    _min: NotificationTemplateMinAggregateOutputType | null
    _max: NotificationTemplateMaxAggregateOutputType | null
  }

  type GetNotificationTemplateGroupByPayload<T extends NotificationTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationTemplateGroupByOutputType[P]>
        }
      >
    >


  export type NotificationTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    channel?: boolean
    subject?: boolean
    body_template?: boolean
    title_template?: boolean
    variables?: boolean
    version?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    notifications?: boolean | NotificationTemplate$notificationsArgs<ExtArgs>
    _count?: boolean | NotificationTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationTemplate"]>

  export type NotificationTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    channel?: boolean
    subject?: boolean
    body_template?: boolean
    title_template?: boolean
    variables?: boolean
    version?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["notificationTemplate"]>

  export type NotificationTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    channel?: boolean
    subject?: boolean
    body_template?: boolean
    title_template?: boolean
    variables?: boolean
    version?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["notificationTemplate"]>

  export type NotificationTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    channel?: boolean
    subject?: boolean
    body_template?: boolean
    title_template?: boolean
    variables?: boolean
    version?: boolean
    is_active?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type NotificationTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "channel" | "subject" | "body_template" | "title_template" | "variables" | "version" | "is_active" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["notificationTemplate"]>
  export type NotificationTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | NotificationTemplate$notificationsArgs<ExtArgs>
    _count?: boolean | NotificationTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NotificationTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NotificationTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NotificationTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationTemplate"
    objects: {
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      channel: $Enums.NotificationTemplateChannel
      subject: string | null
      body_template: string
      title_template: string | null
      variables: string[]
      version: number
      is_active: boolean
      metadata: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["notificationTemplate"]>
    composites: {}
  }

  type NotificationTemplateGetPayload<S extends boolean | null | undefined | NotificationTemplateDefaultArgs> = $Result.GetResult<Prisma.$NotificationTemplatePayload, S>

  type NotificationTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationTemplateCountAggregateInputType | true
    }

  export interface NotificationTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationTemplate'], meta: { name: 'NotificationTemplate' } }
    /**
     * Find zero or one NotificationTemplate that matches the filter.
     * @param {NotificationTemplateFindUniqueArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationTemplateFindUniqueArgs>(args: SelectSubset<T, NotificationTemplateFindUniqueArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationTemplateFindUniqueOrThrowArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindFirstArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationTemplateFindFirstArgs>(args?: SelectSubset<T, NotificationTemplateFindFirstArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindFirstOrThrowArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationTemplates
     * const notificationTemplates = await prisma.notificationTemplate.findMany()
     * 
     * // Get first 10 NotificationTemplates
     * const notificationTemplates = await prisma.notificationTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationTemplateFindManyArgs>(args?: SelectSubset<T, NotificationTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationTemplate.
     * @param {NotificationTemplateCreateArgs} args - Arguments to create a NotificationTemplate.
     * @example
     * // Create one NotificationTemplate
     * const NotificationTemplate = await prisma.notificationTemplate.create({
     *   data: {
     *     // ... data to create a NotificationTemplate
     *   }
     * })
     * 
     */
    create<T extends NotificationTemplateCreateArgs>(args: SelectSubset<T, NotificationTemplateCreateArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationTemplates.
     * @param {NotificationTemplateCreateManyArgs} args - Arguments to create many NotificationTemplates.
     * @example
     * // Create many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationTemplateCreateManyArgs>(args?: SelectSubset<T, NotificationTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationTemplates and returns the data saved in the database.
     * @param {NotificationTemplateCreateManyAndReturnArgs} args - Arguments to create many NotificationTemplates.
     * @example
     * // Create many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationTemplates and only return the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationTemplate.
     * @param {NotificationTemplateDeleteArgs} args - Arguments to delete one NotificationTemplate.
     * @example
     * // Delete one NotificationTemplate
     * const NotificationTemplate = await prisma.notificationTemplate.delete({
     *   where: {
     *     // ... filter to delete one NotificationTemplate
     *   }
     * })
     * 
     */
    delete<T extends NotificationTemplateDeleteArgs>(args: SelectSubset<T, NotificationTemplateDeleteArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationTemplate.
     * @param {NotificationTemplateUpdateArgs} args - Arguments to update one NotificationTemplate.
     * @example
     * // Update one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationTemplateUpdateArgs>(args: SelectSubset<T, NotificationTemplateUpdateArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationTemplates.
     * @param {NotificationTemplateDeleteManyArgs} args - Arguments to filter NotificationTemplates to delete.
     * @example
     * // Delete a few NotificationTemplates
     * const { count } = await prisma.notificationTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationTemplateDeleteManyArgs>(args?: SelectSubset<T, NotificationTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationTemplateUpdateManyArgs>(args: SelectSubset<T, NotificationTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationTemplates and returns the data updated in the database.
     * @param {NotificationTemplateUpdateManyAndReturnArgs} args - Arguments to update many NotificationTemplates.
     * @example
     * // Update many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationTemplates and only return the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationTemplate.
     * @param {NotificationTemplateUpsertArgs} args - Arguments to update or create a NotificationTemplate.
     * @example
     * // Update or create a NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.upsert({
     *   create: {
     *     // ... data to create a NotificationTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationTemplate we want to update
     *   }
     * })
     */
    upsert<T extends NotificationTemplateUpsertArgs>(args: SelectSubset<T, NotificationTemplateUpsertArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateCountArgs} args - Arguments to filter NotificationTemplates to count.
     * @example
     * // Count the number of NotificationTemplates
     * const count = await prisma.notificationTemplate.count({
     *   where: {
     *     // ... the filter for the NotificationTemplates we want to count
     *   }
     * })
    **/
    count<T extends NotificationTemplateCountArgs>(
      args?: Subset<T, NotificationTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationTemplateAggregateArgs>(args: Subset<T, NotificationTemplateAggregateArgs>): Prisma.PrismaPromise<GetNotificationTemplateAggregateType<T>>

    /**
     * Group by NotificationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationTemplateGroupByArgs['orderBy'] }
        : { orderBy?: NotificationTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationTemplate model
   */
  readonly fields: NotificationTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notifications<T extends NotificationTemplate$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, NotificationTemplate$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationTemplate model
   */
  interface NotificationTemplateFieldRefs {
    readonly id: FieldRef<"NotificationTemplate", 'String'>
    readonly name: FieldRef<"NotificationTemplate", 'String'>
    readonly channel: FieldRef<"NotificationTemplate", 'NotificationTemplateChannel'>
    readonly subject: FieldRef<"NotificationTemplate", 'String'>
    readonly body_template: FieldRef<"NotificationTemplate", 'String'>
    readonly title_template: FieldRef<"NotificationTemplate", 'String'>
    readonly variables: FieldRef<"NotificationTemplate", 'String[]'>
    readonly version: FieldRef<"NotificationTemplate", 'Int'>
    readonly is_active: FieldRef<"NotificationTemplate", 'Boolean'>
    readonly metadata: FieldRef<"NotificationTemplate", 'Json'>
    readonly created_at: FieldRef<"NotificationTemplate", 'DateTime'>
    readonly updated_at: FieldRef<"NotificationTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationTemplate findUnique
   */
  export type NotificationTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate findUniqueOrThrow
   */
  export type NotificationTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate findFirst
   */
  export type NotificationTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationTemplates.
     */
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate findFirstOrThrow
   */
  export type NotificationTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationTemplates.
     */
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate findMany
   */
  export type NotificationTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplates to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate create
   */
  export type NotificationTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationTemplate.
     */
    data: XOR<NotificationTemplateCreateInput, NotificationTemplateUncheckedCreateInput>
  }

  /**
   * NotificationTemplate createMany
   */
  export type NotificationTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationTemplates.
     */
    data: NotificationTemplateCreateManyInput | NotificationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationTemplate createManyAndReturn
   */
  export type NotificationTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationTemplates.
     */
    data: NotificationTemplateCreateManyInput | NotificationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationTemplate update
   */
  export type NotificationTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationTemplate.
     */
    data: XOR<NotificationTemplateUpdateInput, NotificationTemplateUncheckedUpdateInput>
    /**
     * Choose, which NotificationTemplate to update.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate updateMany
   */
  export type NotificationTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationTemplates.
     */
    data: XOR<NotificationTemplateUpdateManyMutationInput, NotificationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which NotificationTemplates to update
     */
    where?: NotificationTemplateWhereInput
    /**
     * Limit how many NotificationTemplates to update.
     */
    limit?: number
  }

  /**
   * NotificationTemplate updateManyAndReturn
   */
  export type NotificationTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * The data used to update NotificationTemplates.
     */
    data: XOR<NotificationTemplateUpdateManyMutationInput, NotificationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which NotificationTemplates to update
     */
    where?: NotificationTemplateWhereInput
    /**
     * Limit how many NotificationTemplates to update.
     */
    limit?: number
  }

  /**
   * NotificationTemplate upsert
   */
  export type NotificationTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationTemplate to update in case it exists.
     */
    where: NotificationTemplateWhereUniqueInput
    /**
     * In case the NotificationTemplate found by the `where` argument doesn't exist, create a new NotificationTemplate with this data.
     */
    create: XOR<NotificationTemplateCreateInput, NotificationTemplateUncheckedCreateInput>
    /**
     * In case the NotificationTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationTemplateUpdateInput, NotificationTemplateUncheckedUpdateInput>
  }

  /**
   * NotificationTemplate delete
   */
  export type NotificationTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter which NotificationTemplate to delete.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate deleteMany
   */
  export type NotificationTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationTemplates to delete
     */
    where?: NotificationTemplateWhereInput
    /**
     * Limit how many NotificationTemplates to delete.
     */
    limit?: number
  }

  /**
   * NotificationTemplate.notifications
   */
  export type NotificationTemplate$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * NotificationTemplate without action
   */
  export type NotificationTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
  }


  /**
   * Model NotificationPreference
   */

  export type AggregateNotificationPreference = {
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  export type NotificationPreferenceMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    category: $Enums.NotificationPreferenceCategory | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type NotificationPreferenceMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    category: $Enums.NotificationPreferenceCategory | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type NotificationPreferenceCountAggregateOutputType = {
    id: number
    user_id: number
    category: number
    channels: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type NotificationPreferenceMinAggregateInputType = {
    id?: true
    user_id?: true
    category?: true
    created_at?: true
    updated_at?: true
  }

  export type NotificationPreferenceMaxAggregateInputType = {
    id?: true
    user_id?: true
    category?: true
    created_at?: true
    updated_at?: true
  }

  export type NotificationPreferenceCountAggregateInputType = {
    id?: true
    user_id?: true
    category?: true
    channels?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type NotificationPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreference to aggregate.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationPreferences
    **/
    _count?: true | NotificationPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type GetNotificationPreferenceAggregateType<T extends NotificationPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationPreference[P]>
      : GetScalarType<T[P], AggregateNotificationPreference[P]>
  }




  export type NotificationPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationPreferenceWhereInput
    orderBy?: NotificationPreferenceOrderByWithAggregationInput | NotificationPreferenceOrderByWithAggregationInput[]
    by: NotificationPreferenceScalarFieldEnum[] | NotificationPreferenceScalarFieldEnum
    having?: NotificationPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationPreferenceCountAggregateInputType | true
    _min?: NotificationPreferenceMinAggregateInputType
    _max?: NotificationPreferenceMaxAggregateInputType
  }

  export type NotificationPreferenceGroupByOutputType = {
    id: string
    user_id: string
    category: $Enums.NotificationPreferenceCategory
    channels: JsonValue
    metadata: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: NotificationPreferenceCountAggregateOutputType | null
    _min: NotificationPreferenceMinAggregateOutputType | null
    _max: NotificationPreferenceMaxAggregateOutputType | null
  }

  type GetNotificationPreferenceGroupByPayload<T extends NotificationPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type NotificationPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    category?: boolean
    channels?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    category?: boolean
    channels?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    category?: boolean
    channels?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationPreference"]>

  export type NotificationPreferenceSelectScalar = {
    id?: boolean
    user_id?: boolean
    category?: boolean
    channels?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type NotificationPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "category" | "channels" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["notificationPreference"]>
  export type NotificationPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      category: $Enums.NotificationPreferenceCategory
      channels: Prisma.JsonValue
      metadata: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["notificationPreference"]>
    composites: {}
  }

  type NotificationPreferenceGetPayload<S extends boolean | null | undefined | NotificationPreferenceDefaultArgs> = $Result.GetResult<Prisma.$NotificationPreferencePayload, S>

  type NotificationPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationPreferenceCountAggregateInputType | true
    }

  export interface NotificationPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationPreference'], meta: { name: 'NotificationPreference' } }
    /**
     * Find zero or one NotificationPreference that matches the filter.
     * @param {NotificationPreferenceFindUniqueArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationPreferenceFindUniqueArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationPreferenceFindUniqueOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationPreferenceFindFirstArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindFirstOrThrowArgs} args - Arguments to find a NotificationPreference
     * @example
     * // Get one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany()
     * 
     * // Get first 10 NotificationPreferences
     * const notificationPreferences = await prisma.notificationPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationPreferenceFindManyArgs>(args?: SelectSubset<T, NotificationPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationPreference.
     * @param {NotificationPreferenceCreateArgs} args - Arguments to create a NotificationPreference.
     * @example
     * // Create one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.create({
     *   data: {
     *     // ... data to create a NotificationPreference
     *   }
     * })
     * 
     */
    create<T extends NotificationPreferenceCreateArgs>(args: SelectSubset<T, NotificationPreferenceCreateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationPreferences.
     * @param {NotificationPreferenceCreateManyArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationPreferenceCreateManyArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationPreferences and returns the data saved in the database.
     * @param {NotificationPreferenceCreateManyAndReturnArgs} args - Arguments to create many NotificationPreferences.
     * @example
     * // Create many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationPreference.
     * @param {NotificationPreferenceDeleteArgs} args - Arguments to delete one NotificationPreference.
     * @example
     * // Delete one NotificationPreference
     * const NotificationPreference = await prisma.notificationPreference.delete({
     *   where: {
     *     // ... filter to delete one NotificationPreference
     *   }
     * })
     * 
     */
    delete<T extends NotificationPreferenceDeleteArgs>(args: SelectSubset<T, NotificationPreferenceDeleteArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationPreference.
     * @param {NotificationPreferenceUpdateArgs} args - Arguments to update one NotificationPreference.
     * @example
     * // Update one NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationPreferenceUpdateArgs>(args: SelectSubset<T, NotificationPreferenceUpdateArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationPreferences.
     * @param {NotificationPreferenceDeleteManyArgs} args - Arguments to filter NotificationPreferences to delete.
     * @example
     * // Delete a few NotificationPreferences
     * const { count } = await prisma.notificationPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationPreferenceDeleteManyArgs>(args?: SelectSubset<T, NotificationPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationPreferenceUpdateManyArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationPreferences and returns the data updated in the database.
     * @param {NotificationPreferenceUpdateManyAndReturnArgs} args - Arguments to update many NotificationPreferences.
     * @example
     * // Update many NotificationPreferences
     * const notificationPreference = await prisma.notificationPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationPreferences and only return the `id`
     * const notificationPreferenceWithIdOnly = await prisma.notificationPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationPreference.
     * @param {NotificationPreferenceUpsertArgs} args - Arguments to update or create a NotificationPreference.
     * @example
     * // Update or create a NotificationPreference
     * const notificationPreference = await prisma.notificationPreference.upsert({
     *   create: {
     *     // ... data to create a NotificationPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationPreference we want to update
     *   }
     * })
     */
    upsert<T extends NotificationPreferenceUpsertArgs>(args: SelectSubset<T, NotificationPreferenceUpsertArgs<ExtArgs>>): Prisma__NotificationPreferenceClient<$Result.GetResult<Prisma.$NotificationPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceCountArgs} args - Arguments to filter NotificationPreferences to count.
     * @example
     * // Count the number of NotificationPreferences
     * const count = await prisma.notificationPreference.count({
     *   where: {
     *     // ... the filter for the NotificationPreferences we want to count
     *   }
     * })
    **/
    count<T extends NotificationPreferenceCountArgs>(
      args?: Subset<T, NotificationPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationPreferenceAggregateArgs>(args: Subset<T, NotificationPreferenceAggregateArgs>): Prisma.PrismaPromise<GetNotificationPreferenceAggregateType<T>>

    /**
     * Group by NotificationPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: NotificationPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationPreference model
   */
  readonly fields: NotificationPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationPreference model
   */
  interface NotificationPreferenceFieldRefs {
    readonly id: FieldRef<"NotificationPreference", 'String'>
    readonly user_id: FieldRef<"NotificationPreference", 'String'>
    readonly category: FieldRef<"NotificationPreference", 'NotificationPreferenceCategory'>
    readonly channels: FieldRef<"NotificationPreference", 'Json'>
    readonly metadata: FieldRef<"NotificationPreference", 'Json'>
    readonly created_at: FieldRef<"NotificationPreference", 'DateTime'>
    readonly updated_at: FieldRef<"NotificationPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationPreference findUnique
   */
  export type NotificationPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findUniqueOrThrow
   */
  export type NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference findFirst
   */
  export type NotificationPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findFirstOrThrow
   */
  export type NotificationPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreference to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationPreferences.
     */
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference findMany
   */
  export type NotificationPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which NotificationPreferences to fetch.
     */
    where?: NotificationPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationPreferences to fetch.
     */
    orderBy?: NotificationPreferenceOrderByWithRelationInput | NotificationPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationPreferences.
     */
    cursor?: NotificationPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationPreferences.
     */
    skip?: number
    distinct?: NotificationPreferenceScalarFieldEnum | NotificationPreferenceScalarFieldEnum[]
  }

  /**
   * NotificationPreference create
   */
  export type NotificationPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationPreference.
     */
    data: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
  }

  /**
   * NotificationPreference createMany
   */
  export type NotificationPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationPreference createManyAndReturn
   */
  export type NotificationPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationPreferences.
     */
    data: NotificationPreferenceCreateManyInput | NotificationPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference update
   */
  export type NotificationPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationPreference.
     */
    data: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
    /**
     * Choose, which NotificationPreference to update.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference updateMany
   */
  export type NotificationPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
  }

  /**
   * NotificationPreference updateManyAndReturn
   */
  export type NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update NotificationPreferences.
     */
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which NotificationPreferences to update
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationPreference upsert
   */
  export type NotificationPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationPreference to update in case it exists.
     */
    where: NotificationPreferenceWhereUniqueInput
    /**
     * In case the NotificationPreference found by the `where` argument doesn't exist, create a new NotificationPreference with this data.
     */
    create: XOR<NotificationPreferenceCreateInput, NotificationPreferenceUncheckedCreateInput>
    /**
     * In case the NotificationPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationPreferenceUpdateInput, NotificationPreferenceUncheckedUpdateInput>
  }

  /**
   * NotificationPreference delete
   */
  export type NotificationPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
    /**
     * Filter which NotificationPreference to delete.
     */
    where: NotificationPreferenceWhereUniqueInput
  }

  /**
   * NotificationPreference deleteMany
   */
  export type NotificationPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationPreferences to delete
     */
    where?: NotificationPreferenceWhereInput
    /**
     * Limit how many NotificationPreferences to delete.
     */
    limit?: number
  }

  /**
   * NotificationPreference without action
   */
  export type NotificationPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationPreference
     */
    select?: NotificationPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationPreference
     */
    omit?: NotificationPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationPreferenceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    provider_id: 'provider_id',
    photo_url: 'photo_url',
    onboarding_completed: 'onboarding_completed',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    owner_id: 'owner_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    organization_id: 'organization_id',
    name: 'name',
    brand_color: 'brand_color',
    logo: 'logo',
    gallery: 'gallery',
    is_active: 'is_active',
    whatsapp: 'whatsapp',
    phone: 'phone',
    address: 'address',
    especialidades: 'especialidades',
    services: 'services',
    service_type: 'service_type',
    amenities: 'amenities',
    subscription: 'subscription',
    working_hours: 'working_hours',
    lunch_break: 'lunch_break',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const SpecialtyScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    icon: 'icon',
    is_predefined: 'is_predefined',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SpecialtyScalarFieldEnum = (typeof SpecialtyScalarFieldEnum)[keyof typeof SpecialtyScalarFieldEnum]


  export const AmenityScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    icon: 'icon',
    is_predefined: 'is_predefined',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AmenityScalarFieldEnum = (typeof AmenityScalarFieldEnum)[keyof typeof AmenityScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    specialty_id: 'specialty_id',
    code: 'code',
    name: 'name',
    description: 'description',
    default_duration_minutes: 'default_duration_minutes',
    default_price_cents: 'default_price_cents',
    is_predefined: 'is_predefined',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const UnitSpecialtyScalarFieldEnum: {
    id: 'id',
    unit_id: 'unit_id',
    specialty_id: 'specialty_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UnitSpecialtyScalarFieldEnum = (typeof UnitSpecialtyScalarFieldEnum)[keyof typeof UnitSpecialtyScalarFieldEnum]


  export const UnitAmenityScalarFieldEnum: {
    id: 'id',
    unit_id: 'unit_id',
    amenity_id: 'amenity_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UnitAmenityScalarFieldEnum = (typeof UnitAmenityScalarFieldEnum)[keyof typeof UnitAmenityScalarFieldEnum]


  export const UnitServiceScalarFieldEnum: {
    id: 'id',
    unit_id: 'unit_id',
    service_id: 'service_id',
    custom_price_cents: 'custom_price_cents',
    custom_duration_minutes: 'custom_duration_minutes',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UnitServiceScalarFieldEnum = (typeof UnitServiceScalarFieldEnum)[keyof typeof UnitServiceScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    client_id: 'client_id',
    unit_id: 'unit_id',
    service_id: 'service_id',
    price_cents: 'price_cents',
    notes: 'notes',
    start_at: 'start_at',
    end_at: 'end_at',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    unit_id: 'unit_id',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const BookingRuleScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    type: 'type',
    weekday: 'weekday',
    date: 'date',
    start_time: 'start_time',
    end_time: 'end_time',
    slot_duration_minutes: 'slot_duration_minutes',
    min_advance_minutes: 'min_advance_minutes',
    max_duration_minutes: 'max_duration_minutes',
    max_bookings_per_day: 'max_bookings_per_day',
    max_bookings_per_client_per_day: 'max_bookings_per_client_per_day',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BookingRuleScalarFieldEnum = (typeof BookingRuleScalarFieldEnum)[keyof typeof BookingRuleScalarFieldEnum]


  export const BookingExceptionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    date: 'date',
    type: 'type',
    start_time: 'start_time',
    end_time: 'end_time',
    slot_duration_minutes: 'slot_duration_minutes',
    reason: 'reason',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BookingExceptionScalarFieldEnum = (typeof BookingExceptionScalarFieldEnum)[keyof typeof BookingExceptionScalarFieldEnum]


  export const UnitAvailabilityRuleScalarFieldEnum: {
    id: 'id',
    unit_id: 'unit_id',
    type: 'type',
    weekday: 'weekday',
    date: 'date',
    start_time: 'start_time',
    end_time: 'end_time',
    slot_duration_minutes: 'slot_duration_minutes',
    is_active: 'is_active',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UnitAvailabilityRuleScalarFieldEnum = (typeof UnitAvailabilityRuleScalarFieldEnum)[keyof typeof UnitAvailabilityRuleScalarFieldEnum]


  export const UnitAvailabilityExceptionScalarFieldEnum: {
    id: 'id',
    unit_id: 'unit_id',
    date: 'date',
    type: 'type',
    start_time: 'start_time',
    end_time: 'end_time',
    slot_duration_minutes: 'slot_duration_minutes',
    reason: 'reason',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UnitAvailabilityExceptionScalarFieldEnum = (typeof UnitAvailabilityExceptionScalarFieldEnum)[keyof typeof UnitAvailabilityExceptionScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    currency: 'currency',
    interval: 'interval',
    features: 'features',
    limits: 'limits',
    trial_days: 'trial_days',
    is_active: 'is_active',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    unit_id: 'unit_id',
    user_id: 'user_id',
    plan_id: 'plan_id',
    status: 'status',
    start_date: 'start_date',
    current_period_start: 'current_period_start',
    current_period_end: 'current_period_end',
    cancel_at_period_end: 'cancel_at_period_end',
    canceled_at: 'canceled_at',
    trial_end: 'trial_end',
    renewal_interval: 'renewal_interval',
    discount_id: 'discount_id',
    provider_subscription_id: 'provider_subscription_id',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    subscription_id: 'subscription_id',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    line_items: 'line_items',
    due_date: 'due_date',
    paid_at: 'paid_at',
    provider_invoice_id: 'provider_invoice_id',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const DiscountScalarFieldEnum: {
    id: 'id',
    code: 'code',
    type: 'type',
    value: 'value',
    duration: 'duration',
    repeating_count: 'repeating_count',
    assigned_to_user_id: 'assigned_to_user_id',
    max_redemptions: 'max_redemptions',
    redemptions_count: 'redemptions_count',
    expires_at: 'expires_at',
    is_active: 'is_active',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DiscountScalarFieldEnum = (typeof DiscountScalarFieldEnum)[keyof typeof DiscountScalarFieldEnum]


  export const CouponRedemptionScalarFieldEnum: {
    id: 'id',
    coupon_id: 'coupon_id',
    user_id: 'user_id',
    subscription_id: 'subscription_id',
    redeemed_at: 'redeemed_at',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CouponRedemptionScalarFieldEnum = (typeof CouponRedemptionScalarFieldEnum)[keyof typeof CouponRedemptionScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    target_user_id: 'target_user_id',
    channel: 'channel',
    template_id: 'template_id',
    payload: 'payload',
    priority: 'priority',
    status: 'status',
    provider_id: 'provider_id',
    error_message: 'error_message',
    metadata: 'metadata',
    message_id: 'message_id',
    sent_at: 'sent_at',
    delivered_at: 'delivered_at',
    read_at: 'read_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    channel: 'channel',
    subject: 'subject',
    body_template: 'body_template',
    title_template: 'title_template',
    variables: 'variables',
    version: 'version',
    is_active: 'is_active',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type NotificationTemplateScalarFieldEnum = (typeof NotificationTemplateScalarFieldEnum)[keyof typeof NotificationTemplateScalarFieldEnum]


  export const NotificationPreferenceScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    category: 'category',
    channels: 'channels',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ServiceType'
   */
  export type EnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType'>
    


  /**
   * Reference to a field of type 'ServiceType[]'
   */
  export type ListEnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'BookingRuleType'
   */
  export type EnumBookingRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingRuleType'>
    


  /**
   * Reference to a field of type 'BookingRuleType[]'
   */
  export type ListEnumBookingRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingRuleType[]'>
    


  /**
   * Reference to a field of type 'BookingExceptionType'
   */
  export type EnumBookingExceptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingExceptionType'>
    


  /**
   * Reference to a field of type 'BookingExceptionType[]'
   */
  export type ListEnumBookingExceptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingExceptionType[]'>
    


  /**
   * Reference to a field of type 'UnitAvailabilityRuleType'
   */
  export type EnumUnitAvailabilityRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitAvailabilityRuleType'>
    


  /**
   * Reference to a field of type 'UnitAvailabilityRuleType[]'
   */
  export type ListEnumUnitAvailabilityRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitAvailabilityRuleType[]'>
    


  /**
   * Reference to a field of type 'UnitAvailabilityExceptionType'
   */
  export type EnumUnitAvailabilityExceptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitAvailabilityExceptionType'>
    


  /**
   * Reference to a field of type 'UnitAvailabilityExceptionType[]'
   */
  export type ListEnumUnitAvailabilityExceptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitAvailabilityExceptionType[]'>
    


  /**
   * Reference to a field of type 'RenewalInterval'
   */
  export type EnumRenewalIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RenewalInterval'>
    


  /**
   * Reference to a field of type 'RenewalInterval[]'
   */
  export type ListEnumRenewalIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RenewalInterval[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'DiscountType[]'
   */
  export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


  /**
   * Reference to a field of type 'DiscountDuration'
   */
  export type EnumDiscountDurationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountDuration'>
    


  /**
   * Reference to a field of type 'DiscountDuration[]'
   */
  export type ListEnumDiscountDurationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountDuration[]'>
    


  /**
   * Reference to a field of type 'NotificationChannel'
   */
  export type EnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel'>
    


  /**
   * Reference to a field of type 'NotificationChannel[]'
   */
  export type ListEnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel[]'>
    


  /**
   * Reference to a field of type 'NotificationPriority'
   */
  export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority'>
    


  /**
   * Reference to a field of type 'NotificationPriority[]'
   */
  export type ListEnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationTemplateChannel'
   */
  export type EnumNotificationTemplateChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationTemplateChannel'>
    


  /**
   * Reference to a field of type 'NotificationTemplateChannel[]'
   */
  export type ListEnumNotificationTemplateChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationTemplateChannel[]'>
    


  /**
   * Reference to a field of type 'NotificationPreferenceCategory'
   */
  export type EnumNotificationPreferenceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPreferenceCategory'>
    


  /**
   * Reference to a field of type 'NotificationPreferenceCategory[]'
   */
  export type ListEnumNotificationPreferenceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPreferenceCategory[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    provider_id?: StringFilter<"User"> | string
    photo_url?: StringNullableFilter<"User"> | string | null
    onboarding_completed?: BoolFilter<"User"> | boolean
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    bookings_as_owner?: BookingListRelationFilter
    bookings_as_client?: BookingListRelationFilter
    booking_rules?: BookingRuleListRelationFilter
    booking_exceptions?: BookingExceptionListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    invoices?: InvoiceListRelationFilter
    coupon_redemptions?: CouponRedemptionListRelationFilter
    notifications?: NotificationListRelationFilter
    notification_prefs?: NotificationPreferenceListRelationFilter
    customer_profiles?: CustomerListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    provider_id?: SortOrder
    photo_url?: SortOrderInput | SortOrder
    onboarding_completed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    bookings_as_owner?: BookingOrderByRelationAggregateInput
    bookings_as_client?: BookingOrderByRelationAggregateInput
    booking_rules?: BookingRuleOrderByRelationAggregateInput
    booking_exceptions?: BookingExceptionOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    coupon_redemptions?: CouponRedemptionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    notification_prefs?: NotificationPreferenceOrderByRelationAggregateInput
    customer_profiles?: CustomerOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    provider_id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    photo_url?: StringNullableFilter<"User"> | string | null
    onboarding_completed?: BoolFilter<"User"> | boolean
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    bookings_as_owner?: BookingListRelationFilter
    bookings_as_client?: BookingListRelationFilter
    booking_rules?: BookingRuleListRelationFilter
    booking_exceptions?: BookingExceptionListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    invoices?: InvoiceListRelationFilter
    coupon_redemptions?: CouponRedemptionListRelationFilter
    notifications?: NotificationListRelationFilter
    notification_prefs?: NotificationPreferenceListRelationFilter
    customer_profiles?: CustomerListRelationFilter
  }, "id" | "email" | "provider_id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    provider_id?: SortOrder
    photo_url?: SortOrderInput | SortOrder
    onboarding_completed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    provider_id?: StringWithAggregatesFilter<"User"> | string
    photo_url?: StringNullableWithAggregatesFilter<"User"> | string | null
    onboarding_completed?: BoolWithAggregatesFilter<"User"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    owner_id?: StringFilter<"Organization"> | string
    created_at?: DateTimeFilter<"Organization"> | Date | string
    updated_at?: DateTimeFilter<"Organization"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    units?: UnitListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    owner_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    owner?: UserOrderByWithRelationInput
    units?: UnitOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    owner_id?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    created_at?: DateTimeFilter<"Organization"> | Date | string
    updated_at?: DateTimeFilter<"Organization"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    units?: UnitListRelationFilter
  }, "id" | "owner_id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    owner_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    owner_id?: StringWithAggregatesFilter<"Organization"> | string
    created_at?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: StringFilter<"Unit"> | string
    organization_id?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    brand_color?: StringFilter<"Unit"> | string
    logo?: StringNullableFilter<"Unit"> | string | null
    gallery?: StringNullableListFilter<"Unit">
    is_active?: BoolFilter<"Unit"> | boolean
    whatsapp?: StringFilter<"Unit"> | string
    phone?: StringNullableFilter<"Unit"> | string | null
    address?: JsonFilter<"Unit">
    especialidades?: JsonFilter<"Unit">
    services?: JsonFilter<"Unit">
    service_type?: EnumServiceTypeFilter<"Unit"> | $Enums.ServiceType
    amenities?: StringNullableListFilter<"Unit">
    subscription?: JsonNullableFilter<"Unit">
    working_hours?: JsonNullableFilter<"Unit">
    lunch_break?: JsonNullableFilter<"Unit">
    created_at?: DateTimeFilter<"Unit"> | Date | string
    updated_at?: DateTimeFilter<"Unit"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    unit_specialties?: UnitSpecialtyListRelationFilter
    unit_services?: UnitServiceListRelationFilter
    unit_amenities?: UnitAmenityListRelationFilter
    unit_availability_rules?: UnitAvailabilityRuleListRelationFilter
    unit_availability_exceptions?: UnitAvailabilityExceptionListRelationFilter
    subscription_record?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    bookings?: BookingListRelationFilter
    customers?: CustomerListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    brand_color?: SortOrder
    logo?: SortOrderInput | SortOrder
    gallery?: SortOrder
    is_active?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrder
    especialidades?: SortOrder
    services?: SortOrder
    service_type?: SortOrder
    amenities?: SortOrder
    subscription?: SortOrderInput | SortOrder
    working_hours?: SortOrderInput | SortOrder
    lunch_break?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    unit_specialties?: UnitSpecialtyOrderByRelationAggregateInput
    unit_services?: UnitServiceOrderByRelationAggregateInput
    unit_amenities?: UnitAmenityOrderByRelationAggregateInput
    unit_availability_rules?: UnitAvailabilityRuleOrderByRelationAggregateInput
    unit_availability_exceptions?: UnitAvailabilityExceptionOrderByRelationAggregateInput
    subscription_record?: SubscriptionOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    organization_id?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    brand_color?: StringFilter<"Unit"> | string
    logo?: StringNullableFilter<"Unit"> | string | null
    gallery?: StringNullableListFilter<"Unit">
    is_active?: BoolFilter<"Unit"> | boolean
    whatsapp?: StringFilter<"Unit"> | string
    phone?: StringNullableFilter<"Unit"> | string | null
    address?: JsonFilter<"Unit">
    especialidades?: JsonFilter<"Unit">
    services?: JsonFilter<"Unit">
    service_type?: EnumServiceTypeFilter<"Unit"> | $Enums.ServiceType
    amenities?: StringNullableListFilter<"Unit">
    subscription?: JsonNullableFilter<"Unit">
    working_hours?: JsonNullableFilter<"Unit">
    lunch_break?: JsonNullableFilter<"Unit">
    created_at?: DateTimeFilter<"Unit"> | Date | string
    updated_at?: DateTimeFilter<"Unit"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    unit_specialties?: UnitSpecialtyListRelationFilter
    unit_services?: UnitServiceListRelationFilter
    unit_amenities?: UnitAmenityListRelationFilter
    unit_availability_rules?: UnitAvailabilityRuleListRelationFilter
    unit_availability_exceptions?: UnitAvailabilityExceptionListRelationFilter
    subscription_record?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    bookings?: BookingListRelationFilter
    customers?: CustomerListRelationFilter
  }, "id">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    brand_color?: SortOrder
    logo?: SortOrderInput | SortOrder
    gallery?: SortOrder
    is_active?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrder
    especialidades?: SortOrder
    services?: SortOrder
    service_type?: SortOrder
    amenities?: SortOrder
    subscription?: SortOrderInput | SortOrder
    working_hours?: SortOrderInput | SortOrder
    lunch_break?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Unit"> | string
    organization_id?: StringWithAggregatesFilter<"Unit"> | string
    name?: StringWithAggregatesFilter<"Unit"> | string
    brand_color?: StringWithAggregatesFilter<"Unit"> | string
    logo?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    gallery?: StringNullableListFilter<"Unit">
    is_active?: BoolWithAggregatesFilter<"Unit"> | boolean
    whatsapp?: StringWithAggregatesFilter<"Unit"> | string
    phone?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    address?: JsonWithAggregatesFilter<"Unit">
    especialidades?: JsonWithAggregatesFilter<"Unit">
    services?: JsonWithAggregatesFilter<"Unit">
    service_type?: EnumServiceTypeWithAggregatesFilter<"Unit"> | $Enums.ServiceType
    amenities?: StringNullableListFilter<"Unit">
    subscription?: JsonNullableWithAggregatesFilter<"Unit">
    working_hours?: JsonNullableWithAggregatesFilter<"Unit">
    lunch_break?: JsonNullableWithAggregatesFilter<"Unit">
    created_at?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
  }

  export type SpecialtyWhereInput = {
    AND?: SpecialtyWhereInput | SpecialtyWhereInput[]
    OR?: SpecialtyWhereInput[]
    NOT?: SpecialtyWhereInput | SpecialtyWhereInput[]
    id?: StringFilter<"Specialty"> | string
    code?: StringFilter<"Specialty"> | string
    name?: StringFilter<"Specialty"> | string
    description?: StringNullableFilter<"Specialty"> | string | null
    icon?: StringFilter<"Specialty"> | string
    is_predefined?: BoolFilter<"Specialty"> | boolean
    is_active?: BoolFilter<"Specialty"> | boolean
    created_at?: DateTimeFilter<"Specialty"> | Date | string
    updated_at?: DateTimeFilter<"Specialty"> | Date | string
    services?: ServiceListRelationFilter
    unit_specialties?: UnitSpecialtyListRelationFilter
  }

  export type SpecialtyOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
    unit_specialties?: UnitSpecialtyOrderByRelationAggregateInput
  }

  export type SpecialtyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: SpecialtyWhereInput | SpecialtyWhereInput[]
    OR?: SpecialtyWhereInput[]
    NOT?: SpecialtyWhereInput | SpecialtyWhereInput[]
    name?: StringFilter<"Specialty"> | string
    description?: StringNullableFilter<"Specialty"> | string | null
    icon?: StringFilter<"Specialty"> | string
    is_predefined?: BoolFilter<"Specialty"> | boolean
    is_active?: BoolFilter<"Specialty"> | boolean
    created_at?: DateTimeFilter<"Specialty"> | Date | string
    updated_at?: DateTimeFilter<"Specialty"> | Date | string
    services?: ServiceListRelationFilter
    unit_specialties?: UnitSpecialtyListRelationFilter
  }, "id" | "code">

  export type SpecialtyOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SpecialtyCountOrderByAggregateInput
    _max?: SpecialtyMaxOrderByAggregateInput
    _min?: SpecialtyMinOrderByAggregateInput
  }

  export type SpecialtyScalarWhereWithAggregatesInput = {
    AND?: SpecialtyScalarWhereWithAggregatesInput | SpecialtyScalarWhereWithAggregatesInput[]
    OR?: SpecialtyScalarWhereWithAggregatesInput[]
    NOT?: SpecialtyScalarWhereWithAggregatesInput | SpecialtyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Specialty"> | string
    code?: StringWithAggregatesFilter<"Specialty"> | string
    name?: StringWithAggregatesFilter<"Specialty"> | string
    description?: StringNullableWithAggregatesFilter<"Specialty"> | string | null
    icon?: StringWithAggregatesFilter<"Specialty"> | string
    is_predefined?: BoolWithAggregatesFilter<"Specialty"> | boolean
    is_active?: BoolWithAggregatesFilter<"Specialty"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Specialty"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Specialty"> | Date | string
  }

  export type AmenityWhereInput = {
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    id?: StringFilter<"Amenity"> | string
    code?: StringFilter<"Amenity"> | string
    name?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    icon?: StringFilter<"Amenity"> | string
    is_predefined?: BoolFilter<"Amenity"> | boolean
    is_active?: BoolFilter<"Amenity"> | boolean
    created_at?: DateTimeFilter<"Amenity"> | Date | string
    updated_at?: DateTimeFilter<"Amenity"> | Date | string
    unit_amenities?: UnitAmenityListRelationFilter
  }

  export type AmenityOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    unit_amenities?: UnitAmenityOrderByRelationAggregateInput
  }

  export type AmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    name?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    icon?: StringFilter<"Amenity"> | string
    is_predefined?: BoolFilter<"Amenity"> | boolean
    is_active?: BoolFilter<"Amenity"> | boolean
    created_at?: DateTimeFilter<"Amenity"> | Date | string
    updated_at?: DateTimeFilter<"Amenity"> | Date | string
    unit_amenities?: UnitAmenityListRelationFilter
  }, "id" | "code">

  export type AmenityOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AmenityCountOrderByAggregateInput
    _max?: AmenityMaxOrderByAggregateInput
    _min?: AmenityMinOrderByAggregateInput
  }

  export type AmenityScalarWhereWithAggregatesInput = {
    AND?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    OR?: AmenityScalarWhereWithAggregatesInput[]
    NOT?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Amenity"> | string
    code?: StringWithAggregatesFilter<"Amenity"> | string
    name?: StringWithAggregatesFilter<"Amenity"> | string
    description?: StringNullableWithAggregatesFilter<"Amenity"> | string | null
    icon?: StringWithAggregatesFilter<"Amenity"> | string
    is_predefined?: BoolWithAggregatesFilter<"Amenity"> | boolean
    is_active?: BoolWithAggregatesFilter<"Amenity"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Amenity"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Amenity"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    specialty_id?: StringFilter<"Service"> | string
    code?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    default_duration_minutes?: IntFilter<"Service"> | number
    default_price_cents?: IntFilter<"Service"> | number
    is_predefined?: BoolFilter<"Service"> | boolean
    is_active?: BoolFilter<"Service"> | boolean
    created_at?: DateTimeFilter<"Service"> | Date | string
    updated_at?: DateTimeFilter<"Service"> | Date | string
    specialty?: XOR<SpecialtyScalarRelationFilter, SpecialtyWhereInput>
    unit_services?: UnitServiceListRelationFilter
    bookings?: BookingListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    specialty_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    default_duration_minutes?: SortOrder
    default_price_cents?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    specialty?: SpecialtyOrderByWithRelationInput
    unit_services?: UnitServiceOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    specialty_id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    default_duration_minutes?: IntFilter<"Service"> | number
    default_price_cents?: IntFilter<"Service"> | number
    is_predefined?: BoolFilter<"Service"> | boolean
    is_active?: BoolFilter<"Service"> | boolean
    created_at?: DateTimeFilter<"Service"> | Date | string
    updated_at?: DateTimeFilter<"Service"> | Date | string
    specialty?: XOR<SpecialtyScalarRelationFilter, SpecialtyWhereInput>
    unit_services?: UnitServiceListRelationFilter
    bookings?: BookingListRelationFilter
  }, "id" | "code">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    specialty_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    default_duration_minutes?: SortOrder
    default_price_cents?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    specialty_id?: StringWithAggregatesFilter<"Service"> | string
    code?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    default_duration_minutes?: IntWithAggregatesFilter<"Service"> | number
    default_price_cents?: IntWithAggregatesFilter<"Service"> | number
    is_predefined?: BoolWithAggregatesFilter<"Service"> | boolean
    is_active?: BoolWithAggregatesFilter<"Service"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type UnitSpecialtyWhereInput = {
    AND?: UnitSpecialtyWhereInput | UnitSpecialtyWhereInput[]
    OR?: UnitSpecialtyWhereInput[]
    NOT?: UnitSpecialtyWhereInput | UnitSpecialtyWhereInput[]
    id?: StringFilter<"UnitSpecialty"> | string
    unit_id?: StringFilter<"UnitSpecialty"> | string
    specialty_id?: StringFilter<"UnitSpecialty"> | string
    created_at?: DateTimeFilter<"UnitSpecialty"> | Date | string
    updated_at?: DateTimeFilter<"UnitSpecialty"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    specialty?: XOR<SpecialtyScalarRelationFilter, SpecialtyWhereInput>
  }

  export type UnitSpecialtyOrderByWithRelationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    specialty_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    unit?: UnitOrderByWithRelationInput
    specialty?: SpecialtyOrderByWithRelationInput
  }

  export type UnitSpecialtyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unit_id_specialty_id?: UnitSpecialtyUnit_idSpecialty_idCompoundUniqueInput
    AND?: UnitSpecialtyWhereInput | UnitSpecialtyWhereInput[]
    OR?: UnitSpecialtyWhereInput[]
    NOT?: UnitSpecialtyWhereInput | UnitSpecialtyWhereInput[]
    unit_id?: StringFilter<"UnitSpecialty"> | string
    specialty_id?: StringFilter<"UnitSpecialty"> | string
    created_at?: DateTimeFilter<"UnitSpecialty"> | Date | string
    updated_at?: DateTimeFilter<"UnitSpecialty"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    specialty?: XOR<SpecialtyScalarRelationFilter, SpecialtyWhereInput>
  }, "id" | "unit_id_specialty_id">

  export type UnitSpecialtyOrderByWithAggregationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    specialty_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UnitSpecialtyCountOrderByAggregateInput
    _max?: UnitSpecialtyMaxOrderByAggregateInput
    _min?: UnitSpecialtyMinOrderByAggregateInput
  }

  export type UnitSpecialtyScalarWhereWithAggregatesInput = {
    AND?: UnitSpecialtyScalarWhereWithAggregatesInput | UnitSpecialtyScalarWhereWithAggregatesInput[]
    OR?: UnitSpecialtyScalarWhereWithAggregatesInput[]
    NOT?: UnitSpecialtyScalarWhereWithAggregatesInput | UnitSpecialtyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitSpecialty"> | string
    unit_id?: StringWithAggregatesFilter<"UnitSpecialty"> | string
    specialty_id?: StringWithAggregatesFilter<"UnitSpecialty"> | string
    created_at?: DateTimeWithAggregatesFilter<"UnitSpecialty"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"UnitSpecialty"> | Date | string
  }

  export type UnitAmenityWhereInput = {
    AND?: UnitAmenityWhereInput | UnitAmenityWhereInput[]
    OR?: UnitAmenityWhereInput[]
    NOT?: UnitAmenityWhereInput | UnitAmenityWhereInput[]
    id?: StringFilter<"UnitAmenity"> | string
    unit_id?: StringFilter<"UnitAmenity"> | string
    amenity_id?: StringFilter<"UnitAmenity"> | string
    created_at?: DateTimeFilter<"UnitAmenity"> | Date | string
    updated_at?: DateTimeFilter<"UnitAmenity"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
  }

  export type UnitAmenityOrderByWithRelationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    amenity_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    unit?: UnitOrderByWithRelationInput
    amenity?: AmenityOrderByWithRelationInput
  }

  export type UnitAmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unit_id_amenity_id?: UnitAmenityUnit_idAmenity_idCompoundUniqueInput
    AND?: UnitAmenityWhereInput | UnitAmenityWhereInput[]
    OR?: UnitAmenityWhereInput[]
    NOT?: UnitAmenityWhereInput | UnitAmenityWhereInput[]
    unit_id?: StringFilter<"UnitAmenity"> | string
    amenity_id?: StringFilter<"UnitAmenity"> | string
    created_at?: DateTimeFilter<"UnitAmenity"> | Date | string
    updated_at?: DateTimeFilter<"UnitAmenity"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
  }, "id" | "unit_id_amenity_id">

  export type UnitAmenityOrderByWithAggregationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    amenity_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UnitAmenityCountOrderByAggregateInput
    _max?: UnitAmenityMaxOrderByAggregateInput
    _min?: UnitAmenityMinOrderByAggregateInput
  }

  export type UnitAmenityScalarWhereWithAggregatesInput = {
    AND?: UnitAmenityScalarWhereWithAggregatesInput | UnitAmenityScalarWhereWithAggregatesInput[]
    OR?: UnitAmenityScalarWhereWithAggregatesInput[]
    NOT?: UnitAmenityScalarWhereWithAggregatesInput | UnitAmenityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitAmenity"> | string
    unit_id?: StringWithAggregatesFilter<"UnitAmenity"> | string
    amenity_id?: StringWithAggregatesFilter<"UnitAmenity"> | string
    created_at?: DateTimeWithAggregatesFilter<"UnitAmenity"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"UnitAmenity"> | Date | string
  }

  export type UnitServiceWhereInput = {
    AND?: UnitServiceWhereInput | UnitServiceWhereInput[]
    OR?: UnitServiceWhereInput[]
    NOT?: UnitServiceWhereInput | UnitServiceWhereInput[]
    id?: StringFilter<"UnitService"> | string
    unit_id?: StringFilter<"UnitService"> | string
    service_id?: StringFilter<"UnitService"> | string
    custom_price_cents?: IntNullableFilter<"UnitService"> | number | null
    custom_duration_minutes?: IntNullableFilter<"UnitService"> | number | null
    is_active?: BoolFilter<"UnitService"> | boolean
    created_at?: DateTimeFilter<"UnitService"> | Date | string
    updated_at?: DateTimeFilter<"UnitService"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type UnitServiceOrderByWithRelationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    service_id?: SortOrder
    custom_price_cents?: SortOrderInput | SortOrder
    custom_duration_minutes?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    unit?: UnitOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type UnitServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unit_id_service_id?: UnitServiceUnit_idService_idCompoundUniqueInput
    AND?: UnitServiceWhereInput | UnitServiceWhereInput[]
    OR?: UnitServiceWhereInput[]
    NOT?: UnitServiceWhereInput | UnitServiceWhereInput[]
    unit_id?: StringFilter<"UnitService"> | string
    service_id?: StringFilter<"UnitService"> | string
    custom_price_cents?: IntNullableFilter<"UnitService"> | number | null
    custom_duration_minutes?: IntNullableFilter<"UnitService"> | number | null
    is_active?: BoolFilter<"UnitService"> | boolean
    created_at?: DateTimeFilter<"UnitService"> | Date | string
    updated_at?: DateTimeFilter<"UnitService"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id" | "unit_id_service_id">

  export type UnitServiceOrderByWithAggregationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    service_id?: SortOrder
    custom_price_cents?: SortOrderInput | SortOrder
    custom_duration_minutes?: SortOrderInput | SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UnitServiceCountOrderByAggregateInput
    _avg?: UnitServiceAvgOrderByAggregateInput
    _max?: UnitServiceMaxOrderByAggregateInput
    _min?: UnitServiceMinOrderByAggregateInput
    _sum?: UnitServiceSumOrderByAggregateInput
  }

  export type UnitServiceScalarWhereWithAggregatesInput = {
    AND?: UnitServiceScalarWhereWithAggregatesInput | UnitServiceScalarWhereWithAggregatesInput[]
    OR?: UnitServiceScalarWhereWithAggregatesInput[]
    NOT?: UnitServiceScalarWhereWithAggregatesInput | UnitServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitService"> | string
    unit_id?: StringWithAggregatesFilter<"UnitService"> | string
    service_id?: StringWithAggregatesFilter<"UnitService"> | string
    custom_price_cents?: IntNullableWithAggregatesFilter<"UnitService"> | number | null
    custom_duration_minutes?: IntNullableWithAggregatesFilter<"UnitService"> | number | null
    is_active?: BoolWithAggregatesFilter<"UnitService"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"UnitService"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"UnitService"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    user_id?: StringFilter<"Booking"> | string
    client_id?: StringFilter<"Booking"> | string
    unit_id?: StringFilter<"Booking"> | string
    service_id?: StringNullableFilter<"Booking"> | string | null
    price_cents?: IntNullableFilter<"Booking"> | number | null
    notes?: StringNullableFilter<"Booking"> | string | null
    start_at?: DateTimeFilter<"Booking"> | Date | string
    end_at?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    created_at?: DateTimeFilter<"Booking"> | Date | string
    updated_at?: DateTimeFilter<"Booking"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_id?: SortOrder
    unit_id?: SortOrder
    service_id?: SortOrderInput | SortOrder
    price_cents?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    start_at?: SortOrder
    end_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    owner?: UserOrderByWithRelationInput
    client?: UserOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    user_id?: StringFilter<"Booking"> | string
    client_id?: StringFilter<"Booking"> | string
    unit_id?: StringFilter<"Booking"> | string
    service_id?: StringNullableFilter<"Booking"> | string | null
    price_cents?: IntNullableFilter<"Booking"> | number | null
    notes?: StringNullableFilter<"Booking"> | string | null
    start_at?: DateTimeFilter<"Booking"> | Date | string
    end_at?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    created_at?: DateTimeFilter<"Booking"> | Date | string
    updated_at?: DateTimeFilter<"Booking"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_id?: SortOrder
    unit_id?: SortOrder
    service_id?: SortOrderInput | SortOrder
    price_cents?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    start_at?: SortOrder
    end_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    user_id?: StringWithAggregatesFilter<"Booking"> | string
    client_id?: StringWithAggregatesFilter<"Booking"> | string
    unit_id?: StringWithAggregatesFilter<"Booking"> | string
    service_id?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    price_cents?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    start_at?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    end_at?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    created_at?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    user_id?: StringFilter<"Customer"> | string
    unit_id?: StringFilter<"Customer"> | string
    notes?: StringNullableFilter<"Customer"> | string | null
    created_at?: DateTimeFilter<"Customer"> | Date | string
    updated_at?: DateTimeFilter<"Customer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    unit_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_unit_id?: CustomerUser_idUnit_idCompoundUniqueInput
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    user_id?: StringFilter<"Customer"> | string
    unit_id?: StringFilter<"Customer"> | string
    notes?: StringNullableFilter<"Customer"> | string | null
    created_at?: DateTimeFilter<"Customer"> | Date | string
    updated_at?: DateTimeFilter<"Customer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id" | "user_id_unit_id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    unit_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    user_id?: StringWithAggregatesFilter<"Customer"> | string
    unit_id?: StringWithAggregatesFilter<"Customer"> | string
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type BookingRuleWhereInput = {
    AND?: BookingRuleWhereInput | BookingRuleWhereInput[]
    OR?: BookingRuleWhereInput[]
    NOT?: BookingRuleWhereInput | BookingRuleWhereInput[]
    id?: StringFilter<"BookingRule"> | string
    user_id?: StringFilter<"BookingRule"> | string
    type?: EnumBookingRuleTypeFilter<"BookingRule"> | $Enums.BookingRuleType
    weekday?: IntNullableFilter<"BookingRule"> | number | null
    date?: StringNullableFilter<"BookingRule"> | string | null
    start_time?: DateTimeFilter<"BookingRule"> | Date | string
    end_time?: DateTimeFilter<"BookingRule"> | Date | string
    slot_duration_minutes?: IntFilter<"BookingRule"> | number
    min_advance_minutes?: IntNullableFilter<"BookingRule"> | number | null
    max_duration_minutes?: IntNullableFilter<"BookingRule"> | number | null
    max_bookings_per_day?: IntNullableFilter<"BookingRule"> | number | null
    max_bookings_per_client_per_day?: IntNullableFilter<"BookingRule"> | number | null
    metadata?: JsonNullableFilter<"BookingRule">
    created_at?: DateTimeFilter<"BookingRule"> | Date | string
    updated_at?: DateTimeFilter<"BookingRule"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BookingRuleOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    weekday?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    min_advance_minutes?: SortOrderInput | SortOrder
    max_duration_minutes?: SortOrderInput | SortOrder
    max_bookings_per_day?: SortOrderInput | SortOrder
    max_bookings_per_client_per_day?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BookingRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingRuleWhereInput | BookingRuleWhereInput[]
    OR?: BookingRuleWhereInput[]
    NOT?: BookingRuleWhereInput | BookingRuleWhereInput[]
    user_id?: StringFilter<"BookingRule"> | string
    type?: EnumBookingRuleTypeFilter<"BookingRule"> | $Enums.BookingRuleType
    weekday?: IntNullableFilter<"BookingRule"> | number | null
    date?: StringNullableFilter<"BookingRule"> | string | null
    start_time?: DateTimeFilter<"BookingRule"> | Date | string
    end_time?: DateTimeFilter<"BookingRule"> | Date | string
    slot_duration_minutes?: IntFilter<"BookingRule"> | number
    min_advance_minutes?: IntNullableFilter<"BookingRule"> | number | null
    max_duration_minutes?: IntNullableFilter<"BookingRule"> | number | null
    max_bookings_per_day?: IntNullableFilter<"BookingRule"> | number | null
    max_bookings_per_client_per_day?: IntNullableFilter<"BookingRule"> | number | null
    metadata?: JsonNullableFilter<"BookingRule">
    created_at?: DateTimeFilter<"BookingRule"> | Date | string
    updated_at?: DateTimeFilter<"BookingRule"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BookingRuleOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    weekday?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    min_advance_minutes?: SortOrderInput | SortOrder
    max_duration_minutes?: SortOrderInput | SortOrder
    max_bookings_per_day?: SortOrderInput | SortOrder
    max_bookings_per_client_per_day?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BookingRuleCountOrderByAggregateInput
    _avg?: BookingRuleAvgOrderByAggregateInput
    _max?: BookingRuleMaxOrderByAggregateInput
    _min?: BookingRuleMinOrderByAggregateInput
    _sum?: BookingRuleSumOrderByAggregateInput
  }

  export type BookingRuleScalarWhereWithAggregatesInput = {
    AND?: BookingRuleScalarWhereWithAggregatesInput | BookingRuleScalarWhereWithAggregatesInput[]
    OR?: BookingRuleScalarWhereWithAggregatesInput[]
    NOT?: BookingRuleScalarWhereWithAggregatesInput | BookingRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingRule"> | string
    user_id?: StringWithAggregatesFilter<"BookingRule"> | string
    type?: EnumBookingRuleTypeWithAggregatesFilter<"BookingRule"> | $Enums.BookingRuleType
    weekday?: IntNullableWithAggregatesFilter<"BookingRule"> | number | null
    date?: StringNullableWithAggregatesFilter<"BookingRule"> | string | null
    start_time?: DateTimeWithAggregatesFilter<"BookingRule"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"BookingRule"> | Date | string
    slot_duration_minutes?: IntWithAggregatesFilter<"BookingRule"> | number
    min_advance_minutes?: IntNullableWithAggregatesFilter<"BookingRule"> | number | null
    max_duration_minutes?: IntNullableWithAggregatesFilter<"BookingRule"> | number | null
    max_bookings_per_day?: IntNullableWithAggregatesFilter<"BookingRule"> | number | null
    max_bookings_per_client_per_day?: IntNullableWithAggregatesFilter<"BookingRule"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"BookingRule">
    created_at?: DateTimeWithAggregatesFilter<"BookingRule"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"BookingRule"> | Date | string
  }

  export type BookingExceptionWhereInput = {
    AND?: BookingExceptionWhereInput | BookingExceptionWhereInput[]
    OR?: BookingExceptionWhereInput[]
    NOT?: BookingExceptionWhereInput | BookingExceptionWhereInput[]
    id?: StringFilter<"BookingException"> | string
    user_id?: StringFilter<"BookingException"> | string
    date?: StringFilter<"BookingException"> | string
    type?: EnumBookingExceptionTypeFilter<"BookingException"> | $Enums.BookingExceptionType
    start_time?: DateTimeNullableFilter<"BookingException"> | Date | string | null
    end_time?: DateTimeNullableFilter<"BookingException"> | Date | string | null
    slot_duration_minutes?: IntNullableFilter<"BookingException"> | number | null
    reason?: StringNullableFilter<"BookingException"> | string | null
    created_at?: DateTimeFilter<"BookingException"> | Date | string
    updated_at?: DateTimeFilter<"BookingException"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BookingExceptionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    slot_duration_minutes?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BookingExceptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingExceptionWhereInput | BookingExceptionWhereInput[]
    OR?: BookingExceptionWhereInput[]
    NOT?: BookingExceptionWhereInput | BookingExceptionWhereInput[]
    user_id?: StringFilter<"BookingException"> | string
    date?: StringFilter<"BookingException"> | string
    type?: EnumBookingExceptionTypeFilter<"BookingException"> | $Enums.BookingExceptionType
    start_time?: DateTimeNullableFilter<"BookingException"> | Date | string | null
    end_time?: DateTimeNullableFilter<"BookingException"> | Date | string | null
    slot_duration_minutes?: IntNullableFilter<"BookingException"> | number | null
    reason?: StringNullableFilter<"BookingException"> | string | null
    created_at?: DateTimeFilter<"BookingException"> | Date | string
    updated_at?: DateTimeFilter<"BookingException"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BookingExceptionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    slot_duration_minutes?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BookingExceptionCountOrderByAggregateInput
    _avg?: BookingExceptionAvgOrderByAggregateInput
    _max?: BookingExceptionMaxOrderByAggregateInput
    _min?: BookingExceptionMinOrderByAggregateInput
    _sum?: BookingExceptionSumOrderByAggregateInput
  }

  export type BookingExceptionScalarWhereWithAggregatesInput = {
    AND?: BookingExceptionScalarWhereWithAggregatesInput | BookingExceptionScalarWhereWithAggregatesInput[]
    OR?: BookingExceptionScalarWhereWithAggregatesInput[]
    NOT?: BookingExceptionScalarWhereWithAggregatesInput | BookingExceptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingException"> | string
    user_id?: StringWithAggregatesFilter<"BookingException"> | string
    date?: StringWithAggregatesFilter<"BookingException"> | string
    type?: EnumBookingExceptionTypeWithAggregatesFilter<"BookingException"> | $Enums.BookingExceptionType
    start_time?: DateTimeNullableWithAggregatesFilter<"BookingException"> | Date | string | null
    end_time?: DateTimeNullableWithAggregatesFilter<"BookingException"> | Date | string | null
    slot_duration_minutes?: IntNullableWithAggregatesFilter<"BookingException"> | number | null
    reason?: StringNullableWithAggregatesFilter<"BookingException"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"BookingException"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"BookingException"> | Date | string
  }

  export type UnitAvailabilityRuleWhereInput = {
    AND?: UnitAvailabilityRuleWhereInput | UnitAvailabilityRuleWhereInput[]
    OR?: UnitAvailabilityRuleWhereInput[]
    NOT?: UnitAvailabilityRuleWhereInput | UnitAvailabilityRuleWhereInput[]
    id?: StringFilter<"UnitAvailabilityRule"> | string
    unit_id?: StringFilter<"UnitAvailabilityRule"> | string
    type?: EnumUnitAvailabilityRuleTypeFilter<"UnitAvailabilityRule"> | $Enums.UnitAvailabilityRuleType
    weekday?: IntNullableFilter<"UnitAvailabilityRule"> | number | null
    date?: StringNullableFilter<"UnitAvailabilityRule"> | string | null
    start_time?: StringFilter<"UnitAvailabilityRule"> | string
    end_time?: StringFilter<"UnitAvailabilityRule"> | string
    slot_duration_minutes?: IntFilter<"UnitAvailabilityRule"> | number
    is_active?: BoolFilter<"UnitAvailabilityRule"> | boolean
    metadata?: JsonNullableFilter<"UnitAvailabilityRule">
    created_at?: DateTimeFilter<"UnitAvailabilityRule"> | Date | string
    updated_at?: DateTimeFilter<"UnitAvailabilityRule"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type UnitAvailabilityRuleOrderByWithRelationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    type?: SortOrder
    weekday?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    is_active?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    unit?: UnitOrderByWithRelationInput
  }

  export type UnitAvailabilityRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitAvailabilityRuleWhereInput | UnitAvailabilityRuleWhereInput[]
    OR?: UnitAvailabilityRuleWhereInput[]
    NOT?: UnitAvailabilityRuleWhereInput | UnitAvailabilityRuleWhereInput[]
    unit_id?: StringFilter<"UnitAvailabilityRule"> | string
    type?: EnumUnitAvailabilityRuleTypeFilter<"UnitAvailabilityRule"> | $Enums.UnitAvailabilityRuleType
    weekday?: IntNullableFilter<"UnitAvailabilityRule"> | number | null
    date?: StringNullableFilter<"UnitAvailabilityRule"> | string | null
    start_time?: StringFilter<"UnitAvailabilityRule"> | string
    end_time?: StringFilter<"UnitAvailabilityRule"> | string
    slot_duration_minutes?: IntFilter<"UnitAvailabilityRule"> | number
    is_active?: BoolFilter<"UnitAvailabilityRule"> | boolean
    metadata?: JsonNullableFilter<"UnitAvailabilityRule">
    created_at?: DateTimeFilter<"UnitAvailabilityRule"> | Date | string
    updated_at?: DateTimeFilter<"UnitAvailabilityRule"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id">

  export type UnitAvailabilityRuleOrderByWithAggregationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    type?: SortOrder
    weekday?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    is_active?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UnitAvailabilityRuleCountOrderByAggregateInput
    _avg?: UnitAvailabilityRuleAvgOrderByAggregateInput
    _max?: UnitAvailabilityRuleMaxOrderByAggregateInput
    _min?: UnitAvailabilityRuleMinOrderByAggregateInput
    _sum?: UnitAvailabilityRuleSumOrderByAggregateInput
  }

  export type UnitAvailabilityRuleScalarWhereWithAggregatesInput = {
    AND?: UnitAvailabilityRuleScalarWhereWithAggregatesInput | UnitAvailabilityRuleScalarWhereWithAggregatesInput[]
    OR?: UnitAvailabilityRuleScalarWhereWithAggregatesInput[]
    NOT?: UnitAvailabilityRuleScalarWhereWithAggregatesInput | UnitAvailabilityRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitAvailabilityRule"> | string
    unit_id?: StringWithAggregatesFilter<"UnitAvailabilityRule"> | string
    type?: EnumUnitAvailabilityRuleTypeWithAggregatesFilter<"UnitAvailabilityRule"> | $Enums.UnitAvailabilityRuleType
    weekday?: IntNullableWithAggregatesFilter<"UnitAvailabilityRule"> | number | null
    date?: StringNullableWithAggregatesFilter<"UnitAvailabilityRule"> | string | null
    start_time?: StringWithAggregatesFilter<"UnitAvailabilityRule"> | string
    end_time?: StringWithAggregatesFilter<"UnitAvailabilityRule"> | string
    slot_duration_minutes?: IntWithAggregatesFilter<"UnitAvailabilityRule"> | number
    is_active?: BoolWithAggregatesFilter<"UnitAvailabilityRule"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"UnitAvailabilityRule">
    created_at?: DateTimeWithAggregatesFilter<"UnitAvailabilityRule"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"UnitAvailabilityRule"> | Date | string
  }

  export type UnitAvailabilityExceptionWhereInput = {
    AND?: UnitAvailabilityExceptionWhereInput | UnitAvailabilityExceptionWhereInput[]
    OR?: UnitAvailabilityExceptionWhereInput[]
    NOT?: UnitAvailabilityExceptionWhereInput | UnitAvailabilityExceptionWhereInput[]
    id?: StringFilter<"UnitAvailabilityException"> | string
    unit_id?: StringFilter<"UnitAvailabilityException"> | string
    date?: StringFilter<"UnitAvailabilityException"> | string
    type?: EnumUnitAvailabilityExceptionTypeFilter<"UnitAvailabilityException"> | $Enums.UnitAvailabilityExceptionType
    start_time?: StringNullableFilter<"UnitAvailabilityException"> | string | null
    end_time?: StringNullableFilter<"UnitAvailabilityException"> | string | null
    slot_duration_minutes?: IntNullableFilter<"UnitAvailabilityException"> | number | null
    reason?: StringNullableFilter<"UnitAvailabilityException"> | string | null
    created_at?: DateTimeFilter<"UnitAvailabilityException"> | Date | string
    updated_at?: DateTimeFilter<"UnitAvailabilityException"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type UnitAvailabilityExceptionOrderByWithRelationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    slot_duration_minutes?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    unit?: UnitOrderByWithRelationInput
  }

  export type UnitAvailabilityExceptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitAvailabilityExceptionWhereInput | UnitAvailabilityExceptionWhereInput[]
    OR?: UnitAvailabilityExceptionWhereInput[]
    NOT?: UnitAvailabilityExceptionWhereInput | UnitAvailabilityExceptionWhereInput[]
    unit_id?: StringFilter<"UnitAvailabilityException"> | string
    date?: StringFilter<"UnitAvailabilityException"> | string
    type?: EnumUnitAvailabilityExceptionTypeFilter<"UnitAvailabilityException"> | $Enums.UnitAvailabilityExceptionType
    start_time?: StringNullableFilter<"UnitAvailabilityException"> | string | null
    end_time?: StringNullableFilter<"UnitAvailabilityException"> | string | null
    slot_duration_minutes?: IntNullableFilter<"UnitAvailabilityException"> | number | null
    reason?: StringNullableFilter<"UnitAvailabilityException"> | string | null
    created_at?: DateTimeFilter<"UnitAvailabilityException"> | Date | string
    updated_at?: DateTimeFilter<"UnitAvailabilityException"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id">

  export type UnitAvailabilityExceptionOrderByWithAggregationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    slot_duration_minutes?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UnitAvailabilityExceptionCountOrderByAggregateInput
    _avg?: UnitAvailabilityExceptionAvgOrderByAggregateInput
    _max?: UnitAvailabilityExceptionMaxOrderByAggregateInput
    _min?: UnitAvailabilityExceptionMinOrderByAggregateInput
    _sum?: UnitAvailabilityExceptionSumOrderByAggregateInput
  }

  export type UnitAvailabilityExceptionScalarWhereWithAggregatesInput = {
    AND?: UnitAvailabilityExceptionScalarWhereWithAggregatesInput | UnitAvailabilityExceptionScalarWhereWithAggregatesInput[]
    OR?: UnitAvailabilityExceptionScalarWhereWithAggregatesInput[]
    NOT?: UnitAvailabilityExceptionScalarWhereWithAggregatesInput | UnitAvailabilityExceptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnitAvailabilityException"> | string
    unit_id?: StringWithAggregatesFilter<"UnitAvailabilityException"> | string
    date?: StringWithAggregatesFilter<"UnitAvailabilityException"> | string
    type?: EnumUnitAvailabilityExceptionTypeWithAggregatesFilter<"UnitAvailabilityException"> | $Enums.UnitAvailabilityExceptionType
    start_time?: StringNullableWithAggregatesFilter<"UnitAvailabilityException"> | string | null
    end_time?: StringNullableWithAggregatesFilter<"UnitAvailabilityException"> | string | null
    slot_duration_minutes?: IntNullableWithAggregatesFilter<"UnitAvailabilityException"> | number | null
    reason?: StringNullableWithAggregatesFilter<"UnitAvailabilityException"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"UnitAvailabilityException"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"UnitAvailabilityException"> | Date | string
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    price?: IntFilter<"Plan"> | number
    currency?: StringFilter<"Plan"> | string
    interval?: EnumRenewalIntervalFilter<"Plan"> | $Enums.RenewalInterval
    features?: JsonFilter<"Plan">
    limits?: JsonFilter<"Plan">
    trial_days?: IntNullableFilter<"Plan"> | number | null
    is_active?: BoolFilter<"Plan"> | boolean
    metadata?: JsonNullableFilter<"Plan">
    created_at?: DateTimeFilter<"Plan"> | Date | string
    updated_at?: DateTimeFilter<"Plan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    features?: SortOrder
    limits?: SortOrder
    trial_days?: SortOrderInput | SortOrder
    is_active?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    description?: StringNullableFilter<"Plan"> | string | null
    price?: IntFilter<"Plan"> | number
    currency?: StringFilter<"Plan"> | string
    interval?: EnumRenewalIntervalFilter<"Plan"> | $Enums.RenewalInterval
    features?: JsonFilter<"Plan">
    limits?: JsonFilter<"Plan">
    trial_days?: IntNullableFilter<"Plan"> | number | null
    is_active?: BoolFilter<"Plan"> | boolean
    metadata?: JsonNullableFilter<"Plan">
    created_at?: DateTimeFilter<"Plan"> | Date | string
    updated_at?: DateTimeFilter<"Plan"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }, "id" | "name">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    features?: SortOrder
    limits?: SortOrder
    trial_days?: SortOrderInput | SortOrder
    is_active?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    description?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    price?: IntWithAggregatesFilter<"Plan"> | number
    currency?: StringWithAggregatesFilter<"Plan"> | string
    interval?: EnumRenewalIntervalWithAggregatesFilter<"Plan"> | $Enums.RenewalInterval
    features?: JsonWithAggregatesFilter<"Plan">
    limits?: JsonWithAggregatesFilter<"Plan">
    trial_days?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    is_active?: BoolWithAggregatesFilter<"Plan"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Plan">
    created_at?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    unit_id?: StringFilter<"Subscription"> | string
    user_id?: StringFilter<"Subscription"> | string
    plan_id?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    start_date?: DateTimeFilter<"Subscription"> | Date | string
    current_period_start?: DateTimeFilter<"Subscription"> | Date | string
    current_period_end?: DateTimeFilter<"Subscription"> | Date | string
    cancel_at_period_end?: BoolFilter<"Subscription"> | boolean
    canceled_at?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trial_end?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    renewal_interval?: EnumRenewalIntervalFilter<"Subscription"> | $Enums.RenewalInterval
    discount_id?: StringNullableFilter<"Subscription"> | string | null
    provider_subscription_id?: StringNullableFilter<"Subscription"> | string | null
    metadata?: JsonNullableFilter<"Subscription">
    created_at?: DateTimeFilter<"Subscription"> | Date | string
    updated_at?: DateTimeFilter<"Subscription"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    discount?: XOR<DiscountNullableScalarRelationFilter, DiscountWhereInput> | null
    invoices?: InvoiceListRelationFilter
    coupon_redemptions?: CouponRedemptionListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    status?: SortOrder
    start_date?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    canceled_at?: SortOrderInput | SortOrder
    trial_end?: SortOrderInput | SortOrder
    renewal_interval?: SortOrder
    discount_id?: SortOrderInput | SortOrder
    provider_subscription_id?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    unit?: UnitOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    plan?: PlanOrderByWithRelationInput
    discount?: DiscountOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    coupon_redemptions?: CouponRedemptionOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    unit_id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    user_id?: StringFilter<"Subscription"> | string
    plan_id?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    start_date?: DateTimeFilter<"Subscription"> | Date | string
    current_period_start?: DateTimeFilter<"Subscription"> | Date | string
    current_period_end?: DateTimeFilter<"Subscription"> | Date | string
    cancel_at_period_end?: BoolFilter<"Subscription"> | boolean
    canceled_at?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trial_end?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    renewal_interval?: EnumRenewalIntervalFilter<"Subscription"> | $Enums.RenewalInterval
    discount_id?: StringNullableFilter<"Subscription"> | string | null
    provider_subscription_id?: StringNullableFilter<"Subscription"> | string | null
    metadata?: JsonNullableFilter<"Subscription">
    created_at?: DateTimeFilter<"Subscription"> | Date | string
    updated_at?: DateTimeFilter<"Subscription"> | Date | string
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    discount?: XOR<DiscountNullableScalarRelationFilter, DiscountWhereInput> | null
    invoices?: InvoiceListRelationFilter
    coupon_redemptions?: CouponRedemptionListRelationFilter
  }, "id" | "unit_id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    unit_id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    status?: SortOrder
    start_date?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    canceled_at?: SortOrderInput | SortOrder
    trial_end?: SortOrderInput | SortOrder
    renewal_interval?: SortOrder
    discount_id?: SortOrderInput | SortOrder
    provider_subscription_id?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    unit_id?: StringWithAggregatesFilter<"Subscription"> | string
    user_id?: StringWithAggregatesFilter<"Subscription"> | string
    plan_id?: StringWithAggregatesFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    start_date?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    current_period_start?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    current_period_end?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    cancel_at_period_end?: BoolWithAggregatesFilter<"Subscription"> | boolean
    canceled_at?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trial_end?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    renewal_interval?: EnumRenewalIntervalWithAggregatesFilter<"Subscription"> | $Enums.RenewalInterval
    discount_id?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    provider_subscription_id?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Subscription">
    created_at?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    user_id?: StringFilter<"Invoice"> | string
    subscription_id?: StringFilter<"Invoice"> | string
    amount?: IntFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    line_items?: JsonFilter<"Invoice">
    due_date?: DateTimeFilter<"Invoice"> | Date | string
    paid_at?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    provider_invoice_id?: StringNullableFilter<"Invoice"> | string | null
    metadata?: JsonNullableFilter<"Invoice">
    created_at?: DateTimeFilter<"Invoice"> | Date | string
    updated_at?: DateTimeFilter<"Invoice"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    line_items?: SortOrder
    due_date?: SortOrder
    paid_at?: SortOrderInput | SortOrder
    provider_invoice_id?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    user_id?: StringFilter<"Invoice"> | string
    subscription_id?: StringFilter<"Invoice"> | string
    amount?: IntFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    line_items?: JsonFilter<"Invoice">
    due_date?: DateTimeFilter<"Invoice"> | Date | string
    paid_at?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    provider_invoice_id?: StringNullableFilter<"Invoice"> | string | null
    metadata?: JsonNullableFilter<"Invoice">
    created_at?: DateTimeFilter<"Invoice"> | Date | string
    updated_at?: DateTimeFilter<"Invoice"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    line_items?: SortOrder
    due_date?: SortOrder
    paid_at?: SortOrderInput | SortOrder
    provider_invoice_id?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    user_id?: StringWithAggregatesFilter<"Invoice"> | string
    subscription_id?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: IntWithAggregatesFilter<"Invoice"> | number
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    line_items?: JsonWithAggregatesFilter<"Invoice">
    due_date?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paid_at?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    provider_invoice_id?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Invoice">
    created_at?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type DiscountWhereInput = {
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    id?: StringFilter<"Discount"> | string
    code?: StringFilter<"Discount"> | string
    type?: EnumDiscountTypeFilter<"Discount"> | $Enums.DiscountType
    value?: IntFilter<"Discount"> | number
    duration?: EnumDiscountDurationFilter<"Discount"> | $Enums.DiscountDuration
    repeating_count?: IntNullableFilter<"Discount"> | number | null
    assigned_to_user_id?: StringNullableFilter<"Discount"> | string | null
    max_redemptions?: IntNullableFilter<"Discount"> | number | null
    redemptions_count?: IntFilter<"Discount"> | number
    expires_at?: DateTimeNullableFilter<"Discount"> | Date | string | null
    is_active?: BoolFilter<"Discount"> | boolean
    metadata?: JsonNullableFilter<"Discount">
    created_at?: DateTimeFilter<"Discount"> | Date | string
    updated_at?: DateTimeFilter<"Discount"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }

  export type DiscountOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    value?: SortOrder
    duration?: SortOrder
    repeating_count?: SortOrderInput | SortOrder
    assigned_to_user_id?: SortOrderInput | SortOrder
    max_redemptions?: SortOrderInput | SortOrder
    redemptions_count?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    is_active?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type DiscountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    type?: EnumDiscountTypeFilter<"Discount"> | $Enums.DiscountType
    value?: IntFilter<"Discount"> | number
    duration?: EnumDiscountDurationFilter<"Discount"> | $Enums.DiscountDuration
    repeating_count?: IntNullableFilter<"Discount"> | number | null
    assigned_to_user_id?: StringNullableFilter<"Discount"> | string | null
    max_redemptions?: IntNullableFilter<"Discount"> | number | null
    redemptions_count?: IntFilter<"Discount"> | number
    expires_at?: DateTimeNullableFilter<"Discount"> | Date | string | null
    is_active?: BoolFilter<"Discount"> | boolean
    metadata?: JsonNullableFilter<"Discount">
    created_at?: DateTimeFilter<"Discount"> | Date | string
    updated_at?: DateTimeFilter<"Discount"> | Date | string
    subscriptions?: SubscriptionListRelationFilter
  }, "id" | "code">

  export type DiscountOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    value?: SortOrder
    duration?: SortOrder
    repeating_count?: SortOrderInput | SortOrder
    assigned_to_user_id?: SortOrderInput | SortOrder
    max_redemptions?: SortOrderInput | SortOrder
    redemptions_count?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    is_active?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DiscountCountOrderByAggregateInput
    _avg?: DiscountAvgOrderByAggregateInput
    _max?: DiscountMaxOrderByAggregateInput
    _min?: DiscountMinOrderByAggregateInput
    _sum?: DiscountSumOrderByAggregateInput
  }

  export type DiscountScalarWhereWithAggregatesInput = {
    AND?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    OR?: DiscountScalarWhereWithAggregatesInput[]
    NOT?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Discount"> | string
    code?: StringWithAggregatesFilter<"Discount"> | string
    type?: EnumDiscountTypeWithAggregatesFilter<"Discount"> | $Enums.DiscountType
    value?: IntWithAggregatesFilter<"Discount"> | number
    duration?: EnumDiscountDurationWithAggregatesFilter<"Discount"> | $Enums.DiscountDuration
    repeating_count?: IntNullableWithAggregatesFilter<"Discount"> | number | null
    assigned_to_user_id?: StringNullableWithAggregatesFilter<"Discount"> | string | null
    max_redemptions?: IntNullableWithAggregatesFilter<"Discount"> | number | null
    redemptions_count?: IntWithAggregatesFilter<"Discount"> | number
    expires_at?: DateTimeNullableWithAggregatesFilter<"Discount"> | Date | string | null
    is_active?: BoolWithAggregatesFilter<"Discount"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Discount">
    created_at?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
  }

  export type CouponRedemptionWhereInput = {
    AND?: CouponRedemptionWhereInput | CouponRedemptionWhereInput[]
    OR?: CouponRedemptionWhereInput[]
    NOT?: CouponRedemptionWhereInput | CouponRedemptionWhereInput[]
    id?: StringFilter<"CouponRedemption"> | string
    coupon_id?: StringFilter<"CouponRedemption"> | string
    user_id?: StringFilter<"CouponRedemption"> | string
    subscription_id?: StringFilter<"CouponRedemption"> | string
    redeemed_at?: DateTimeFilter<"CouponRedemption"> | Date | string
    metadata?: JsonNullableFilter<"CouponRedemption">
    created_at?: DateTimeFilter<"CouponRedemption"> | Date | string
    updated_at?: DateTimeFilter<"CouponRedemption"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type CouponRedemptionOrderByWithRelationInput = {
    id?: SortOrder
    coupon_id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    redeemed_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type CouponRedemptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CouponRedemptionWhereInput | CouponRedemptionWhereInput[]
    OR?: CouponRedemptionWhereInput[]
    NOT?: CouponRedemptionWhereInput | CouponRedemptionWhereInput[]
    coupon_id?: StringFilter<"CouponRedemption"> | string
    user_id?: StringFilter<"CouponRedemption"> | string
    subscription_id?: StringFilter<"CouponRedemption"> | string
    redeemed_at?: DateTimeFilter<"CouponRedemption"> | Date | string
    metadata?: JsonNullableFilter<"CouponRedemption">
    created_at?: DateTimeFilter<"CouponRedemption"> | Date | string
    updated_at?: DateTimeFilter<"CouponRedemption"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type CouponRedemptionOrderByWithAggregationInput = {
    id?: SortOrder
    coupon_id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    redeemed_at?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CouponRedemptionCountOrderByAggregateInput
    _max?: CouponRedemptionMaxOrderByAggregateInput
    _min?: CouponRedemptionMinOrderByAggregateInput
  }

  export type CouponRedemptionScalarWhereWithAggregatesInput = {
    AND?: CouponRedemptionScalarWhereWithAggregatesInput | CouponRedemptionScalarWhereWithAggregatesInput[]
    OR?: CouponRedemptionScalarWhereWithAggregatesInput[]
    NOT?: CouponRedemptionScalarWhereWithAggregatesInput | CouponRedemptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CouponRedemption"> | string
    coupon_id?: StringWithAggregatesFilter<"CouponRedemption"> | string
    user_id?: StringWithAggregatesFilter<"CouponRedemption"> | string
    subscription_id?: StringWithAggregatesFilter<"CouponRedemption"> | string
    redeemed_at?: DateTimeWithAggregatesFilter<"CouponRedemption"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"CouponRedemption">
    created_at?: DateTimeWithAggregatesFilter<"CouponRedemption"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CouponRedemption"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    target_user_id?: StringFilter<"Notification"> | string
    channel?: EnumNotificationChannelFilter<"Notification"> | $Enums.NotificationChannel
    template_id?: StringFilter<"Notification"> | string
    payload?: JsonFilter<"Notification">
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    provider_id?: StringNullableFilter<"Notification"> | string | null
    error_message?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    message_id?: StringFilter<"Notification"> | string
    sent_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    delivered_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    read_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    created_at?: DateTimeFilter<"Notification"> | Date | string
    updated_at?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<NotificationTemplateScalarRelationFilter, NotificationTemplateWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    target_user_id?: SortOrder
    channel?: SortOrder
    template_id?: SortOrder
    payload?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    provider_id?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    message_id?: SortOrder
    sent_at?: SortOrderInput | SortOrder
    delivered_at?: SortOrderInput | SortOrder
    read_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    template?: NotificationTemplateOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    message_id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    target_user_id?: StringFilter<"Notification"> | string
    channel?: EnumNotificationChannelFilter<"Notification"> | $Enums.NotificationChannel
    template_id?: StringFilter<"Notification"> | string
    payload?: JsonFilter<"Notification">
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    provider_id?: StringNullableFilter<"Notification"> | string | null
    error_message?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    sent_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    delivered_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    read_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    created_at?: DateTimeFilter<"Notification"> | Date | string
    updated_at?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<NotificationTemplateScalarRelationFilter, NotificationTemplateWhereInput>
  }, "id" | "message_id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    target_user_id?: SortOrder
    channel?: SortOrder
    template_id?: SortOrder
    payload?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    provider_id?: SortOrderInput | SortOrder
    error_message?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    message_id?: SortOrder
    sent_at?: SortOrderInput | SortOrder
    delivered_at?: SortOrderInput | SortOrder
    read_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    target_user_id?: StringWithAggregatesFilter<"Notification"> | string
    channel?: EnumNotificationChannelWithAggregatesFilter<"Notification"> | $Enums.NotificationChannel
    template_id?: StringWithAggregatesFilter<"Notification"> | string
    payload?: JsonWithAggregatesFilter<"Notification">
    priority?: EnumNotificationPriorityWithAggregatesFilter<"Notification"> | $Enums.NotificationPriority
    status?: EnumNotificationStatusWithAggregatesFilter<"Notification"> | $Enums.NotificationStatus
    provider_id?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    error_message?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    message_id?: StringWithAggregatesFilter<"Notification"> | string
    sent_at?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    delivered_at?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    read_at?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NotificationTemplateWhereInput = {
    AND?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    OR?: NotificationTemplateWhereInput[]
    NOT?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    id?: StringFilter<"NotificationTemplate"> | string
    name?: StringFilter<"NotificationTemplate"> | string
    channel?: EnumNotificationTemplateChannelFilter<"NotificationTemplate"> | $Enums.NotificationTemplateChannel
    subject?: StringNullableFilter<"NotificationTemplate"> | string | null
    body_template?: StringFilter<"NotificationTemplate"> | string
    title_template?: StringNullableFilter<"NotificationTemplate"> | string | null
    variables?: StringNullableListFilter<"NotificationTemplate">
    version?: IntFilter<"NotificationTemplate"> | number
    is_active?: BoolFilter<"NotificationTemplate"> | boolean
    metadata?: JsonNullableFilter<"NotificationTemplate">
    created_at?: DateTimeFilter<"NotificationTemplate"> | Date | string
    updated_at?: DateTimeFilter<"NotificationTemplate"> | Date | string
    notifications?: NotificationListRelationFilter
  }

  export type NotificationTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    channel?: SortOrder
    subject?: SortOrderInput | SortOrder
    body_template?: SortOrder
    title_template?: SortOrderInput | SortOrder
    variables?: SortOrder
    version?: SortOrder
    is_active?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type NotificationTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_channel?: NotificationTemplateNameChannelCompoundUniqueInput
    AND?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    OR?: NotificationTemplateWhereInput[]
    NOT?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    name?: StringFilter<"NotificationTemplate"> | string
    channel?: EnumNotificationTemplateChannelFilter<"NotificationTemplate"> | $Enums.NotificationTemplateChannel
    subject?: StringNullableFilter<"NotificationTemplate"> | string | null
    body_template?: StringFilter<"NotificationTemplate"> | string
    title_template?: StringNullableFilter<"NotificationTemplate"> | string | null
    variables?: StringNullableListFilter<"NotificationTemplate">
    version?: IntFilter<"NotificationTemplate"> | number
    is_active?: BoolFilter<"NotificationTemplate"> | boolean
    metadata?: JsonNullableFilter<"NotificationTemplate">
    created_at?: DateTimeFilter<"NotificationTemplate"> | Date | string
    updated_at?: DateTimeFilter<"NotificationTemplate"> | Date | string
    notifications?: NotificationListRelationFilter
  }, "id" | "name_channel">

  export type NotificationTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    channel?: SortOrder
    subject?: SortOrderInput | SortOrder
    body_template?: SortOrder
    title_template?: SortOrderInput | SortOrder
    variables?: SortOrder
    version?: SortOrder
    is_active?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: NotificationTemplateCountOrderByAggregateInput
    _avg?: NotificationTemplateAvgOrderByAggregateInput
    _max?: NotificationTemplateMaxOrderByAggregateInput
    _min?: NotificationTemplateMinOrderByAggregateInput
    _sum?: NotificationTemplateSumOrderByAggregateInput
  }

  export type NotificationTemplateScalarWhereWithAggregatesInput = {
    AND?: NotificationTemplateScalarWhereWithAggregatesInput | NotificationTemplateScalarWhereWithAggregatesInput[]
    OR?: NotificationTemplateScalarWhereWithAggregatesInput[]
    NOT?: NotificationTemplateScalarWhereWithAggregatesInput | NotificationTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    name?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    channel?: EnumNotificationTemplateChannelWithAggregatesFilter<"NotificationTemplate"> | $Enums.NotificationTemplateChannel
    subject?: StringNullableWithAggregatesFilter<"NotificationTemplate"> | string | null
    body_template?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    title_template?: StringNullableWithAggregatesFilter<"NotificationTemplate"> | string | null
    variables?: StringNullableListFilter<"NotificationTemplate">
    version?: IntWithAggregatesFilter<"NotificationTemplate"> | number
    is_active?: BoolWithAggregatesFilter<"NotificationTemplate"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"NotificationTemplate">
    created_at?: DateTimeWithAggregatesFilter<"NotificationTemplate"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"NotificationTemplate"> | Date | string
  }

  export type NotificationPreferenceWhereInput = {
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    user_id?: StringFilter<"NotificationPreference"> | string
    category?: EnumNotificationPreferenceCategoryFilter<"NotificationPreference"> | $Enums.NotificationPreferenceCategory
    channels?: JsonFilter<"NotificationPreference">
    metadata?: JsonNullableFilter<"NotificationPreference">
    created_at?: DateTimeFilter<"NotificationPreference"> | Date | string
    updated_at?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    category?: SortOrder
    channels?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_category?: NotificationPreferenceUser_idCategoryCompoundUniqueInput
    AND?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    OR?: NotificationPreferenceWhereInput[]
    NOT?: NotificationPreferenceWhereInput | NotificationPreferenceWhereInput[]
    user_id?: StringFilter<"NotificationPreference"> | string
    category?: EnumNotificationPreferenceCategoryFilter<"NotificationPreference"> | $Enums.NotificationPreferenceCategory
    channels?: JsonFilter<"NotificationPreference">
    metadata?: JsonNullableFilter<"NotificationPreference">
    created_at?: DateTimeFilter<"NotificationPreference"> | Date | string
    updated_at?: DateTimeFilter<"NotificationPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id_category">

  export type NotificationPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    category?: SortOrder
    channels?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: NotificationPreferenceCountOrderByAggregateInput
    _max?: NotificationPreferenceMaxOrderByAggregateInput
    _min?: NotificationPreferenceMinOrderByAggregateInput
  }

  export type NotificationPreferenceScalarWhereWithAggregatesInput = {
    AND?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    OR?: NotificationPreferenceScalarWhereWithAggregatesInput[]
    NOT?: NotificationPreferenceScalarWhereWithAggregatesInput | NotificationPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationPreference"> | string
    user_id?: StringWithAggregatesFilter<"NotificationPreference"> | string
    category?: EnumNotificationPreferenceCategoryWithAggregatesFilter<"NotificationPreference"> | $Enums.NotificationPreferenceCategory
    channels?: JsonWithAggregatesFilter<"NotificationPreference">
    metadata?: JsonNullableWithAggregatesFilter<"NotificationPreference">
    created_at?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"NotificationPreference"> | Date | string
  }

  export type UserCreateInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationUncheckedCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingUncheckedCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleUncheckedCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUncheckedUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUncheckedUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUncheckedUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOrganizationInput
    units?: UnitCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id: string
    name: string
    owner_id: string
    created_at?: Date | string
    updated_at?: Date | string
    units?: UnitUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOrganizationNestedInput
    units?: UnitUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    owner_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: UnitUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id: string
    name: string
    owner_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    owner_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    organization: OrganizationCreateNestedOneWithoutUnitsInput
    unit_specialties?: UnitSpecialtyCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionCreateNestedOneWithoutUnitInput
    bookings?: BookingCreateNestedManyWithoutUnitInput
    customers?: CustomerCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id: string
    organization_id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit_specialties?: UnitSpecialtyUncheckedCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceUncheckedCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionUncheckedCreateNestedOneWithoutUnitInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUnitInput
    customers?: CustomerUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUnitsNestedInput
    unit_specialties?: UnitSpecialtyUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUpdateOneWithoutUnitNestedInput
    bookings?: BookingUpdateManyWithoutUnitNestedInput
    customers?: CustomerUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_specialties?: UnitSpecialtyUncheckedUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUncheckedUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUncheckedUpdateOneWithoutUnitNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUnitNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id: string
    organization_id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    icon: string
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    services?: ServiceCreateNestedManyWithoutSpecialtyInput
    unit_specialties?: UnitSpecialtyCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    icon: string
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutSpecialtyInput
    unit_specialties?: UnitSpecialtyUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutSpecialtyNestedInput
    unit_specialties?: UnitSpecialtyUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutSpecialtyNestedInput
    unit_specialties?: UnitSpecialtyUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyCreateManyInput = {
    id: string
    code: string
    name: string
    description?: string | null
    icon: string
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SpecialtyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    icon: string
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    unit_amenities?: UnitAmenityCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUncheckedCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    icon: string
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    unit_amenities?: UnitAmenityUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_amenities?: UnitAmenityUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_amenities?: UnitAmenityUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityCreateManyInput = {
    id: string
    code: string
    name: string
    description?: string | null
    icon: string
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AmenityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    default_duration_minutes: number
    default_price_cents: number
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    specialty: SpecialtyCreateNestedOneWithoutServicesInput
    unit_services?: UnitServiceCreateNestedManyWithoutServiceInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id: string
    specialty_id: string
    code: string
    name: string
    description?: string | null
    default_duration_minutes: number
    default_price_cents: number
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    unit_services?: UnitServiceUncheckedCreateNestedManyWithoutServiceInput
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    default_duration_minutes?: IntFieldUpdateOperationsInput | number
    default_price_cents?: IntFieldUpdateOperationsInput | number
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    specialty?: SpecialtyUpdateOneRequiredWithoutServicesNestedInput
    unit_services?: UnitServiceUpdateManyWithoutServiceNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialty_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    default_duration_minutes?: IntFieldUpdateOperationsInput | number
    default_price_cents?: IntFieldUpdateOperationsInput | number
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_services?: UnitServiceUncheckedUpdateManyWithoutServiceNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id: string
    specialty_id: string
    code: string
    name: string
    description?: string | null
    default_duration_minutes: number
    default_price_cents: number
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    default_duration_minutes?: IntFieldUpdateOperationsInput | number
    default_price_cents?: IntFieldUpdateOperationsInput | number
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialty_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    default_duration_minutes?: IntFieldUpdateOperationsInput | number
    default_price_cents?: IntFieldUpdateOperationsInput | number
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitSpecialtyCreateInput = {
    id: string
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutUnit_specialtiesInput
    specialty: SpecialtyCreateNestedOneWithoutUnit_specialtiesInput
  }

  export type UnitSpecialtyUncheckedCreateInput = {
    id: string
    unit_id: string
    specialty_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitSpecialtyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutUnit_specialtiesNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutUnit_specialtiesNestedInput
  }

  export type UnitSpecialtyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    specialty_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitSpecialtyCreateManyInput = {
    id: string
    unit_id: string
    specialty_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitSpecialtyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitSpecialtyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    specialty_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAmenityCreateInput = {
    id: string
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutUnit_amenitiesInput
    amenity: AmenityCreateNestedOneWithoutUnit_amenitiesInput
  }

  export type UnitAmenityUncheckedCreateInput = {
    id: string
    unit_id: string
    amenity_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAmenityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutUnit_amenitiesNestedInput
    amenity?: AmenityUpdateOneRequiredWithoutUnit_amenitiesNestedInput
  }

  export type UnitAmenityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    amenity_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAmenityCreateManyInput = {
    id: string
    unit_id: string
    amenity_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAmenityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAmenityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    amenity_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitServiceCreateInput = {
    id: string
    custom_price_cents?: number | null
    custom_duration_minutes?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutUnit_servicesInput
    service: ServiceCreateNestedOneWithoutUnit_servicesInput
  }

  export type UnitServiceUncheckedCreateInput = {
    id: string
    unit_id: string
    service_id: string
    custom_price_cents?: number | null
    custom_duration_minutes?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    custom_price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    custom_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutUnit_servicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutUnit_servicesNestedInput
  }

  export type UnitServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    custom_price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    custom_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitServiceCreateManyInput = {
    id: string
    unit_id: string
    service_id: string
    custom_price_cents?: number | null
    custom_duration_minutes?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    custom_price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    custom_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    custom_price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    custom_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id: string
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutBookings_as_ownerInput
    client: UserCreateNestedOneWithoutBookings_as_clientInput
    unit: UnitCreateNestedOneWithoutBookingsInput
    service?: ServiceCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateInput = {
    id: string
    user_id: string
    client_id: string
    unit_id: string
    service_id?: string | null
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutBookings_as_ownerNestedInput
    client?: UserUpdateOneRequiredWithoutBookings_as_clientNestedInput
    unit?: UnitUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyInput = {
    id: string
    user_id: string
    client_id: string
    unit_id: string
    service_id?: string | null
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutCustomer_profilesInput
    unit: UnitCreateNestedOneWithoutCustomersInput
  }

  export type CustomerUncheckedCreateInput = {
    id: string
    user_id: string
    unit_id: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomer_profilesNestedInput
    unit?: UnitUpdateOneRequiredWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateManyInput = {
    id: string
    user_id: string
    unit_id: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRuleCreateInput = {
    id: string
    type: $Enums.BookingRuleType
    weekday?: number | null
    date?: string | null
    start_time: Date | string
    end_time: Date | string
    slot_duration_minutes: number
    min_advance_minutes?: number | null
    max_duration_minutes?: number | null
    max_bookings_per_day?: number | null
    max_bookings_per_client_per_day?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutBooking_rulesInput
  }

  export type BookingRuleUncheckedCreateInput = {
    id: string
    user_id: string
    type: $Enums.BookingRuleType
    weekday?: number | null
    date?: string | null
    start_time: Date | string
    end_time: Date | string
    slot_duration_minutes: number
    min_advance_minutes?: number | null
    max_duration_minutes?: number | null
    max_bookings_per_day?: number | null
    max_bookings_per_client_per_day?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingRuleTypeFieldUpdateOperationsInput | $Enums.BookingRuleType
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    slot_duration_minutes?: IntFieldUpdateOperationsInput | number
    min_advance_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    max_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    max_bookings_per_day?: NullableIntFieldUpdateOperationsInput | number | null
    max_bookings_per_client_per_day?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBooking_rulesNestedInput
  }

  export type BookingRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingRuleTypeFieldUpdateOperationsInput | $Enums.BookingRuleType
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    slot_duration_minutes?: IntFieldUpdateOperationsInput | number
    min_advance_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    max_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    max_bookings_per_day?: NullableIntFieldUpdateOperationsInput | number | null
    max_bookings_per_client_per_day?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRuleCreateManyInput = {
    id: string
    user_id: string
    type: $Enums.BookingRuleType
    weekday?: number | null
    date?: string | null
    start_time: Date | string
    end_time: Date | string
    slot_duration_minutes: number
    min_advance_minutes?: number | null
    max_duration_minutes?: number | null
    max_bookings_per_day?: number | null
    max_bookings_per_client_per_day?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingRuleTypeFieldUpdateOperationsInput | $Enums.BookingRuleType
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    slot_duration_minutes?: IntFieldUpdateOperationsInput | number
    min_advance_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    max_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    max_bookings_per_day?: NullableIntFieldUpdateOperationsInput | number | null
    max_bookings_per_client_per_day?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingRuleTypeFieldUpdateOperationsInput | $Enums.BookingRuleType
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    slot_duration_minutes?: IntFieldUpdateOperationsInput | number
    min_advance_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    max_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    max_bookings_per_day?: NullableIntFieldUpdateOperationsInput | number | null
    max_bookings_per_client_per_day?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingExceptionCreateInput = {
    id: string
    date: string
    type: $Enums.BookingExceptionType
    start_time?: Date | string | null
    end_time?: Date | string | null
    slot_duration_minutes?: number | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutBooking_exceptionsInput
  }

  export type BookingExceptionUncheckedCreateInput = {
    id: string
    user_id: string
    date: string
    type: $Enums.BookingExceptionType
    start_time?: Date | string | null
    end_time?: Date | string | null
    slot_duration_minutes?: number | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingExceptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingExceptionTypeFieldUpdateOperationsInput | $Enums.BookingExceptionType
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slot_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBooking_exceptionsNestedInput
  }

  export type BookingExceptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingExceptionTypeFieldUpdateOperationsInput | $Enums.BookingExceptionType
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slot_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingExceptionCreateManyInput = {
    id: string
    user_id: string
    date: string
    type: $Enums.BookingExceptionType
    start_time?: Date | string | null
    end_time?: Date | string | null
    slot_duration_minutes?: number | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingExceptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingExceptionTypeFieldUpdateOperationsInput | $Enums.BookingExceptionType
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slot_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingExceptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingExceptionTypeFieldUpdateOperationsInput | $Enums.BookingExceptionType
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slot_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAvailabilityRuleCreateInput = {
    id: string
    type: $Enums.UnitAvailabilityRuleType
    weekday?: number | null
    date?: string | null
    start_time: string
    end_time: string
    slot_duration_minutes: number
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutUnit_availability_rulesInput
  }

  export type UnitAvailabilityRuleUncheckedCreateInput = {
    id: string
    unit_id: string
    type: $Enums.UnitAvailabilityRuleType
    weekday?: number | null
    date?: string | null
    start_time: string
    end_time: string
    slot_duration_minutes: number
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAvailabilityRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumUnitAvailabilityRuleTypeFieldUpdateOperationsInput | $Enums.UnitAvailabilityRuleType
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    slot_duration_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutUnit_availability_rulesNestedInput
  }

  export type UnitAvailabilityRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    type?: EnumUnitAvailabilityRuleTypeFieldUpdateOperationsInput | $Enums.UnitAvailabilityRuleType
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    slot_duration_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAvailabilityRuleCreateManyInput = {
    id: string
    unit_id: string
    type: $Enums.UnitAvailabilityRuleType
    weekday?: number | null
    date?: string | null
    start_time: string
    end_time: string
    slot_duration_minutes: number
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAvailabilityRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumUnitAvailabilityRuleTypeFieldUpdateOperationsInput | $Enums.UnitAvailabilityRuleType
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    slot_duration_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAvailabilityRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    type?: EnumUnitAvailabilityRuleTypeFieldUpdateOperationsInput | $Enums.UnitAvailabilityRuleType
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    slot_duration_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAvailabilityExceptionCreateInput = {
    id: string
    date: string
    type: $Enums.UnitAvailabilityExceptionType
    start_time?: string | null
    end_time?: string | null
    slot_duration_minutes?: number | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutUnit_availability_exceptionsInput
  }

  export type UnitAvailabilityExceptionUncheckedCreateInput = {
    id: string
    unit_id: string
    date: string
    type: $Enums.UnitAvailabilityExceptionType
    start_time?: string | null
    end_time?: string | null
    slot_duration_minutes?: number | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAvailabilityExceptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    type?: EnumUnitAvailabilityExceptionTypeFieldUpdateOperationsInput | $Enums.UnitAvailabilityExceptionType
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    slot_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutUnit_availability_exceptionsNestedInput
  }

  export type UnitAvailabilityExceptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    type?: EnumUnitAvailabilityExceptionTypeFieldUpdateOperationsInput | $Enums.UnitAvailabilityExceptionType
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    slot_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAvailabilityExceptionCreateManyInput = {
    id: string
    unit_id: string
    date: string
    type: $Enums.UnitAvailabilityExceptionType
    start_time?: string | null
    end_time?: string | null
    slot_duration_minutes?: number | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAvailabilityExceptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    type?: EnumUnitAvailabilityExceptionTypeFieldUpdateOperationsInput | $Enums.UnitAvailabilityExceptionType
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    slot_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAvailabilityExceptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    type?: EnumUnitAvailabilityExceptionTypeFieldUpdateOperationsInput | $Enums.UnitAvailabilityExceptionType
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    slot_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateInput = {
    id: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval: $Enums.RenewalInterval
    features: JsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    trial_days?: number | null
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval: $Enums.RenewalInterval
    features: JsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    trial_days?: number | null
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    features?: JsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    trial_days?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    features?: JsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    trial_days?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval: $Enums.RenewalInterval
    features: JsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    trial_days?: number | null
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    features?: JsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    trial_days?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    features?: JsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    trial_days?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutSubscription_recordInput
    user: UserCreateNestedOneWithoutSubscriptionsInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    discount?: DiscountCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id: string
    unit_id: string
    user_id: string
    plan_id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    discount_id?: string | null
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutSubscription_recordNestedInput
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    discount?: DiscountUpdateOneWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    discount_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id: string
    unit_id: string
    user_id: string
    plan_id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    discount_id?: string | null
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    discount_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    line_items: JsonNullValueInput | InputJsonValue
    due_date: Date | string
    paid_at?: Date | string | null
    provider_invoice_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutInvoicesInput
    subscription: SubscriptionCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id: string
    user_id: string
    subscription_id: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    line_items: JsonNullValueInput | InputJsonValue
    due_date: Date | string
    paid_at?: Date | string | null
    provider_invoice_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    line_items?: JsonNullValueInput | InputJsonValue
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    subscription_id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    line_items?: JsonNullValueInput | InputJsonValue
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id: string
    user_id: string
    subscription_id: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    line_items: JsonNullValueInput | InputJsonValue
    due_date: Date | string
    paid_at?: Date | string | null
    provider_invoice_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    line_items?: JsonNullValueInput | InputJsonValue
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    subscription_id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    line_items?: JsonNullValueInput | InputJsonValue
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountCreateInput = {
    id: string
    code: string
    type: $Enums.DiscountType
    value: number
    duration: $Enums.DiscountDuration
    repeating_count?: number | null
    assigned_to_user_id?: string | null
    max_redemptions?: number | null
    redemptions_count?: number
    expires_at?: Date | string | null
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    subscriptions?: SubscriptionCreateNestedManyWithoutDiscountInput
  }

  export type DiscountUncheckedCreateInput = {
    id: string
    code: string
    type: $Enums.DiscountType
    value: number
    duration: $Enums.DiscountDuration
    repeating_count?: number | null
    assigned_to_user_id?: string | null
    max_redemptions?: number | null
    redemptions_count?: number
    expires_at?: Date | string | null
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutDiscountInput
  }

  export type DiscountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: IntFieldUpdateOperationsInput | number
    duration?: EnumDiscountDurationFieldUpdateOperationsInput | $Enums.DiscountDuration
    repeating_count?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_to_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    max_redemptions?: NullableIntFieldUpdateOperationsInput | number | null
    redemptions_count?: IntFieldUpdateOperationsInput | number
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: IntFieldUpdateOperationsInput | number
    duration?: EnumDiscountDurationFieldUpdateOperationsInput | $Enums.DiscountDuration
    repeating_count?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_to_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    max_redemptions?: NullableIntFieldUpdateOperationsInput | number | null
    redemptions_count?: IntFieldUpdateOperationsInput | number
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountCreateManyInput = {
    id: string
    code: string
    type: $Enums.DiscountType
    value: number
    duration: $Enums.DiscountDuration
    repeating_count?: number | null
    assigned_to_user_id?: string | null
    max_redemptions?: number | null
    redemptions_count?: number
    expires_at?: Date | string | null
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DiscountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: IntFieldUpdateOperationsInput | number
    duration?: EnumDiscountDurationFieldUpdateOperationsInput | $Enums.DiscountDuration
    repeating_count?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_to_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    max_redemptions?: NullableIntFieldUpdateOperationsInput | number | null
    redemptions_count?: IntFieldUpdateOperationsInput | number
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: IntFieldUpdateOperationsInput | number
    duration?: EnumDiscountDurationFieldUpdateOperationsInput | $Enums.DiscountDuration
    repeating_count?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_to_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    max_redemptions?: NullableIntFieldUpdateOperationsInput | number | null
    redemptions_count?: IntFieldUpdateOperationsInput | number
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionCreateInput = {
    id: string
    coupon_id: string
    redeemed_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutCoupon_redemptionsInput
    subscription: SubscriptionCreateNestedOneWithoutCoupon_redemptionsInput
  }

  export type CouponRedemptionUncheckedCreateInput = {
    id: string
    coupon_id: string
    user_id: string
    subscription_id: string
    redeemed_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CouponRedemptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coupon_id?: StringFieldUpdateOperationsInput | string
    redeemed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoupon_redemptionsNestedInput
    subscription?: SubscriptionUpdateOneRequiredWithoutCoupon_redemptionsNestedInput
  }

  export type CouponRedemptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coupon_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    subscription_id?: StringFieldUpdateOperationsInput | string
    redeemed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionCreateManyInput = {
    id: string
    coupon_id: string
    user_id: string
    subscription_id: string
    redeemed_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CouponRedemptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    coupon_id?: StringFieldUpdateOperationsInput | string
    redeemed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coupon_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    subscription_id?: StringFieldUpdateOperationsInput | string
    redeemed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id: string
    channel: $Enums.NotificationChannel
    payload: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    provider_id?: string | null
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id: string
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    template: NotificationTemplateCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id: string
    target_user_id: string
    channel: $Enums.NotificationChannel
    template_id: string
    payload: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    provider_id?: string | null
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id: string
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    payload?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    template?: NotificationTemplateUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_user_id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    template_id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id: string
    target_user_id: string
    channel: $Enums.NotificationChannel
    template_id: string
    payload: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    provider_id?: string | null
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id: string
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    payload?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_user_id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    template_id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTemplateCreateInput = {
    id: string
    name: string
    channel: $Enums.NotificationTemplateChannel
    subject?: string | null
    body_template: string
    title_template?: string | null
    variables?: NotificationTemplateCreatevariablesInput | string[]
    version?: number
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    notifications?: NotificationCreateNestedManyWithoutTemplateInput
  }

  export type NotificationTemplateUncheckedCreateInput = {
    id: string
    name: string
    channel: $Enums.NotificationTemplateChannel
    subject?: string | null
    body_template: string
    title_template?: string | null
    variables?: NotificationTemplateCreatevariablesInput | string[]
    version?: number
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type NotificationTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationTemplateChannelFieldUpdateOperationsInput | $Enums.NotificationTemplateChannel
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body_template?: StringFieldUpdateOperationsInput | string
    title_template?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutTemplateNestedInput
  }

  export type NotificationTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationTemplateChannelFieldUpdateOperationsInput | $Enums.NotificationTemplateChannel
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body_template?: StringFieldUpdateOperationsInput | string
    title_template?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type NotificationTemplateCreateManyInput = {
    id: string
    name: string
    channel: $Enums.NotificationTemplateChannel
    subject?: string | null
    body_template: string
    title_template?: string | null
    variables?: NotificationTemplateCreatevariablesInput | string[]
    version?: number
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationTemplateChannelFieldUpdateOperationsInput | $Enums.NotificationTemplateChannel
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body_template?: StringFieldUpdateOperationsInput | string
    title_template?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationTemplateChannelFieldUpdateOperationsInput | $Enums.NotificationTemplateChannel
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body_template?: StringFieldUpdateOperationsInput | string
    title_template?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateInput = {
    id: string
    category: $Enums.NotificationPreferenceCategory
    channels: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutNotification_prefsInput
  }

  export type NotificationPreferenceUncheckedCreateInput = {
    id: string
    user_id: string
    category: $Enums.NotificationPreferenceCategory
    channels: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumNotificationPreferenceCategoryFieldUpdateOperationsInput | $Enums.NotificationPreferenceCategory
    channels?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotification_prefsNestedInput
  }

  export type NotificationPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    category?: EnumNotificationPreferenceCategoryFieldUpdateOperationsInput | $Enums.NotificationPreferenceCategory
    channels?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceCreateManyInput = {
    id: string
    user_id: string
    category: $Enums.NotificationPreferenceCategory
    channels: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumNotificationPreferenceCategoryFieldUpdateOperationsInput | $Enums.NotificationPreferenceCategory
    channels?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    category?: EnumNotificationPreferenceCategoryFieldUpdateOperationsInput | $Enums.NotificationPreferenceCategory
    channels?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type OrganizationNullableScalarRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type BookingRuleListRelationFilter = {
    every?: BookingRuleWhereInput
    some?: BookingRuleWhereInput
    none?: BookingRuleWhereInput
  }

  export type BookingExceptionListRelationFilter = {
    every?: BookingExceptionWhereInput
    some?: BookingExceptionWhereInput
    none?: BookingExceptionWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type CouponRedemptionListRelationFilter = {
    every?: CouponRedemptionWhereInput
    some?: CouponRedemptionWhereInput
    none?: CouponRedemptionWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type NotificationPreferenceListRelationFilter = {
    every?: NotificationPreferenceWhereInput
    some?: NotificationPreferenceWhereInput
    none?: NotificationPreferenceWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingExceptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CouponRedemptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    provider_id?: SortOrder
    photo_url?: SortOrder
    onboarding_completed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    provider_id?: SortOrder
    photo_url?: SortOrder
    onboarding_completed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    provider_id?: SortOrder
    photo_url?: SortOrder
    onboarding_completed?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    owner_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    owner_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    owner_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type UnitSpecialtyListRelationFilter = {
    every?: UnitSpecialtyWhereInput
    some?: UnitSpecialtyWhereInput
    none?: UnitSpecialtyWhereInput
  }

  export type UnitServiceListRelationFilter = {
    every?: UnitServiceWhereInput
    some?: UnitServiceWhereInput
    none?: UnitServiceWhereInput
  }

  export type UnitAmenityListRelationFilter = {
    every?: UnitAmenityWhereInput
    some?: UnitAmenityWhereInput
    none?: UnitAmenityWhereInput
  }

  export type UnitAvailabilityRuleListRelationFilter = {
    every?: UnitAvailabilityRuleWhereInput
    some?: UnitAvailabilityRuleWhereInput
    none?: UnitAvailabilityRuleWhereInput
  }

  export type UnitAvailabilityExceptionListRelationFilter = {
    every?: UnitAvailabilityExceptionWhereInput
    some?: UnitAvailabilityExceptionWhereInput
    none?: UnitAvailabilityExceptionWhereInput
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type UnitSpecialtyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitAmenityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitAvailabilityRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitAvailabilityExceptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    brand_color?: SortOrder
    logo?: SortOrder
    gallery?: SortOrder
    is_active?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    especialidades?: SortOrder
    services?: SortOrder
    service_type?: SortOrder
    amenities?: SortOrder
    subscription?: SortOrder
    working_hours?: SortOrder
    lunch_break?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    brand_color?: SortOrder
    logo?: SortOrder
    is_active?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrder
    service_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    organization_id?: SortOrder
    name?: SortOrder
    brand_color?: SortOrder
    logo?: SortOrder
    is_active?: SortOrder
    whatsapp?: SortOrder
    phone?: SortOrder
    service_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecialtyCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SpecialtyMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SpecialtyMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AmenityCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AmenityMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SpecialtyScalarRelationFilter = {
    is?: SpecialtyWhereInput
    isNot?: SpecialtyWhereInput
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    specialty_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    default_duration_minutes?: SortOrder
    default_price_cents?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    default_duration_minutes?: SortOrder
    default_price_cents?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    specialty_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    default_duration_minutes?: SortOrder
    default_price_cents?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    specialty_id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    default_duration_minutes?: SortOrder
    default_price_cents?: SortOrder
    is_predefined?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    default_duration_minutes?: SortOrder
    default_price_cents?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UnitScalarRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type UnitSpecialtyUnit_idSpecialty_idCompoundUniqueInput = {
    unit_id: string
    specialty_id: string
  }

  export type UnitSpecialtyCountOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    specialty_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitSpecialtyMaxOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    specialty_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitSpecialtyMinOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    specialty_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AmenityScalarRelationFilter = {
    is?: AmenityWhereInput
    isNot?: AmenityWhereInput
  }

  export type UnitAmenityUnit_idAmenity_idCompoundUniqueInput = {
    unit_id: string
    amenity_id: string
  }

  export type UnitAmenityCountOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    amenity_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitAmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    amenity_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitAmenityMinOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    amenity_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type UnitServiceUnit_idService_idCompoundUniqueInput = {
    unit_id: string
    service_id: string
  }

  export type UnitServiceCountOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    service_id?: SortOrder
    custom_price_cents?: SortOrder
    custom_duration_minutes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitServiceAvgOrderByAggregateInput = {
    custom_price_cents?: SortOrder
    custom_duration_minutes?: SortOrder
  }

  export type UnitServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    service_id?: SortOrder
    custom_price_cents?: SortOrder
    custom_duration_minutes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitServiceMinOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    service_id?: SortOrder
    custom_price_cents?: SortOrder
    custom_duration_minutes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitServiceSumOrderByAggregateInput = {
    custom_price_cents?: SortOrder
    custom_duration_minutes?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type ServiceNullableScalarRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_id?: SortOrder
    unit_id?: SortOrder
    service_id?: SortOrder
    price_cents?: SortOrder
    notes?: SortOrder
    start_at?: SortOrder
    end_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    price_cents?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_id?: SortOrder
    unit_id?: SortOrder
    service_id?: SortOrder
    price_cents?: SortOrder
    notes?: SortOrder
    start_at?: SortOrder
    end_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    client_id?: SortOrder
    unit_id?: SortOrder
    service_id?: SortOrder
    price_cents?: SortOrder
    notes?: SortOrder
    start_at?: SortOrder
    end_at?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    price_cents?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type CustomerUser_idUnit_idCompoundUniqueInput = {
    user_id: string
    unit_id: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    unit_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    unit_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    unit_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumBookingRuleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingRuleType | EnumBookingRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingRuleType[] | ListEnumBookingRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingRuleType[] | ListEnumBookingRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingRuleTypeFilter<$PrismaModel> | $Enums.BookingRuleType
  }

  export type BookingRuleCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    weekday?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    min_advance_minutes?: SortOrder
    max_duration_minutes?: SortOrder
    max_bookings_per_day?: SortOrder
    max_bookings_per_client_per_day?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingRuleAvgOrderByAggregateInput = {
    weekday?: SortOrder
    slot_duration_minutes?: SortOrder
    min_advance_minutes?: SortOrder
    max_duration_minutes?: SortOrder
    max_bookings_per_day?: SortOrder
    max_bookings_per_client_per_day?: SortOrder
  }

  export type BookingRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    weekday?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    min_advance_minutes?: SortOrder
    max_duration_minutes?: SortOrder
    max_bookings_per_day?: SortOrder
    max_bookings_per_client_per_day?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingRuleMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    type?: SortOrder
    weekday?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    min_advance_minutes?: SortOrder
    max_duration_minutes?: SortOrder
    max_bookings_per_day?: SortOrder
    max_bookings_per_client_per_day?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingRuleSumOrderByAggregateInput = {
    weekday?: SortOrder
    slot_duration_minutes?: SortOrder
    min_advance_minutes?: SortOrder
    max_duration_minutes?: SortOrder
    max_bookings_per_day?: SortOrder
    max_bookings_per_client_per_day?: SortOrder
  }

  export type EnumBookingRuleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingRuleType | EnumBookingRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingRuleType[] | ListEnumBookingRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingRuleType[] | ListEnumBookingRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingRuleTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookingRuleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingRuleTypeFilter<$PrismaModel>
    _max?: NestedEnumBookingRuleTypeFilter<$PrismaModel>
  }

  export type EnumBookingExceptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingExceptionType | EnumBookingExceptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingExceptionType[] | ListEnumBookingExceptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingExceptionType[] | ListEnumBookingExceptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingExceptionTypeFilter<$PrismaModel> | $Enums.BookingExceptionType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BookingExceptionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingExceptionAvgOrderByAggregateInput = {
    slot_duration_minutes?: SortOrder
  }

  export type BookingExceptionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingExceptionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BookingExceptionSumOrderByAggregateInput = {
    slot_duration_minutes?: SortOrder
  }

  export type EnumBookingExceptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingExceptionType | EnumBookingExceptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingExceptionType[] | ListEnumBookingExceptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingExceptionType[] | ListEnumBookingExceptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingExceptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookingExceptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingExceptionTypeFilter<$PrismaModel>
    _max?: NestedEnumBookingExceptionTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUnitAvailabilityRuleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitAvailabilityRuleType | EnumUnitAvailabilityRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UnitAvailabilityRuleType[] | ListEnumUnitAvailabilityRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitAvailabilityRuleType[] | ListEnumUnitAvailabilityRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitAvailabilityRuleTypeFilter<$PrismaModel> | $Enums.UnitAvailabilityRuleType
  }

  export type UnitAvailabilityRuleCountOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    type?: SortOrder
    weekday?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    is_active?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitAvailabilityRuleAvgOrderByAggregateInput = {
    weekday?: SortOrder
    slot_duration_minutes?: SortOrder
  }

  export type UnitAvailabilityRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    type?: SortOrder
    weekday?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitAvailabilityRuleMinOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    type?: SortOrder
    weekday?: SortOrder
    date?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitAvailabilityRuleSumOrderByAggregateInput = {
    weekday?: SortOrder
    slot_duration_minutes?: SortOrder
  }

  export type EnumUnitAvailabilityRuleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitAvailabilityRuleType | EnumUnitAvailabilityRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UnitAvailabilityRuleType[] | ListEnumUnitAvailabilityRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitAvailabilityRuleType[] | ListEnumUnitAvailabilityRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitAvailabilityRuleTypeWithAggregatesFilter<$PrismaModel> | $Enums.UnitAvailabilityRuleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitAvailabilityRuleTypeFilter<$PrismaModel>
    _max?: NestedEnumUnitAvailabilityRuleTypeFilter<$PrismaModel>
  }

  export type EnumUnitAvailabilityExceptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitAvailabilityExceptionType | EnumUnitAvailabilityExceptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UnitAvailabilityExceptionType[] | ListEnumUnitAvailabilityExceptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitAvailabilityExceptionType[] | ListEnumUnitAvailabilityExceptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitAvailabilityExceptionTypeFilter<$PrismaModel> | $Enums.UnitAvailabilityExceptionType
  }

  export type UnitAvailabilityExceptionCountOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitAvailabilityExceptionAvgOrderByAggregateInput = {
    slot_duration_minutes?: SortOrder
  }

  export type UnitAvailabilityExceptionMaxOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitAvailabilityExceptionMinOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    slot_duration_minutes?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UnitAvailabilityExceptionSumOrderByAggregateInput = {
    slot_duration_minutes?: SortOrder
  }

  export type EnumUnitAvailabilityExceptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitAvailabilityExceptionType | EnumUnitAvailabilityExceptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UnitAvailabilityExceptionType[] | ListEnumUnitAvailabilityExceptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitAvailabilityExceptionType[] | ListEnumUnitAvailabilityExceptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitAvailabilityExceptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.UnitAvailabilityExceptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitAvailabilityExceptionTypeFilter<$PrismaModel>
    _max?: NestedEnumUnitAvailabilityExceptionTypeFilter<$PrismaModel>
  }

  export type EnumRenewalIntervalFilter<$PrismaModel = never> = {
    equals?: $Enums.RenewalInterval | EnumRenewalIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.RenewalInterval[] | ListEnumRenewalIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.RenewalInterval[] | ListEnumRenewalIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumRenewalIntervalFilter<$PrismaModel> | $Enums.RenewalInterval
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    features?: SortOrder
    limits?: SortOrder
    trial_days?: SortOrder
    is_active?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    price?: SortOrder
    trial_days?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    trial_days?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    trial_days?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    price?: SortOrder
    trial_days?: SortOrder
  }

  export type EnumRenewalIntervalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RenewalInterval | EnumRenewalIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.RenewalInterval[] | ListEnumRenewalIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.RenewalInterval[] | ListEnumRenewalIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumRenewalIntervalWithAggregatesFilter<$PrismaModel> | $Enums.RenewalInterval
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRenewalIntervalFilter<$PrismaModel>
    _max?: NestedEnumRenewalIntervalFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type PlanScalarRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type DiscountNullableScalarRelationFilter = {
    is?: DiscountWhereInput | null
    isNot?: DiscountWhereInput | null
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    status?: SortOrder
    start_date?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    canceled_at?: SortOrder
    trial_end?: SortOrder
    renewal_interval?: SortOrder
    discount_id?: SortOrder
    provider_subscription_id?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    status?: SortOrder
    start_date?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    canceled_at?: SortOrder
    trial_end?: SortOrder
    renewal_interval?: SortOrder
    discount_id?: SortOrder
    provider_subscription_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    unit_id?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    status?: SortOrder
    start_date?: SortOrder
    current_period_start?: SortOrder
    current_period_end?: SortOrder
    cancel_at_period_end?: SortOrder
    canceled_at?: SortOrder
    trial_end?: SortOrder
    renewal_interval?: SortOrder
    discount_id?: SortOrder
    provider_subscription_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    line_items?: SortOrder
    due_date?: SortOrder
    paid_at?: SortOrder
    provider_invoice_id?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    paid_at?: SortOrder
    provider_invoice_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    due_date?: SortOrder
    paid_at?: SortOrder
    provider_invoice_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type EnumDiscountDurationFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountDuration | EnumDiscountDurationFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountDuration[] | ListEnumDiscountDurationFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountDuration[] | ListEnumDiscountDurationFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountDurationFilter<$PrismaModel> | $Enums.DiscountDuration
  }

  export type DiscountCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    value?: SortOrder
    duration?: SortOrder
    repeating_count?: SortOrder
    assigned_to_user_id?: SortOrder
    max_redemptions?: SortOrder
    redemptions_count?: SortOrder
    expires_at?: SortOrder
    is_active?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DiscountAvgOrderByAggregateInput = {
    value?: SortOrder
    repeating_count?: SortOrder
    max_redemptions?: SortOrder
    redemptions_count?: SortOrder
  }

  export type DiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    value?: SortOrder
    duration?: SortOrder
    repeating_count?: SortOrder
    assigned_to_user_id?: SortOrder
    max_redemptions?: SortOrder
    redemptions_count?: SortOrder
    expires_at?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DiscountMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    type?: SortOrder
    value?: SortOrder
    duration?: SortOrder
    repeating_count?: SortOrder
    assigned_to_user_id?: SortOrder
    max_redemptions?: SortOrder
    redemptions_count?: SortOrder
    expires_at?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DiscountSumOrderByAggregateInput = {
    value?: SortOrder
    repeating_count?: SortOrder
    max_redemptions?: SortOrder
    redemptions_count?: SortOrder
  }

  export type EnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type EnumDiscountDurationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountDuration | EnumDiscountDurationFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountDuration[] | ListEnumDiscountDurationFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountDuration[] | ListEnumDiscountDurationFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountDurationWithAggregatesFilter<$PrismaModel> | $Enums.DiscountDuration
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountDurationFilter<$PrismaModel>
    _max?: NestedEnumDiscountDurationFilter<$PrismaModel>
  }

  export type CouponRedemptionCountOrderByAggregateInput = {
    id?: SortOrder
    coupon_id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    redeemed_at?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CouponRedemptionMaxOrderByAggregateInput = {
    id?: SortOrder
    coupon_id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    redeemed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CouponRedemptionMinOrderByAggregateInput = {
    id?: SortOrder
    coupon_id?: SortOrder
    user_id?: SortOrder
    subscription_id?: SortOrder
    redeemed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumNotificationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelFilter<$PrismaModel> | $Enums.NotificationChannel
  }

  export type EnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NotificationTemplateScalarRelationFilter = {
    is?: NotificationTemplateWhereInput
    isNot?: NotificationTemplateWhereInput
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    target_user_id?: SortOrder
    channel?: SortOrder
    template_id?: SortOrder
    payload?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    provider_id?: SortOrder
    error_message?: SortOrder
    metadata?: SortOrder
    message_id?: SortOrder
    sent_at?: SortOrder
    delivered_at?: SortOrder
    read_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    target_user_id?: SortOrder
    channel?: SortOrder
    template_id?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    provider_id?: SortOrder
    error_message?: SortOrder
    message_id?: SortOrder
    sent_at?: SortOrder
    delivered_at?: SortOrder
    read_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    target_user_id?: SortOrder
    channel?: SortOrder
    template_id?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    provider_id?: SortOrder
    error_message?: SortOrder
    message_id?: SortOrder
    sent_at?: SortOrder
    delivered_at?: SortOrder
    read_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumNotificationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelFilter<$PrismaModel>
  }

  export type EnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTemplateChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationTemplateChannel | EnumNotificationTemplateChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationTemplateChannel[] | ListEnumNotificationTemplateChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationTemplateChannel[] | ListEnumNotificationTemplateChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTemplateChannelFilter<$PrismaModel> | $Enums.NotificationTemplateChannel
  }

  export type NotificationTemplateNameChannelCompoundUniqueInput = {
    name: string
    channel: $Enums.NotificationTemplateChannel
  }

  export type NotificationTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    channel?: SortOrder
    subject?: SortOrder
    body_template?: SortOrder
    title_template?: SortOrder
    variables?: SortOrder
    version?: SortOrder
    is_active?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type NotificationTemplateAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type NotificationTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    channel?: SortOrder
    subject?: SortOrder
    body_template?: SortOrder
    title_template?: SortOrder
    version?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type NotificationTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    channel?: SortOrder
    subject?: SortOrder
    body_template?: SortOrder
    title_template?: SortOrder
    version?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type NotificationTemplateSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumNotificationTemplateChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationTemplateChannel | EnumNotificationTemplateChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationTemplateChannel[] | ListEnumNotificationTemplateChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationTemplateChannel[] | ListEnumNotificationTemplateChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTemplateChannelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationTemplateChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTemplateChannelFilter<$PrismaModel>
    _max?: NestedEnumNotificationTemplateChannelFilter<$PrismaModel>
  }

  export type EnumNotificationPreferenceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPreferenceCategory | EnumNotificationPreferenceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPreferenceCategory[] | ListEnumNotificationPreferenceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPreferenceCategory[] | ListEnumNotificationPreferenceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPreferenceCategoryFilter<$PrismaModel> | $Enums.NotificationPreferenceCategory
  }

  export type NotificationPreferenceUser_idCategoryCompoundUniqueInput = {
    user_id: string
    category: $Enums.NotificationPreferenceCategory
  }

  export type NotificationPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    category?: SortOrder
    channels?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type NotificationPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type NotificationPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    category?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumNotificationPreferenceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPreferenceCategory | EnumNotificationPreferenceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPreferenceCategory[] | ListEnumNotificationPreferenceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPreferenceCategory[] | ListEnumNotificationPreferenceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPreferenceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPreferenceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPreferenceCategoryFilter<$PrismaModel>
    _max?: NestedEnumNotificationPreferenceCategoryFilter<$PrismaModel>
  }

  export type OrganizationCreateNestedOneWithoutOwnerInput = {
    create?: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOwnerInput
    connect?: OrganizationWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput> | BookingCreateWithoutOwnerInput[] | BookingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOwnerInput | BookingCreateOrConnectWithoutOwnerInput[]
    createMany?: BookingCreateManyOwnerInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutClientInput = {
    create?: XOR<BookingCreateWithoutClientInput, BookingUncheckedCreateWithoutClientInput> | BookingCreateWithoutClientInput[] | BookingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutClientInput | BookingCreateOrConnectWithoutClientInput[]
    createMany?: BookingCreateManyClientInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingRuleCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingRuleCreateWithoutUserInput, BookingRuleUncheckedCreateWithoutUserInput> | BookingRuleCreateWithoutUserInput[] | BookingRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingRuleCreateOrConnectWithoutUserInput | BookingRuleCreateOrConnectWithoutUserInput[]
    createMany?: BookingRuleCreateManyUserInputEnvelope
    connect?: BookingRuleWhereUniqueInput | BookingRuleWhereUniqueInput[]
  }

  export type BookingExceptionCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingExceptionCreateWithoutUserInput, BookingExceptionUncheckedCreateWithoutUserInput> | BookingExceptionCreateWithoutUserInput[] | BookingExceptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingExceptionCreateOrConnectWithoutUserInput | BookingExceptionCreateOrConnectWithoutUserInput[]
    createMany?: BookingExceptionCreateManyUserInputEnvelope
    connect?: BookingExceptionWhereUniqueInput | BookingExceptionWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CouponRedemptionCreateNestedManyWithoutUserInput = {
    create?: XOR<CouponRedemptionCreateWithoutUserInput, CouponRedemptionUncheckedCreateWithoutUserInput> | CouponRedemptionCreateWithoutUserInput[] | CouponRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutUserInput | CouponRedemptionCreateOrConnectWithoutUserInput[]
    createMany?: CouponRedemptionCreateManyUserInputEnvelope
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationPreferenceCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutUserInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput> | CustomerCreateWithoutUserInput[] | CustomerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput | CustomerCreateOrConnectWithoutUserInput[]
    createMany?: CustomerCreateManyUserInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type OrganizationUncheckedCreateNestedOneWithoutOwnerInput = {
    create?: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOwnerInput
    connect?: OrganizationWhereUniqueInput
  }

  export type BookingUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput> | BookingCreateWithoutOwnerInput[] | BookingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOwnerInput | BookingCreateOrConnectWithoutOwnerInput[]
    createMany?: BookingCreateManyOwnerInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<BookingCreateWithoutClientInput, BookingUncheckedCreateWithoutClientInput> | BookingCreateWithoutClientInput[] | BookingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutClientInput | BookingCreateOrConnectWithoutClientInput[]
    createMany?: BookingCreateManyClientInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingRuleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingRuleCreateWithoutUserInput, BookingRuleUncheckedCreateWithoutUserInput> | BookingRuleCreateWithoutUserInput[] | BookingRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingRuleCreateOrConnectWithoutUserInput | BookingRuleCreateOrConnectWithoutUserInput[]
    createMany?: BookingRuleCreateManyUserInputEnvelope
    connect?: BookingRuleWhereUniqueInput | BookingRuleWhereUniqueInput[]
  }

  export type BookingExceptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingExceptionCreateWithoutUserInput, BookingExceptionUncheckedCreateWithoutUserInput> | BookingExceptionCreateWithoutUserInput[] | BookingExceptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingExceptionCreateOrConnectWithoutUserInput | BookingExceptionCreateOrConnectWithoutUserInput[]
    createMany?: BookingExceptionCreateManyUserInputEnvelope
    connect?: BookingExceptionWhereUniqueInput | BookingExceptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CouponRedemptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CouponRedemptionCreateWithoutUserInput, CouponRedemptionUncheckedCreateWithoutUserInput> | CouponRedemptionCreateWithoutUserInput[] | CouponRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutUserInput | CouponRedemptionCreateOrConnectWithoutUserInput[]
    createMany?: CouponRedemptionCreateManyUserInputEnvelope
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput> | CustomerCreateWithoutUserInput[] | CustomerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput | CustomerCreateOrConnectWithoutUserInput[]
    createMany?: CustomerCreateManyUserInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OrganizationUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOwnerInput
    upsert?: OrganizationUpsertWithoutOwnerInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutOwnerInput, OrganizationUpdateWithoutOwnerInput>, OrganizationUncheckedUpdateWithoutOwnerInput>
  }

  export type BookingUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput> | BookingCreateWithoutOwnerInput[] | BookingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOwnerInput | BookingCreateOrConnectWithoutOwnerInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutOwnerInput | BookingUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BookingCreateManyOwnerInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutOwnerInput | BookingUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutOwnerInput | BookingUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutClientNestedInput = {
    create?: XOR<BookingCreateWithoutClientInput, BookingUncheckedCreateWithoutClientInput> | BookingCreateWithoutClientInput[] | BookingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutClientInput | BookingCreateOrConnectWithoutClientInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutClientInput | BookingUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: BookingCreateManyClientInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutClientInput | BookingUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutClientInput | BookingUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingRuleUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingRuleCreateWithoutUserInput, BookingRuleUncheckedCreateWithoutUserInput> | BookingRuleCreateWithoutUserInput[] | BookingRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingRuleCreateOrConnectWithoutUserInput | BookingRuleCreateOrConnectWithoutUserInput[]
    upsert?: BookingRuleUpsertWithWhereUniqueWithoutUserInput | BookingRuleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingRuleCreateManyUserInputEnvelope
    set?: BookingRuleWhereUniqueInput | BookingRuleWhereUniqueInput[]
    disconnect?: BookingRuleWhereUniqueInput | BookingRuleWhereUniqueInput[]
    delete?: BookingRuleWhereUniqueInput | BookingRuleWhereUniqueInput[]
    connect?: BookingRuleWhereUniqueInput | BookingRuleWhereUniqueInput[]
    update?: BookingRuleUpdateWithWhereUniqueWithoutUserInput | BookingRuleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingRuleUpdateManyWithWhereWithoutUserInput | BookingRuleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingRuleScalarWhereInput | BookingRuleScalarWhereInput[]
  }

  export type BookingExceptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingExceptionCreateWithoutUserInput, BookingExceptionUncheckedCreateWithoutUserInput> | BookingExceptionCreateWithoutUserInput[] | BookingExceptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingExceptionCreateOrConnectWithoutUserInput | BookingExceptionCreateOrConnectWithoutUserInput[]
    upsert?: BookingExceptionUpsertWithWhereUniqueWithoutUserInput | BookingExceptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingExceptionCreateManyUserInputEnvelope
    set?: BookingExceptionWhereUniqueInput | BookingExceptionWhereUniqueInput[]
    disconnect?: BookingExceptionWhereUniqueInput | BookingExceptionWhereUniqueInput[]
    delete?: BookingExceptionWhereUniqueInput | BookingExceptionWhereUniqueInput[]
    connect?: BookingExceptionWhereUniqueInput | BookingExceptionWhereUniqueInput[]
    update?: BookingExceptionUpdateWithWhereUniqueWithoutUserInput | BookingExceptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingExceptionUpdateManyWithWhereWithoutUserInput | BookingExceptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingExceptionScalarWhereInput | BookingExceptionScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CouponRedemptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CouponRedemptionCreateWithoutUserInput, CouponRedemptionUncheckedCreateWithoutUserInput> | CouponRedemptionCreateWithoutUserInput[] | CouponRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutUserInput | CouponRedemptionCreateOrConnectWithoutUserInput[]
    upsert?: CouponRedemptionUpsertWithWhereUniqueWithoutUserInput | CouponRedemptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CouponRedemptionCreateManyUserInputEnvelope
    set?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    disconnect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    delete?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    update?: CouponRedemptionUpdateWithWhereUniqueWithoutUserInput | CouponRedemptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CouponRedemptionUpdateManyWithWhereWithoutUserInput | CouponRedemptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationPreferenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput | NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    set?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    disconnect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    delete?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    update?: NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput | NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationPreferenceUpdateManyWithWhereWithoutUserInput | NotificationPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutUserNestedInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput> | CustomerCreateWithoutUserInput[] | CustomerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput | CustomerCreateOrConnectWithoutUserInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutUserInput | CustomerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CustomerCreateManyUserInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutUserInput | CustomerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutUserInput | CustomerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type OrganizationUncheckedUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutOwnerInput
    upsert?: OrganizationUpsertWithoutOwnerInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutOwnerInput, OrganizationUpdateWithoutOwnerInput>, OrganizationUncheckedUpdateWithoutOwnerInput>
  }

  export type BookingUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput> | BookingCreateWithoutOwnerInput[] | BookingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOwnerInput | BookingCreateOrConnectWithoutOwnerInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutOwnerInput | BookingUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BookingCreateManyOwnerInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutOwnerInput | BookingUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutOwnerInput | BookingUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<BookingCreateWithoutClientInput, BookingUncheckedCreateWithoutClientInput> | BookingCreateWithoutClientInput[] | BookingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutClientInput | BookingCreateOrConnectWithoutClientInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutClientInput | BookingUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: BookingCreateManyClientInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutClientInput | BookingUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutClientInput | BookingUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingRuleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingRuleCreateWithoutUserInput, BookingRuleUncheckedCreateWithoutUserInput> | BookingRuleCreateWithoutUserInput[] | BookingRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingRuleCreateOrConnectWithoutUserInput | BookingRuleCreateOrConnectWithoutUserInput[]
    upsert?: BookingRuleUpsertWithWhereUniqueWithoutUserInput | BookingRuleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingRuleCreateManyUserInputEnvelope
    set?: BookingRuleWhereUniqueInput | BookingRuleWhereUniqueInput[]
    disconnect?: BookingRuleWhereUniqueInput | BookingRuleWhereUniqueInput[]
    delete?: BookingRuleWhereUniqueInput | BookingRuleWhereUniqueInput[]
    connect?: BookingRuleWhereUniqueInput | BookingRuleWhereUniqueInput[]
    update?: BookingRuleUpdateWithWhereUniqueWithoutUserInput | BookingRuleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingRuleUpdateManyWithWhereWithoutUserInput | BookingRuleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingRuleScalarWhereInput | BookingRuleScalarWhereInput[]
  }

  export type BookingExceptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingExceptionCreateWithoutUserInput, BookingExceptionUncheckedCreateWithoutUserInput> | BookingExceptionCreateWithoutUserInput[] | BookingExceptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingExceptionCreateOrConnectWithoutUserInput | BookingExceptionCreateOrConnectWithoutUserInput[]
    upsert?: BookingExceptionUpsertWithWhereUniqueWithoutUserInput | BookingExceptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingExceptionCreateManyUserInputEnvelope
    set?: BookingExceptionWhereUniqueInput | BookingExceptionWhereUniqueInput[]
    disconnect?: BookingExceptionWhereUniqueInput | BookingExceptionWhereUniqueInput[]
    delete?: BookingExceptionWhereUniqueInput | BookingExceptionWhereUniqueInput[]
    connect?: BookingExceptionWhereUniqueInput | BookingExceptionWhereUniqueInput[]
    update?: BookingExceptionUpdateWithWhereUniqueWithoutUserInput | BookingExceptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingExceptionUpdateManyWithWhereWithoutUserInput | BookingExceptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingExceptionScalarWhereInput | BookingExceptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CouponRedemptionCreateWithoutUserInput, CouponRedemptionUncheckedCreateWithoutUserInput> | CouponRedemptionCreateWithoutUserInput[] | CouponRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutUserInput | CouponRedemptionCreateOrConnectWithoutUserInput[]
    upsert?: CouponRedemptionUpsertWithWhereUniqueWithoutUserInput | CouponRedemptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CouponRedemptionCreateManyUserInputEnvelope
    set?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    disconnect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    delete?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    update?: CouponRedemptionUpdateWithWhereUniqueWithoutUserInput | CouponRedemptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CouponRedemptionUpdateManyWithWhereWithoutUserInput | CouponRedemptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput> | NotificationPreferenceCreateWithoutUserInput[] | NotificationPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationPreferenceCreateOrConnectWithoutUserInput | NotificationPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput | NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationPreferenceCreateManyUserInputEnvelope
    set?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    disconnect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    delete?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    connect?: NotificationPreferenceWhereUniqueInput | NotificationPreferenceWhereUniqueInput[]
    update?: NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput | NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationPreferenceUpdateManyWithWhereWithoutUserInput | NotificationPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput> | CustomerCreateWithoutUserInput[] | CustomerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutUserInput | CustomerCreateOrConnectWithoutUserInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutUserInput | CustomerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CustomerCreateManyUserInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutUserInput | CustomerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutUserInput | CustomerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput
    connect?: UserWhereUniqueInput
  }

  export type UnitCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UnitCreateWithoutOrganizationInput, UnitUncheckedCreateWithoutOrganizationInput> | UnitCreateWithoutOrganizationInput[] | UnitUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOrganizationInput | UnitCreateOrConnectWithoutOrganizationInput[]
    createMany?: UnitCreateManyOrganizationInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UnitCreateWithoutOrganizationInput, UnitUncheckedCreateWithoutOrganizationInput> | UnitCreateWithoutOrganizationInput[] | UnitUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOrganizationInput | UnitCreateOrConnectWithoutOrganizationInput[]
    createMany?: UnitCreateManyOrganizationInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput
    upsert?: UserUpsertWithoutOrganizationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganizationInput, UserUpdateWithoutOrganizationInput>, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UnitUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UnitCreateWithoutOrganizationInput, UnitUncheckedCreateWithoutOrganizationInput> | UnitCreateWithoutOrganizationInput[] | UnitUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOrganizationInput | UnitCreateOrConnectWithoutOrganizationInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutOrganizationInput | UnitUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UnitCreateManyOrganizationInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutOrganizationInput | UnitUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutOrganizationInput | UnitUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UnitCreateWithoutOrganizationInput, UnitUncheckedCreateWithoutOrganizationInput> | UnitCreateWithoutOrganizationInput[] | UnitUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutOrganizationInput | UnitCreateOrConnectWithoutOrganizationInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutOrganizationInput | UnitUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UnitCreateManyOrganizationInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutOrganizationInput | UnitUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutOrganizationInput | UnitUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type UnitCreategalleryInput = {
    set: string[]
  }

  export type UnitCreateamenitiesInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutUnitsInput = {
    create?: XOR<OrganizationCreateWithoutUnitsInput, OrganizationUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUnitsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UnitSpecialtyCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitSpecialtyCreateWithoutUnitInput, UnitSpecialtyUncheckedCreateWithoutUnitInput> | UnitSpecialtyCreateWithoutUnitInput[] | UnitSpecialtyUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitSpecialtyCreateOrConnectWithoutUnitInput | UnitSpecialtyCreateOrConnectWithoutUnitInput[]
    createMany?: UnitSpecialtyCreateManyUnitInputEnvelope
    connect?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
  }

  export type UnitServiceCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitServiceCreateWithoutUnitInput, UnitServiceUncheckedCreateWithoutUnitInput> | UnitServiceCreateWithoutUnitInput[] | UnitServiceUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitServiceCreateOrConnectWithoutUnitInput | UnitServiceCreateOrConnectWithoutUnitInput[]
    createMany?: UnitServiceCreateManyUnitInputEnvelope
    connect?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
  }

  export type UnitAmenityCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitAmenityCreateWithoutUnitInput, UnitAmenityUncheckedCreateWithoutUnitInput> | UnitAmenityCreateWithoutUnitInput[] | UnitAmenityUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAmenityCreateOrConnectWithoutUnitInput | UnitAmenityCreateOrConnectWithoutUnitInput[]
    createMany?: UnitAmenityCreateManyUnitInputEnvelope
    connect?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
  }

  export type UnitAvailabilityRuleCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitAvailabilityRuleCreateWithoutUnitInput, UnitAvailabilityRuleUncheckedCreateWithoutUnitInput> | UnitAvailabilityRuleCreateWithoutUnitInput[] | UnitAvailabilityRuleUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAvailabilityRuleCreateOrConnectWithoutUnitInput | UnitAvailabilityRuleCreateOrConnectWithoutUnitInput[]
    createMany?: UnitAvailabilityRuleCreateManyUnitInputEnvelope
    connect?: UnitAvailabilityRuleWhereUniqueInput | UnitAvailabilityRuleWhereUniqueInput[]
  }

  export type UnitAvailabilityExceptionCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitAvailabilityExceptionCreateWithoutUnitInput, UnitAvailabilityExceptionUncheckedCreateWithoutUnitInput> | UnitAvailabilityExceptionCreateWithoutUnitInput[] | UnitAvailabilityExceptionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAvailabilityExceptionCreateOrConnectWithoutUnitInput | UnitAvailabilityExceptionCreateOrConnectWithoutUnitInput[]
    createMany?: UnitAvailabilityExceptionCreateManyUnitInputEnvelope
    connect?: UnitAvailabilityExceptionWhereUniqueInput | UnitAvailabilityExceptionWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutUnitInput = {
    create?: XOR<SubscriptionCreateWithoutUnitInput, SubscriptionUncheckedCreateWithoutUnitInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUnitInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutUnitInput = {
    create?: XOR<BookingCreateWithoutUnitInput, BookingUncheckedCreateWithoutUnitInput> | BookingCreateWithoutUnitInput[] | BookingUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUnitInput | BookingCreateOrConnectWithoutUnitInput[]
    createMany?: BookingCreateManyUnitInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutUnitInput = {
    create?: XOR<CustomerCreateWithoutUnitInput, CustomerUncheckedCreateWithoutUnitInput> | CustomerCreateWithoutUnitInput[] | CustomerUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutUnitInput | CustomerCreateOrConnectWithoutUnitInput[]
    createMany?: CustomerCreateManyUnitInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type UnitSpecialtyUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitSpecialtyCreateWithoutUnitInput, UnitSpecialtyUncheckedCreateWithoutUnitInput> | UnitSpecialtyCreateWithoutUnitInput[] | UnitSpecialtyUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitSpecialtyCreateOrConnectWithoutUnitInput | UnitSpecialtyCreateOrConnectWithoutUnitInput[]
    createMany?: UnitSpecialtyCreateManyUnitInputEnvelope
    connect?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
  }

  export type UnitServiceUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitServiceCreateWithoutUnitInput, UnitServiceUncheckedCreateWithoutUnitInput> | UnitServiceCreateWithoutUnitInput[] | UnitServiceUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitServiceCreateOrConnectWithoutUnitInput | UnitServiceCreateOrConnectWithoutUnitInput[]
    createMany?: UnitServiceCreateManyUnitInputEnvelope
    connect?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
  }

  export type UnitAmenityUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitAmenityCreateWithoutUnitInput, UnitAmenityUncheckedCreateWithoutUnitInput> | UnitAmenityCreateWithoutUnitInput[] | UnitAmenityUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAmenityCreateOrConnectWithoutUnitInput | UnitAmenityCreateOrConnectWithoutUnitInput[]
    createMany?: UnitAmenityCreateManyUnitInputEnvelope
    connect?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
  }

  export type UnitAvailabilityRuleUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitAvailabilityRuleCreateWithoutUnitInput, UnitAvailabilityRuleUncheckedCreateWithoutUnitInput> | UnitAvailabilityRuleCreateWithoutUnitInput[] | UnitAvailabilityRuleUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAvailabilityRuleCreateOrConnectWithoutUnitInput | UnitAvailabilityRuleCreateOrConnectWithoutUnitInput[]
    createMany?: UnitAvailabilityRuleCreateManyUnitInputEnvelope
    connect?: UnitAvailabilityRuleWhereUniqueInput | UnitAvailabilityRuleWhereUniqueInput[]
  }

  export type UnitAvailabilityExceptionUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<UnitAvailabilityExceptionCreateWithoutUnitInput, UnitAvailabilityExceptionUncheckedCreateWithoutUnitInput> | UnitAvailabilityExceptionCreateWithoutUnitInput[] | UnitAvailabilityExceptionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAvailabilityExceptionCreateOrConnectWithoutUnitInput | UnitAvailabilityExceptionCreateOrConnectWithoutUnitInput[]
    createMany?: UnitAvailabilityExceptionCreateManyUnitInputEnvelope
    connect?: UnitAvailabilityExceptionWhereUniqueInput | UnitAvailabilityExceptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutUnitInput = {
    create?: XOR<SubscriptionCreateWithoutUnitInput, SubscriptionUncheckedCreateWithoutUnitInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUnitInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type BookingUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<BookingCreateWithoutUnitInput, BookingUncheckedCreateWithoutUnitInput> | BookingCreateWithoutUnitInput[] | BookingUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUnitInput | BookingCreateOrConnectWithoutUnitInput[]
    createMany?: BookingCreateManyUnitInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<CustomerCreateWithoutUnitInput, CustomerUncheckedCreateWithoutUnitInput> | CustomerCreateWithoutUnitInput[] | CustomerUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutUnitInput | CustomerCreateOrConnectWithoutUnitInput[]
    createMany?: CustomerCreateManyUnitInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type UnitUpdategalleryInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumServiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ServiceType
  }

  export type UnitUpdateamenitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<OrganizationCreateWithoutUnitsInput, OrganizationUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUnitsInput
    upsert?: OrganizationUpsertWithoutUnitsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUnitsInput, OrganizationUpdateWithoutUnitsInput>, OrganizationUncheckedUpdateWithoutUnitsInput>
  }

  export type UnitSpecialtyUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitSpecialtyCreateWithoutUnitInput, UnitSpecialtyUncheckedCreateWithoutUnitInput> | UnitSpecialtyCreateWithoutUnitInput[] | UnitSpecialtyUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitSpecialtyCreateOrConnectWithoutUnitInput | UnitSpecialtyCreateOrConnectWithoutUnitInput[]
    upsert?: UnitSpecialtyUpsertWithWhereUniqueWithoutUnitInput | UnitSpecialtyUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitSpecialtyCreateManyUnitInputEnvelope
    set?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    disconnect?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    delete?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    connect?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    update?: UnitSpecialtyUpdateWithWhereUniqueWithoutUnitInput | UnitSpecialtyUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitSpecialtyUpdateManyWithWhereWithoutUnitInput | UnitSpecialtyUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitSpecialtyScalarWhereInput | UnitSpecialtyScalarWhereInput[]
  }

  export type UnitServiceUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitServiceCreateWithoutUnitInput, UnitServiceUncheckedCreateWithoutUnitInput> | UnitServiceCreateWithoutUnitInput[] | UnitServiceUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitServiceCreateOrConnectWithoutUnitInput | UnitServiceCreateOrConnectWithoutUnitInput[]
    upsert?: UnitServiceUpsertWithWhereUniqueWithoutUnitInput | UnitServiceUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitServiceCreateManyUnitInputEnvelope
    set?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    disconnect?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    delete?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    connect?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    update?: UnitServiceUpdateWithWhereUniqueWithoutUnitInput | UnitServiceUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitServiceUpdateManyWithWhereWithoutUnitInput | UnitServiceUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitServiceScalarWhereInput | UnitServiceScalarWhereInput[]
  }

  export type UnitAmenityUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitAmenityCreateWithoutUnitInput, UnitAmenityUncheckedCreateWithoutUnitInput> | UnitAmenityCreateWithoutUnitInput[] | UnitAmenityUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAmenityCreateOrConnectWithoutUnitInput | UnitAmenityCreateOrConnectWithoutUnitInput[]
    upsert?: UnitAmenityUpsertWithWhereUniqueWithoutUnitInput | UnitAmenityUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitAmenityCreateManyUnitInputEnvelope
    set?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    disconnect?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    delete?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    connect?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    update?: UnitAmenityUpdateWithWhereUniqueWithoutUnitInput | UnitAmenityUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitAmenityUpdateManyWithWhereWithoutUnitInput | UnitAmenityUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitAmenityScalarWhereInput | UnitAmenityScalarWhereInput[]
  }

  export type UnitAvailabilityRuleUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitAvailabilityRuleCreateWithoutUnitInput, UnitAvailabilityRuleUncheckedCreateWithoutUnitInput> | UnitAvailabilityRuleCreateWithoutUnitInput[] | UnitAvailabilityRuleUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAvailabilityRuleCreateOrConnectWithoutUnitInput | UnitAvailabilityRuleCreateOrConnectWithoutUnitInput[]
    upsert?: UnitAvailabilityRuleUpsertWithWhereUniqueWithoutUnitInput | UnitAvailabilityRuleUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitAvailabilityRuleCreateManyUnitInputEnvelope
    set?: UnitAvailabilityRuleWhereUniqueInput | UnitAvailabilityRuleWhereUniqueInput[]
    disconnect?: UnitAvailabilityRuleWhereUniqueInput | UnitAvailabilityRuleWhereUniqueInput[]
    delete?: UnitAvailabilityRuleWhereUniqueInput | UnitAvailabilityRuleWhereUniqueInput[]
    connect?: UnitAvailabilityRuleWhereUniqueInput | UnitAvailabilityRuleWhereUniqueInput[]
    update?: UnitAvailabilityRuleUpdateWithWhereUniqueWithoutUnitInput | UnitAvailabilityRuleUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitAvailabilityRuleUpdateManyWithWhereWithoutUnitInput | UnitAvailabilityRuleUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitAvailabilityRuleScalarWhereInput | UnitAvailabilityRuleScalarWhereInput[]
  }

  export type UnitAvailabilityExceptionUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitAvailabilityExceptionCreateWithoutUnitInput, UnitAvailabilityExceptionUncheckedCreateWithoutUnitInput> | UnitAvailabilityExceptionCreateWithoutUnitInput[] | UnitAvailabilityExceptionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAvailabilityExceptionCreateOrConnectWithoutUnitInput | UnitAvailabilityExceptionCreateOrConnectWithoutUnitInput[]
    upsert?: UnitAvailabilityExceptionUpsertWithWhereUniqueWithoutUnitInput | UnitAvailabilityExceptionUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitAvailabilityExceptionCreateManyUnitInputEnvelope
    set?: UnitAvailabilityExceptionWhereUniqueInput | UnitAvailabilityExceptionWhereUniqueInput[]
    disconnect?: UnitAvailabilityExceptionWhereUniqueInput | UnitAvailabilityExceptionWhereUniqueInput[]
    delete?: UnitAvailabilityExceptionWhereUniqueInput | UnitAvailabilityExceptionWhereUniqueInput[]
    connect?: UnitAvailabilityExceptionWhereUniqueInput | UnitAvailabilityExceptionWhereUniqueInput[]
    update?: UnitAvailabilityExceptionUpdateWithWhereUniqueWithoutUnitInput | UnitAvailabilityExceptionUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitAvailabilityExceptionUpdateManyWithWhereWithoutUnitInput | UnitAvailabilityExceptionUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitAvailabilityExceptionScalarWhereInput | UnitAvailabilityExceptionScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutUnitNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUnitInput, SubscriptionUncheckedCreateWithoutUnitInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUnitInput
    upsert?: SubscriptionUpsertWithoutUnitInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUnitInput, SubscriptionUpdateWithoutUnitInput>, SubscriptionUncheckedUpdateWithoutUnitInput>
  }

  export type BookingUpdateManyWithoutUnitNestedInput = {
    create?: XOR<BookingCreateWithoutUnitInput, BookingUncheckedCreateWithoutUnitInput> | BookingCreateWithoutUnitInput[] | BookingUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUnitInput | BookingCreateOrConnectWithoutUnitInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUnitInput | BookingUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: BookingCreateManyUnitInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUnitInput | BookingUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUnitInput | BookingUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutUnitNestedInput = {
    create?: XOR<CustomerCreateWithoutUnitInput, CustomerUncheckedCreateWithoutUnitInput> | CustomerCreateWithoutUnitInput[] | CustomerUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutUnitInput | CustomerCreateOrConnectWithoutUnitInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutUnitInput | CustomerUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: CustomerCreateManyUnitInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutUnitInput | CustomerUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutUnitInput | CustomerUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type UnitSpecialtyUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitSpecialtyCreateWithoutUnitInput, UnitSpecialtyUncheckedCreateWithoutUnitInput> | UnitSpecialtyCreateWithoutUnitInput[] | UnitSpecialtyUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitSpecialtyCreateOrConnectWithoutUnitInput | UnitSpecialtyCreateOrConnectWithoutUnitInput[]
    upsert?: UnitSpecialtyUpsertWithWhereUniqueWithoutUnitInput | UnitSpecialtyUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitSpecialtyCreateManyUnitInputEnvelope
    set?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    disconnect?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    delete?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    connect?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    update?: UnitSpecialtyUpdateWithWhereUniqueWithoutUnitInput | UnitSpecialtyUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitSpecialtyUpdateManyWithWhereWithoutUnitInput | UnitSpecialtyUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitSpecialtyScalarWhereInput | UnitSpecialtyScalarWhereInput[]
  }

  export type UnitServiceUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitServiceCreateWithoutUnitInput, UnitServiceUncheckedCreateWithoutUnitInput> | UnitServiceCreateWithoutUnitInput[] | UnitServiceUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitServiceCreateOrConnectWithoutUnitInput | UnitServiceCreateOrConnectWithoutUnitInput[]
    upsert?: UnitServiceUpsertWithWhereUniqueWithoutUnitInput | UnitServiceUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitServiceCreateManyUnitInputEnvelope
    set?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    disconnect?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    delete?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    connect?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    update?: UnitServiceUpdateWithWhereUniqueWithoutUnitInput | UnitServiceUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitServiceUpdateManyWithWhereWithoutUnitInput | UnitServiceUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitServiceScalarWhereInput | UnitServiceScalarWhereInput[]
  }

  export type UnitAmenityUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitAmenityCreateWithoutUnitInput, UnitAmenityUncheckedCreateWithoutUnitInput> | UnitAmenityCreateWithoutUnitInput[] | UnitAmenityUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAmenityCreateOrConnectWithoutUnitInput | UnitAmenityCreateOrConnectWithoutUnitInput[]
    upsert?: UnitAmenityUpsertWithWhereUniqueWithoutUnitInput | UnitAmenityUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitAmenityCreateManyUnitInputEnvelope
    set?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    disconnect?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    delete?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    connect?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    update?: UnitAmenityUpdateWithWhereUniqueWithoutUnitInput | UnitAmenityUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitAmenityUpdateManyWithWhereWithoutUnitInput | UnitAmenityUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitAmenityScalarWhereInput | UnitAmenityScalarWhereInput[]
  }

  export type UnitAvailabilityRuleUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitAvailabilityRuleCreateWithoutUnitInput, UnitAvailabilityRuleUncheckedCreateWithoutUnitInput> | UnitAvailabilityRuleCreateWithoutUnitInput[] | UnitAvailabilityRuleUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAvailabilityRuleCreateOrConnectWithoutUnitInput | UnitAvailabilityRuleCreateOrConnectWithoutUnitInput[]
    upsert?: UnitAvailabilityRuleUpsertWithWhereUniqueWithoutUnitInput | UnitAvailabilityRuleUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitAvailabilityRuleCreateManyUnitInputEnvelope
    set?: UnitAvailabilityRuleWhereUniqueInput | UnitAvailabilityRuleWhereUniqueInput[]
    disconnect?: UnitAvailabilityRuleWhereUniqueInput | UnitAvailabilityRuleWhereUniqueInput[]
    delete?: UnitAvailabilityRuleWhereUniqueInput | UnitAvailabilityRuleWhereUniqueInput[]
    connect?: UnitAvailabilityRuleWhereUniqueInput | UnitAvailabilityRuleWhereUniqueInput[]
    update?: UnitAvailabilityRuleUpdateWithWhereUniqueWithoutUnitInput | UnitAvailabilityRuleUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitAvailabilityRuleUpdateManyWithWhereWithoutUnitInput | UnitAvailabilityRuleUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitAvailabilityRuleScalarWhereInput | UnitAvailabilityRuleScalarWhereInput[]
  }

  export type UnitAvailabilityExceptionUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<UnitAvailabilityExceptionCreateWithoutUnitInput, UnitAvailabilityExceptionUncheckedCreateWithoutUnitInput> | UnitAvailabilityExceptionCreateWithoutUnitInput[] | UnitAvailabilityExceptionUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: UnitAvailabilityExceptionCreateOrConnectWithoutUnitInput | UnitAvailabilityExceptionCreateOrConnectWithoutUnitInput[]
    upsert?: UnitAvailabilityExceptionUpsertWithWhereUniqueWithoutUnitInput | UnitAvailabilityExceptionUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: UnitAvailabilityExceptionCreateManyUnitInputEnvelope
    set?: UnitAvailabilityExceptionWhereUniqueInput | UnitAvailabilityExceptionWhereUniqueInput[]
    disconnect?: UnitAvailabilityExceptionWhereUniqueInput | UnitAvailabilityExceptionWhereUniqueInput[]
    delete?: UnitAvailabilityExceptionWhereUniqueInput | UnitAvailabilityExceptionWhereUniqueInput[]
    connect?: UnitAvailabilityExceptionWhereUniqueInput | UnitAvailabilityExceptionWhereUniqueInput[]
    update?: UnitAvailabilityExceptionUpdateWithWhereUniqueWithoutUnitInput | UnitAvailabilityExceptionUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: UnitAvailabilityExceptionUpdateManyWithWhereWithoutUnitInput | UnitAvailabilityExceptionUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: UnitAvailabilityExceptionScalarWhereInput | UnitAvailabilityExceptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutUnitNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUnitInput, SubscriptionUncheckedCreateWithoutUnitInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUnitInput
    upsert?: SubscriptionUpsertWithoutUnitInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUnitInput, SubscriptionUpdateWithoutUnitInput>, SubscriptionUncheckedUpdateWithoutUnitInput>
  }

  export type BookingUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<BookingCreateWithoutUnitInput, BookingUncheckedCreateWithoutUnitInput> | BookingCreateWithoutUnitInput[] | BookingUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUnitInput | BookingCreateOrConnectWithoutUnitInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUnitInput | BookingUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: BookingCreateManyUnitInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUnitInput | BookingUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUnitInput | BookingUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<CustomerCreateWithoutUnitInput, CustomerUncheckedCreateWithoutUnitInput> | CustomerCreateWithoutUnitInput[] | CustomerUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutUnitInput | CustomerCreateOrConnectWithoutUnitInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutUnitInput | CustomerUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: CustomerCreateManyUnitInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutUnitInput | CustomerUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutUnitInput | CustomerUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type ServiceCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<ServiceCreateWithoutSpecialtyInput, ServiceUncheckedCreateWithoutSpecialtyInput> | ServiceCreateWithoutSpecialtyInput[] | ServiceUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutSpecialtyInput | ServiceCreateOrConnectWithoutSpecialtyInput[]
    createMany?: ServiceCreateManySpecialtyInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type UnitSpecialtyCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<UnitSpecialtyCreateWithoutSpecialtyInput, UnitSpecialtyUncheckedCreateWithoutSpecialtyInput> | UnitSpecialtyCreateWithoutSpecialtyInput[] | UnitSpecialtyUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: UnitSpecialtyCreateOrConnectWithoutSpecialtyInput | UnitSpecialtyCreateOrConnectWithoutSpecialtyInput[]
    createMany?: UnitSpecialtyCreateManySpecialtyInputEnvelope
    connect?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<ServiceCreateWithoutSpecialtyInput, ServiceUncheckedCreateWithoutSpecialtyInput> | ServiceCreateWithoutSpecialtyInput[] | ServiceUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutSpecialtyInput | ServiceCreateOrConnectWithoutSpecialtyInput[]
    createMany?: ServiceCreateManySpecialtyInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type UnitSpecialtyUncheckedCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<UnitSpecialtyCreateWithoutSpecialtyInput, UnitSpecialtyUncheckedCreateWithoutSpecialtyInput> | UnitSpecialtyCreateWithoutSpecialtyInput[] | UnitSpecialtyUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: UnitSpecialtyCreateOrConnectWithoutSpecialtyInput | UnitSpecialtyCreateOrConnectWithoutSpecialtyInput[]
    createMany?: UnitSpecialtyCreateManySpecialtyInputEnvelope
    connect?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<ServiceCreateWithoutSpecialtyInput, ServiceUncheckedCreateWithoutSpecialtyInput> | ServiceCreateWithoutSpecialtyInput[] | ServiceUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutSpecialtyInput | ServiceCreateOrConnectWithoutSpecialtyInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutSpecialtyInput | ServiceUpsertWithWhereUniqueWithoutSpecialtyInput[]
    createMany?: ServiceCreateManySpecialtyInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutSpecialtyInput | ServiceUpdateWithWhereUniqueWithoutSpecialtyInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutSpecialtyInput | ServiceUpdateManyWithWhereWithoutSpecialtyInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type UnitSpecialtyUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<UnitSpecialtyCreateWithoutSpecialtyInput, UnitSpecialtyUncheckedCreateWithoutSpecialtyInput> | UnitSpecialtyCreateWithoutSpecialtyInput[] | UnitSpecialtyUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: UnitSpecialtyCreateOrConnectWithoutSpecialtyInput | UnitSpecialtyCreateOrConnectWithoutSpecialtyInput[]
    upsert?: UnitSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput | UnitSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput[]
    createMany?: UnitSpecialtyCreateManySpecialtyInputEnvelope
    set?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    disconnect?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    delete?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    connect?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    update?: UnitSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput | UnitSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput[]
    updateMany?: UnitSpecialtyUpdateManyWithWhereWithoutSpecialtyInput | UnitSpecialtyUpdateManyWithWhereWithoutSpecialtyInput[]
    deleteMany?: UnitSpecialtyScalarWhereInput | UnitSpecialtyScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<ServiceCreateWithoutSpecialtyInput, ServiceUncheckedCreateWithoutSpecialtyInput> | ServiceCreateWithoutSpecialtyInput[] | ServiceUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutSpecialtyInput | ServiceCreateOrConnectWithoutSpecialtyInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutSpecialtyInput | ServiceUpsertWithWhereUniqueWithoutSpecialtyInput[]
    createMany?: ServiceCreateManySpecialtyInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutSpecialtyInput | ServiceUpdateWithWhereUniqueWithoutSpecialtyInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutSpecialtyInput | ServiceUpdateManyWithWhereWithoutSpecialtyInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type UnitSpecialtyUncheckedUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<UnitSpecialtyCreateWithoutSpecialtyInput, UnitSpecialtyUncheckedCreateWithoutSpecialtyInput> | UnitSpecialtyCreateWithoutSpecialtyInput[] | UnitSpecialtyUncheckedCreateWithoutSpecialtyInput[]
    connectOrCreate?: UnitSpecialtyCreateOrConnectWithoutSpecialtyInput | UnitSpecialtyCreateOrConnectWithoutSpecialtyInput[]
    upsert?: UnitSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput | UnitSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput[]
    createMany?: UnitSpecialtyCreateManySpecialtyInputEnvelope
    set?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    disconnect?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    delete?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    connect?: UnitSpecialtyWhereUniqueInput | UnitSpecialtyWhereUniqueInput[]
    update?: UnitSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput | UnitSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput[]
    updateMany?: UnitSpecialtyUpdateManyWithWhereWithoutSpecialtyInput | UnitSpecialtyUpdateManyWithWhereWithoutSpecialtyInput[]
    deleteMany?: UnitSpecialtyScalarWhereInput | UnitSpecialtyScalarWhereInput[]
  }

  export type UnitAmenityCreateNestedManyWithoutAmenityInput = {
    create?: XOR<UnitAmenityCreateWithoutAmenityInput, UnitAmenityUncheckedCreateWithoutAmenityInput> | UnitAmenityCreateWithoutAmenityInput[] | UnitAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: UnitAmenityCreateOrConnectWithoutAmenityInput | UnitAmenityCreateOrConnectWithoutAmenityInput[]
    createMany?: UnitAmenityCreateManyAmenityInputEnvelope
    connect?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
  }

  export type UnitAmenityUncheckedCreateNestedManyWithoutAmenityInput = {
    create?: XOR<UnitAmenityCreateWithoutAmenityInput, UnitAmenityUncheckedCreateWithoutAmenityInput> | UnitAmenityCreateWithoutAmenityInput[] | UnitAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: UnitAmenityCreateOrConnectWithoutAmenityInput | UnitAmenityCreateOrConnectWithoutAmenityInput[]
    createMany?: UnitAmenityCreateManyAmenityInputEnvelope
    connect?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
  }

  export type UnitAmenityUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<UnitAmenityCreateWithoutAmenityInput, UnitAmenityUncheckedCreateWithoutAmenityInput> | UnitAmenityCreateWithoutAmenityInput[] | UnitAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: UnitAmenityCreateOrConnectWithoutAmenityInput | UnitAmenityCreateOrConnectWithoutAmenityInput[]
    upsert?: UnitAmenityUpsertWithWhereUniqueWithoutAmenityInput | UnitAmenityUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: UnitAmenityCreateManyAmenityInputEnvelope
    set?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    disconnect?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    delete?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    connect?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    update?: UnitAmenityUpdateWithWhereUniqueWithoutAmenityInput | UnitAmenityUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: UnitAmenityUpdateManyWithWhereWithoutAmenityInput | UnitAmenityUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: UnitAmenityScalarWhereInput | UnitAmenityScalarWhereInput[]
  }

  export type UnitAmenityUncheckedUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<UnitAmenityCreateWithoutAmenityInput, UnitAmenityUncheckedCreateWithoutAmenityInput> | UnitAmenityCreateWithoutAmenityInput[] | UnitAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: UnitAmenityCreateOrConnectWithoutAmenityInput | UnitAmenityCreateOrConnectWithoutAmenityInput[]
    upsert?: UnitAmenityUpsertWithWhereUniqueWithoutAmenityInput | UnitAmenityUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: UnitAmenityCreateManyAmenityInputEnvelope
    set?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    disconnect?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    delete?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    connect?: UnitAmenityWhereUniqueInput | UnitAmenityWhereUniqueInput[]
    update?: UnitAmenityUpdateWithWhereUniqueWithoutAmenityInput | UnitAmenityUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: UnitAmenityUpdateManyWithWhereWithoutAmenityInput | UnitAmenityUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: UnitAmenityScalarWhereInput | UnitAmenityScalarWhereInput[]
  }

  export type SpecialtyCreateNestedOneWithoutServicesInput = {
    create?: XOR<SpecialtyCreateWithoutServicesInput, SpecialtyUncheckedCreateWithoutServicesInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutServicesInput
    connect?: SpecialtyWhereUniqueInput
  }

  export type UnitServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<UnitServiceCreateWithoutServiceInput, UnitServiceUncheckedCreateWithoutServiceInput> | UnitServiceCreateWithoutServiceInput[] | UnitServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UnitServiceCreateOrConnectWithoutServiceInput | UnitServiceCreateOrConnectWithoutServiceInput[]
    createMany?: UnitServiceCreateManyServiceInputEnvelope
    connect?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type UnitServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<UnitServiceCreateWithoutServiceInput, UnitServiceUncheckedCreateWithoutServiceInput> | UnitServiceCreateWithoutServiceInput[] | UnitServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UnitServiceCreateOrConnectWithoutServiceInput | UnitServiceCreateOrConnectWithoutServiceInput[]
    createMany?: UnitServiceCreateManyServiceInputEnvelope
    connect?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SpecialtyUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<SpecialtyCreateWithoutServicesInput, SpecialtyUncheckedCreateWithoutServicesInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutServicesInput
    upsert?: SpecialtyUpsertWithoutServicesInput
    connect?: SpecialtyWhereUniqueInput
    update?: XOR<XOR<SpecialtyUpdateToOneWithWhereWithoutServicesInput, SpecialtyUpdateWithoutServicesInput>, SpecialtyUncheckedUpdateWithoutServicesInput>
  }

  export type UnitServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<UnitServiceCreateWithoutServiceInput, UnitServiceUncheckedCreateWithoutServiceInput> | UnitServiceCreateWithoutServiceInput[] | UnitServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UnitServiceCreateOrConnectWithoutServiceInput | UnitServiceCreateOrConnectWithoutServiceInput[]
    upsert?: UnitServiceUpsertWithWhereUniqueWithoutServiceInput | UnitServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: UnitServiceCreateManyServiceInputEnvelope
    set?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    disconnect?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    delete?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    connect?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    update?: UnitServiceUpdateWithWhereUniqueWithoutServiceInput | UnitServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: UnitServiceUpdateManyWithWhereWithoutServiceInput | UnitServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: UnitServiceScalarWhereInput | UnitServiceScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceInput | BookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceInput | BookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceInput | BookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type UnitServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<UnitServiceCreateWithoutServiceInput, UnitServiceUncheckedCreateWithoutServiceInput> | UnitServiceCreateWithoutServiceInput[] | UnitServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UnitServiceCreateOrConnectWithoutServiceInput | UnitServiceCreateOrConnectWithoutServiceInput[]
    upsert?: UnitServiceUpsertWithWhereUniqueWithoutServiceInput | UnitServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: UnitServiceCreateManyServiceInputEnvelope
    set?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    disconnect?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    delete?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    connect?: UnitServiceWhereUniqueInput | UnitServiceWhereUniqueInput[]
    update?: UnitServiceUpdateWithWhereUniqueWithoutServiceInput | UnitServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: UnitServiceUpdateManyWithWhereWithoutServiceInput | UnitServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: UnitServiceScalarWhereInput | UnitServiceScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput> | BookingCreateWithoutServiceInput[] | BookingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceInput | BookingCreateOrConnectWithoutServiceInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceInput | BookingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingCreateManyServiceInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceInput | BookingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceInput | BookingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type UnitCreateNestedOneWithoutUnit_specialtiesInput = {
    create?: XOR<UnitCreateWithoutUnit_specialtiesInput, UnitUncheckedCreateWithoutUnit_specialtiesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutUnit_specialtiesInput
    connect?: UnitWhereUniqueInput
  }

  export type SpecialtyCreateNestedOneWithoutUnit_specialtiesInput = {
    create?: XOR<SpecialtyCreateWithoutUnit_specialtiesInput, SpecialtyUncheckedCreateWithoutUnit_specialtiesInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutUnit_specialtiesInput
    connect?: SpecialtyWhereUniqueInput
  }

  export type UnitUpdateOneRequiredWithoutUnit_specialtiesNestedInput = {
    create?: XOR<UnitCreateWithoutUnit_specialtiesInput, UnitUncheckedCreateWithoutUnit_specialtiesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutUnit_specialtiesInput
    upsert?: UnitUpsertWithoutUnit_specialtiesInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutUnit_specialtiesInput, UnitUpdateWithoutUnit_specialtiesInput>, UnitUncheckedUpdateWithoutUnit_specialtiesInput>
  }

  export type SpecialtyUpdateOneRequiredWithoutUnit_specialtiesNestedInput = {
    create?: XOR<SpecialtyCreateWithoutUnit_specialtiesInput, SpecialtyUncheckedCreateWithoutUnit_specialtiesInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutUnit_specialtiesInput
    upsert?: SpecialtyUpsertWithoutUnit_specialtiesInput
    connect?: SpecialtyWhereUniqueInput
    update?: XOR<XOR<SpecialtyUpdateToOneWithWhereWithoutUnit_specialtiesInput, SpecialtyUpdateWithoutUnit_specialtiesInput>, SpecialtyUncheckedUpdateWithoutUnit_specialtiesInput>
  }

  export type UnitCreateNestedOneWithoutUnit_amenitiesInput = {
    create?: XOR<UnitCreateWithoutUnit_amenitiesInput, UnitUncheckedCreateWithoutUnit_amenitiesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutUnit_amenitiesInput
    connect?: UnitWhereUniqueInput
  }

  export type AmenityCreateNestedOneWithoutUnit_amenitiesInput = {
    create?: XOR<AmenityCreateWithoutUnit_amenitiesInput, AmenityUncheckedCreateWithoutUnit_amenitiesInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutUnit_amenitiesInput
    connect?: AmenityWhereUniqueInput
  }

  export type UnitUpdateOneRequiredWithoutUnit_amenitiesNestedInput = {
    create?: XOR<UnitCreateWithoutUnit_amenitiesInput, UnitUncheckedCreateWithoutUnit_amenitiesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutUnit_amenitiesInput
    upsert?: UnitUpsertWithoutUnit_amenitiesInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutUnit_amenitiesInput, UnitUpdateWithoutUnit_amenitiesInput>, UnitUncheckedUpdateWithoutUnit_amenitiesInput>
  }

  export type AmenityUpdateOneRequiredWithoutUnit_amenitiesNestedInput = {
    create?: XOR<AmenityCreateWithoutUnit_amenitiesInput, AmenityUncheckedCreateWithoutUnit_amenitiesInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutUnit_amenitiesInput
    upsert?: AmenityUpsertWithoutUnit_amenitiesInput
    connect?: AmenityWhereUniqueInput
    update?: XOR<XOR<AmenityUpdateToOneWithWhereWithoutUnit_amenitiesInput, AmenityUpdateWithoutUnit_amenitiesInput>, AmenityUncheckedUpdateWithoutUnit_amenitiesInput>
  }

  export type UnitCreateNestedOneWithoutUnit_servicesInput = {
    create?: XOR<UnitCreateWithoutUnit_servicesInput, UnitUncheckedCreateWithoutUnit_servicesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutUnit_servicesInput
    connect?: UnitWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutUnit_servicesInput = {
    create?: XOR<ServiceCreateWithoutUnit_servicesInput, ServiceUncheckedCreateWithoutUnit_servicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutUnit_servicesInput
    connect?: ServiceWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UnitUpdateOneRequiredWithoutUnit_servicesNestedInput = {
    create?: XOR<UnitCreateWithoutUnit_servicesInput, UnitUncheckedCreateWithoutUnit_servicesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutUnit_servicesInput
    upsert?: UnitUpsertWithoutUnit_servicesInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutUnit_servicesInput, UnitUpdateWithoutUnit_servicesInput>, UnitUncheckedUpdateWithoutUnit_servicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutUnit_servicesNestedInput = {
    create?: XOR<ServiceCreateWithoutUnit_servicesInput, ServiceUncheckedCreateWithoutUnit_servicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutUnit_servicesInput
    upsert?: ServiceUpsertWithoutUnit_servicesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutUnit_servicesInput, ServiceUpdateWithoutUnit_servicesInput>, ServiceUncheckedUpdateWithoutUnit_servicesInput>
  }

  export type UserCreateNestedOneWithoutBookings_as_ownerInput = {
    create?: XOR<UserCreateWithoutBookings_as_ownerInput, UserUncheckedCreateWithoutBookings_as_ownerInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookings_as_ownerInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookings_as_clientInput = {
    create?: XOR<UserCreateWithoutBookings_as_clientInput, UserUncheckedCreateWithoutBookings_as_clientInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookings_as_clientInput
    connect?: UserWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UnitCreateWithoutBookingsInput, UnitUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutBookingsInput
    connect?: UnitWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    connect?: ServiceWhereUniqueInput
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type UserUpdateOneRequiredWithoutBookings_as_ownerNestedInput = {
    create?: XOR<UserCreateWithoutBookings_as_ownerInput, UserUncheckedCreateWithoutBookings_as_ownerInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookings_as_ownerInput
    upsert?: UserUpsertWithoutBookings_as_ownerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookings_as_ownerInput, UserUpdateWithoutBookings_as_ownerInput>, UserUncheckedUpdateWithoutBookings_as_ownerInput>
  }

  export type UserUpdateOneRequiredWithoutBookings_as_clientNestedInput = {
    create?: XOR<UserCreateWithoutBookings_as_clientInput, UserUncheckedCreateWithoutBookings_as_clientInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookings_as_clientInput
    upsert?: UserUpsertWithoutBookings_as_clientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookings_as_clientInput, UserUpdateWithoutBookings_as_clientInput>, UserUncheckedUpdateWithoutBookings_as_clientInput>
  }

  export type UnitUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UnitCreateWithoutBookingsInput, UnitUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutBookingsInput
    upsert?: UnitUpsertWithoutBookingsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutBookingsInput, UnitUpdateWithoutBookingsInput>, UnitUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingsInput
    upsert?: ServiceUpsertWithoutBookingsInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBookingsInput, ServiceUpdateWithoutBookingsInput>, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type UserCreateNestedOneWithoutCustomer_profilesInput = {
    create?: XOR<UserCreateWithoutCustomer_profilesInput, UserUncheckedCreateWithoutCustomer_profilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomer_profilesInput
    connect?: UserWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutCustomersInput = {
    create?: XOR<UnitCreateWithoutCustomersInput, UnitUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: UnitCreateOrConnectWithoutCustomersInput
    connect?: UnitWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCustomer_profilesNestedInput = {
    create?: XOR<UserCreateWithoutCustomer_profilesInput, UserUncheckedCreateWithoutCustomer_profilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomer_profilesInput
    upsert?: UserUpsertWithoutCustomer_profilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomer_profilesInput, UserUpdateWithoutCustomer_profilesInput>, UserUncheckedUpdateWithoutCustomer_profilesInput>
  }

  export type UnitUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<UnitCreateWithoutCustomersInput, UnitUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: UnitCreateOrConnectWithoutCustomersInput
    upsert?: UnitUpsertWithoutCustomersInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutCustomersInput, UnitUpdateWithoutCustomersInput>, UnitUncheckedUpdateWithoutCustomersInput>
  }

  export type UserCreateNestedOneWithoutBooking_rulesInput = {
    create?: XOR<UserCreateWithoutBooking_rulesInput, UserUncheckedCreateWithoutBooking_rulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBooking_rulesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumBookingRuleTypeFieldUpdateOperationsInput = {
    set?: $Enums.BookingRuleType
  }

  export type UserUpdateOneRequiredWithoutBooking_rulesNestedInput = {
    create?: XOR<UserCreateWithoutBooking_rulesInput, UserUncheckedCreateWithoutBooking_rulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBooking_rulesInput
    upsert?: UserUpsertWithoutBooking_rulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBooking_rulesInput, UserUpdateWithoutBooking_rulesInput>, UserUncheckedUpdateWithoutBooking_rulesInput>
  }

  export type UserCreateNestedOneWithoutBooking_exceptionsInput = {
    create?: XOR<UserCreateWithoutBooking_exceptionsInput, UserUncheckedCreateWithoutBooking_exceptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBooking_exceptionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumBookingExceptionTypeFieldUpdateOperationsInput = {
    set?: $Enums.BookingExceptionType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutBooking_exceptionsNestedInput = {
    create?: XOR<UserCreateWithoutBooking_exceptionsInput, UserUncheckedCreateWithoutBooking_exceptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBooking_exceptionsInput
    upsert?: UserUpsertWithoutBooking_exceptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBooking_exceptionsInput, UserUpdateWithoutBooking_exceptionsInput>, UserUncheckedUpdateWithoutBooking_exceptionsInput>
  }

  export type UnitCreateNestedOneWithoutUnit_availability_rulesInput = {
    create?: XOR<UnitCreateWithoutUnit_availability_rulesInput, UnitUncheckedCreateWithoutUnit_availability_rulesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutUnit_availability_rulesInput
    connect?: UnitWhereUniqueInput
  }

  export type EnumUnitAvailabilityRuleTypeFieldUpdateOperationsInput = {
    set?: $Enums.UnitAvailabilityRuleType
  }

  export type UnitUpdateOneRequiredWithoutUnit_availability_rulesNestedInput = {
    create?: XOR<UnitCreateWithoutUnit_availability_rulesInput, UnitUncheckedCreateWithoutUnit_availability_rulesInput>
    connectOrCreate?: UnitCreateOrConnectWithoutUnit_availability_rulesInput
    upsert?: UnitUpsertWithoutUnit_availability_rulesInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutUnit_availability_rulesInput, UnitUpdateWithoutUnit_availability_rulesInput>, UnitUncheckedUpdateWithoutUnit_availability_rulesInput>
  }

  export type UnitCreateNestedOneWithoutUnit_availability_exceptionsInput = {
    create?: XOR<UnitCreateWithoutUnit_availability_exceptionsInput, UnitUncheckedCreateWithoutUnit_availability_exceptionsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutUnit_availability_exceptionsInput
    connect?: UnitWhereUniqueInput
  }

  export type EnumUnitAvailabilityExceptionTypeFieldUpdateOperationsInput = {
    set?: $Enums.UnitAvailabilityExceptionType
  }

  export type UnitUpdateOneRequiredWithoutUnit_availability_exceptionsNestedInput = {
    create?: XOR<UnitCreateWithoutUnit_availability_exceptionsInput, UnitUncheckedCreateWithoutUnit_availability_exceptionsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutUnit_availability_exceptionsInput
    upsert?: UnitUpsertWithoutUnit_availability_exceptionsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutUnit_availability_exceptionsInput, UnitUpdateWithoutUnit_availability_exceptionsInput>, UnitUncheckedUpdateWithoutUnit_availability_exceptionsInput>
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type EnumRenewalIntervalFieldUpdateOperationsInput = {
    set?: $Enums.RenewalInterval
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type UnitCreateNestedOneWithoutSubscription_recordInput = {
    create?: XOR<UnitCreateWithoutSubscription_recordInput, UnitUncheckedCreateWithoutSubscription_recordInput>
    connectOrCreate?: UnitCreateOrConnectWithoutSubscription_recordInput
    connect?: UnitWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput
    connect?: PlanWhereUniqueInput
  }

  export type DiscountCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<DiscountCreateWithoutSubscriptionsInput, DiscountUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutSubscriptionsInput
    connect?: DiscountWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CouponRedemptionCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<CouponRedemptionCreateWithoutSubscriptionInput, CouponRedemptionUncheckedCreateWithoutSubscriptionInput> | CouponRedemptionCreateWithoutSubscriptionInput[] | CouponRedemptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutSubscriptionInput | CouponRedemptionCreateOrConnectWithoutSubscriptionInput[]
    createMany?: CouponRedemptionCreateManySubscriptionInputEnvelope
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type CouponRedemptionUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<CouponRedemptionCreateWithoutSubscriptionInput, CouponRedemptionUncheckedCreateWithoutSubscriptionInput> | CouponRedemptionCreateWithoutSubscriptionInput[] | CouponRedemptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutSubscriptionInput | CouponRedemptionCreateOrConnectWithoutSubscriptionInput[]
    createMany?: CouponRedemptionCreateManySubscriptionInputEnvelope
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type UnitUpdateOneRequiredWithoutSubscription_recordNestedInput = {
    create?: XOR<UnitCreateWithoutSubscription_recordInput, UnitUncheckedCreateWithoutSubscription_recordInput>
    connectOrCreate?: UnitCreateOrConnectWithoutSubscription_recordInput
    upsert?: UnitUpsertWithoutSubscription_recordInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutSubscription_recordInput, UnitUpdateWithoutSubscription_recordInput>, UnitUncheckedUpdateWithoutSubscription_recordInput>
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: PlanUpsertWithoutSubscriptionsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutSubscriptionsInput, PlanUpdateWithoutSubscriptionsInput>, PlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type DiscountUpdateOneWithoutSubscriptionsNestedInput = {
    create?: XOR<DiscountCreateWithoutSubscriptionsInput, DiscountUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutSubscriptionsInput
    upsert?: DiscountUpsertWithoutSubscriptionsInput
    disconnect?: DiscountWhereInput | boolean
    delete?: DiscountWhereInput | boolean
    connect?: DiscountWhereUniqueInput
    update?: XOR<XOR<DiscountUpdateToOneWithWhereWithoutSubscriptionsInput, DiscountUpdateWithoutSubscriptionsInput>, DiscountUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type InvoiceUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSubscriptionInput | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CouponRedemptionUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<CouponRedemptionCreateWithoutSubscriptionInput, CouponRedemptionUncheckedCreateWithoutSubscriptionInput> | CouponRedemptionCreateWithoutSubscriptionInput[] | CouponRedemptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutSubscriptionInput | CouponRedemptionCreateOrConnectWithoutSubscriptionInput[]
    upsert?: CouponRedemptionUpsertWithWhereUniqueWithoutSubscriptionInput | CouponRedemptionUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: CouponRedemptionCreateManySubscriptionInputEnvelope
    set?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    disconnect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    delete?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    update?: CouponRedemptionUpdateWithWhereUniqueWithoutSubscriptionInput | CouponRedemptionUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: CouponRedemptionUpdateManyWithWhereWithoutSubscriptionInput | CouponRedemptionUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput> | InvoiceCreateWithoutSubscriptionInput[] | InvoiceUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSubscriptionInput | InvoiceCreateOrConnectWithoutSubscriptionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput | InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: InvoiceCreateManySubscriptionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput | InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSubscriptionInput | InvoiceUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type CouponRedemptionUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<CouponRedemptionCreateWithoutSubscriptionInput, CouponRedemptionUncheckedCreateWithoutSubscriptionInput> | CouponRedemptionCreateWithoutSubscriptionInput[] | CouponRedemptionUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutSubscriptionInput | CouponRedemptionCreateOrConnectWithoutSubscriptionInput[]
    upsert?: CouponRedemptionUpsertWithWhereUniqueWithoutSubscriptionInput | CouponRedemptionUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: CouponRedemptionCreateManySubscriptionInputEnvelope
    set?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    disconnect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    delete?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    update?: CouponRedemptionUpdateWithWhereUniqueWithoutSubscriptionInput | CouponRedemptionUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: CouponRedemptionUpdateManyWithWhereWithoutSubscriptionInput | CouponRedemptionUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type UserUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    upsert?: UserUpsertWithoutInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesInput, UserUpdateWithoutInvoicesInput>, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type SubscriptionUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutInvoicesInput
    upsert?: SubscriptionUpsertWithoutInvoicesInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutInvoicesInput, SubscriptionUpdateWithoutInvoicesInput>, SubscriptionUncheckedUpdateWithoutInvoicesInput>
  }

  export type SubscriptionCreateNestedManyWithoutDiscountInput = {
    create?: XOR<SubscriptionCreateWithoutDiscountInput, SubscriptionUncheckedCreateWithoutDiscountInput> | SubscriptionCreateWithoutDiscountInput[] | SubscriptionUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutDiscountInput | SubscriptionCreateOrConnectWithoutDiscountInput[]
    createMany?: SubscriptionCreateManyDiscountInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutDiscountInput = {
    create?: XOR<SubscriptionCreateWithoutDiscountInput, SubscriptionUncheckedCreateWithoutDiscountInput> | SubscriptionCreateWithoutDiscountInput[] | SubscriptionUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutDiscountInput | SubscriptionCreateOrConnectWithoutDiscountInput[]
    createMany?: SubscriptionCreateManyDiscountInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type EnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType
  }

  export type EnumDiscountDurationFieldUpdateOperationsInput = {
    set?: $Enums.DiscountDuration
  }

  export type SubscriptionUpdateManyWithoutDiscountNestedInput = {
    create?: XOR<SubscriptionCreateWithoutDiscountInput, SubscriptionUncheckedCreateWithoutDiscountInput> | SubscriptionCreateWithoutDiscountInput[] | SubscriptionUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutDiscountInput | SubscriptionCreateOrConnectWithoutDiscountInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutDiscountInput | SubscriptionUpsertWithWhereUniqueWithoutDiscountInput[]
    createMany?: SubscriptionCreateManyDiscountInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutDiscountInput | SubscriptionUpdateWithWhereUniqueWithoutDiscountInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutDiscountInput | SubscriptionUpdateManyWithWhereWithoutDiscountInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutDiscountNestedInput = {
    create?: XOR<SubscriptionCreateWithoutDiscountInput, SubscriptionUncheckedCreateWithoutDiscountInput> | SubscriptionCreateWithoutDiscountInput[] | SubscriptionUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutDiscountInput | SubscriptionCreateOrConnectWithoutDiscountInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutDiscountInput | SubscriptionUpsertWithWhereUniqueWithoutDiscountInput[]
    createMany?: SubscriptionCreateManyDiscountInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutDiscountInput | SubscriptionUpdateWithWhereUniqueWithoutDiscountInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutDiscountInput | SubscriptionUpdateManyWithWhereWithoutDiscountInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCoupon_redemptionsInput = {
    create?: XOR<UserCreateWithoutCoupon_redemptionsInput, UserUncheckedCreateWithoutCoupon_redemptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoupon_redemptionsInput
    connect?: UserWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutCoupon_redemptionsInput = {
    create?: XOR<SubscriptionCreateWithoutCoupon_redemptionsInput, SubscriptionUncheckedCreateWithoutCoupon_redemptionsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCoupon_redemptionsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCoupon_redemptionsNestedInput = {
    create?: XOR<UserCreateWithoutCoupon_redemptionsInput, UserUncheckedCreateWithoutCoupon_redemptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoupon_redemptionsInput
    upsert?: UserUpsertWithoutCoupon_redemptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoupon_redemptionsInput, UserUpdateWithoutCoupon_redemptionsInput>, UserUncheckedUpdateWithoutCoupon_redemptionsInput>
  }

  export type SubscriptionUpdateOneRequiredWithoutCoupon_redemptionsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCoupon_redemptionsInput, SubscriptionUncheckedCreateWithoutCoupon_redemptionsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCoupon_redemptionsInput
    upsert?: SubscriptionUpsertWithoutCoupon_redemptionsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutCoupon_redemptionsInput, SubscriptionUpdateWithoutCoupon_redemptionsInput>, SubscriptionUncheckedUpdateWithoutCoupon_redemptionsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationTemplateCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<NotificationTemplateCreateWithoutNotificationsInput, NotificationTemplateUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutNotificationsInput
    connect?: NotificationTemplateWhereUniqueInput
  }

  export type EnumNotificationChannelFieldUpdateOperationsInput = {
    set?: $Enums.NotificationChannel
  }

  export type EnumNotificationPriorityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPriority
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NotificationTemplateUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<NotificationTemplateCreateWithoutNotificationsInput, NotificationTemplateUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutNotificationsInput
    upsert?: NotificationTemplateUpsertWithoutNotificationsInput
    connect?: NotificationTemplateWhereUniqueInput
    update?: XOR<XOR<NotificationTemplateUpdateToOneWithWhereWithoutNotificationsInput, NotificationTemplateUpdateWithoutNotificationsInput>, NotificationTemplateUncheckedUpdateWithoutNotificationsInput>
  }

  export type NotificationTemplateCreatevariablesInput = {
    set: string[]
  }

  export type NotificationCreateNestedManyWithoutTemplateInput = {
    create?: XOR<NotificationCreateWithoutTemplateInput, NotificationUncheckedCreateWithoutTemplateInput> | NotificationCreateWithoutTemplateInput[] | NotificationUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTemplateInput | NotificationCreateOrConnectWithoutTemplateInput[]
    createMany?: NotificationCreateManyTemplateInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<NotificationCreateWithoutTemplateInput, NotificationUncheckedCreateWithoutTemplateInput> | NotificationCreateWithoutTemplateInput[] | NotificationUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTemplateInput | NotificationCreateOrConnectWithoutTemplateInput[]
    createMany?: NotificationCreateManyTemplateInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumNotificationTemplateChannelFieldUpdateOperationsInput = {
    set?: $Enums.NotificationTemplateChannel
  }

  export type NotificationTemplateUpdatevariablesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NotificationUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<NotificationCreateWithoutTemplateInput, NotificationUncheckedCreateWithoutTemplateInput> | NotificationCreateWithoutTemplateInput[] | NotificationUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTemplateInput | NotificationCreateOrConnectWithoutTemplateInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTemplateInput | NotificationUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: NotificationCreateManyTemplateInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTemplateInput | NotificationUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTemplateInput | NotificationUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<NotificationCreateWithoutTemplateInput, NotificationUncheckedCreateWithoutTemplateInput> | NotificationCreateWithoutTemplateInput[] | NotificationUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTemplateInput | NotificationCreateOrConnectWithoutTemplateInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTemplateInput | NotificationUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: NotificationCreateManyTemplateInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTemplateInput | NotificationUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTemplateInput | NotificationUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotification_prefsInput = {
    create?: XOR<UserCreateWithoutNotification_prefsInput, UserUncheckedCreateWithoutNotification_prefsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotification_prefsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationPreferenceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.NotificationPreferenceCategory
  }

  export type UserUpdateOneRequiredWithoutNotification_prefsNestedInput = {
    create?: XOR<UserCreateWithoutNotification_prefsInput, UserUncheckedCreateWithoutNotification_prefsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotification_prefsInput
    upsert?: UserUpsertWithoutNotification_prefsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotification_prefsInput, UserUpdateWithoutNotification_prefsInput>, UserUncheckedUpdateWithoutNotification_prefsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumBookingRuleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingRuleType | EnumBookingRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingRuleType[] | ListEnumBookingRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingRuleType[] | ListEnumBookingRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingRuleTypeFilter<$PrismaModel> | $Enums.BookingRuleType
  }

  export type NestedEnumBookingRuleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingRuleType | EnumBookingRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingRuleType[] | ListEnumBookingRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingRuleType[] | ListEnumBookingRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingRuleTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookingRuleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingRuleTypeFilter<$PrismaModel>
    _max?: NestedEnumBookingRuleTypeFilter<$PrismaModel>
  }

  export type NestedEnumBookingExceptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingExceptionType | EnumBookingExceptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingExceptionType[] | ListEnumBookingExceptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingExceptionType[] | ListEnumBookingExceptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingExceptionTypeFilter<$PrismaModel> | $Enums.BookingExceptionType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumBookingExceptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingExceptionType | EnumBookingExceptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingExceptionType[] | ListEnumBookingExceptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingExceptionType[] | ListEnumBookingExceptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingExceptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookingExceptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingExceptionTypeFilter<$PrismaModel>
    _max?: NestedEnumBookingExceptionTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUnitAvailabilityRuleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitAvailabilityRuleType | EnumUnitAvailabilityRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UnitAvailabilityRuleType[] | ListEnumUnitAvailabilityRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitAvailabilityRuleType[] | ListEnumUnitAvailabilityRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitAvailabilityRuleTypeFilter<$PrismaModel> | $Enums.UnitAvailabilityRuleType
  }

  export type NestedEnumUnitAvailabilityRuleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitAvailabilityRuleType | EnumUnitAvailabilityRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UnitAvailabilityRuleType[] | ListEnumUnitAvailabilityRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitAvailabilityRuleType[] | ListEnumUnitAvailabilityRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitAvailabilityRuleTypeWithAggregatesFilter<$PrismaModel> | $Enums.UnitAvailabilityRuleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitAvailabilityRuleTypeFilter<$PrismaModel>
    _max?: NestedEnumUnitAvailabilityRuleTypeFilter<$PrismaModel>
  }

  export type NestedEnumUnitAvailabilityExceptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitAvailabilityExceptionType | EnumUnitAvailabilityExceptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UnitAvailabilityExceptionType[] | ListEnumUnitAvailabilityExceptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitAvailabilityExceptionType[] | ListEnumUnitAvailabilityExceptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitAvailabilityExceptionTypeFilter<$PrismaModel> | $Enums.UnitAvailabilityExceptionType
  }

  export type NestedEnumUnitAvailabilityExceptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitAvailabilityExceptionType | EnumUnitAvailabilityExceptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UnitAvailabilityExceptionType[] | ListEnumUnitAvailabilityExceptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitAvailabilityExceptionType[] | ListEnumUnitAvailabilityExceptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitAvailabilityExceptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.UnitAvailabilityExceptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitAvailabilityExceptionTypeFilter<$PrismaModel>
    _max?: NestedEnumUnitAvailabilityExceptionTypeFilter<$PrismaModel>
  }

  export type NestedEnumRenewalIntervalFilter<$PrismaModel = never> = {
    equals?: $Enums.RenewalInterval | EnumRenewalIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.RenewalInterval[] | ListEnumRenewalIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.RenewalInterval[] | ListEnumRenewalIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumRenewalIntervalFilter<$PrismaModel> | $Enums.RenewalInterval
  }

  export type NestedEnumRenewalIntervalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RenewalInterval | EnumRenewalIntervalFieldRefInput<$PrismaModel>
    in?: $Enums.RenewalInterval[] | ListEnumRenewalIntervalFieldRefInput<$PrismaModel>
    notIn?: $Enums.RenewalInterval[] | ListEnumRenewalIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumRenewalIntervalWithAggregatesFilter<$PrismaModel> | $Enums.RenewalInterval
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRenewalIntervalFilter<$PrismaModel>
    _max?: NestedEnumRenewalIntervalFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type NestedEnumDiscountDurationFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountDuration | EnumDiscountDurationFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountDuration[] | ListEnumDiscountDurationFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountDuration[] | ListEnumDiscountDurationFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountDurationFilter<$PrismaModel> | $Enums.DiscountDuration
  }

  export type NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type NestedEnumDiscountDurationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountDuration | EnumDiscountDurationFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountDuration[] | ListEnumDiscountDurationFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountDuration[] | ListEnumDiscountDurationFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountDurationWithAggregatesFilter<$PrismaModel> | $Enums.DiscountDuration
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountDurationFilter<$PrismaModel>
    _max?: NestedEnumDiscountDurationFilter<$PrismaModel>
  }

  export type NestedEnumNotificationChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelFilter<$PrismaModel> | $Enums.NotificationChannel
  }

  export type NestedEnumNotificationPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityFilter<$PrismaModel> | $Enums.NotificationPriority
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationChannelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationChannelFilter<$PrismaModel>
    _max?: NestedEnumNotificationChannelFilter<$PrismaModel>
  }

  export type NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPriority | EnumNotificationPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPriority[] | ListEnumNotificationPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPriorityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPriorityFilter<$PrismaModel>
    _max?: NestedEnumNotificationPriorityFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTemplateChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationTemplateChannel | EnumNotificationTemplateChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationTemplateChannel[] | ListEnumNotificationTemplateChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationTemplateChannel[] | ListEnumNotificationTemplateChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTemplateChannelFilter<$PrismaModel> | $Enums.NotificationTemplateChannel
  }

  export type NestedEnumNotificationTemplateChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationTemplateChannel | EnumNotificationTemplateChannelFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationTemplateChannel[] | ListEnumNotificationTemplateChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationTemplateChannel[] | ListEnumNotificationTemplateChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTemplateChannelWithAggregatesFilter<$PrismaModel> | $Enums.NotificationTemplateChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTemplateChannelFilter<$PrismaModel>
    _max?: NestedEnumNotificationTemplateChannelFilter<$PrismaModel>
  }

  export type NestedEnumNotificationPreferenceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPreferenceCategory | EnumNotificationPreferenceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPreferenceCategory[] | ListEnumNotificationPreferenceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPreferenceCategory[] | ListEnumNotificationPreferenceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPreferenceCategoryFilter<$PrismaModel> | $Enums.NotificationPreferenceCategory
  }

  export type NestedEnumNotificationPreferenceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationPreferenceCategory | EnumNotificationPreferenceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationPreferenceCategory[] | ListEnumNotificationPreferenceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationPreferenceCategory[] | ListEnumNotificationPreferenceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationPreferenceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.NotificationPreferenceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationPreferenceCategoryFilter<$PrismaModel>
    _max?: NestedEnumNotificationPreferenceCategoryFilter<$PrismaModel>
  }

  export type OrganizationCreateWithoutOwnerInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    units?: UnitCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutOwnerInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    units?: UnitUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutOwnerInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput>
  }

  export type BookingCreateWithoutOwnerInput = {
    id: string
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
    client: UserCreateNestedOneWithoutBookings_as_clientInput
    unit: UnitCreateNestedOneWithoutBookingsInput
    service?: ServiceCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutOwnerInput = {
    id: string
    client_id: string
    unit_id: string
    service_id?: string | null
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingCreateOrConnectWithoutOwnerInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput>
  }

  export type BookingCreateManyOwnerInputEnvelope = {
    data: BookingCreateManyOwnerInput | BookingCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutClientInput = {
    id: string
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutBookings_as_ownerInput
    unit: UnitCreateNestedOneWithoutBookingsInput
    service?: ServiceCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutClientInput = {
    id: string
    user_id: string
    unit_id: string
    service_id?: string | null
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingCreateOrConnectWithoutClientInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutClientInput, BookingUncheckedCreateWithoutClientInput>
  }

  export type BookingCreateManyClientInputEnvelope = {
    data: BookingCreateManyClientInput | BookingCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type BookingRuleCreateWithoutUserInput = {
    id: string
    type: $Enums.BookingRuleType
    weekday?: number | null
    date?: string | null
    start_time: Date | string
    end_time: Date | string
    slot_duration_minutes: number
    min_advance_minutes?: number | null
    max_duration_minutes?: number | null
    max_bookings_per_day?: number | null
    max_bookings_per_client_per_day?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingRuleUncheckedCreateWithoutUserInput = {
    id: string
    type: $Enums.BookingRuleType
    weekday?: number | null
    date?: string | null
    start_time: Date | string
    end_time: Date | string
    slot_duration_minutes: number
    min_advance_minutes?: number | null
    max_duration_minutes?: number | null
    max_bookings_per_day?: number | null
    max_bookings_per_client_per_day?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingRuleCreateOrConnectWithoutUserInput = {
    where: BookingRuleWhereUniqueInput
    create: XOR<BookingRuleCreateWithoutUserInput, BookingRuleUncheckedCreateWithoutUserInput>
  }

  export type BookingRuleCreateManyUserInputEnvelope = {
    data: BookingRuleCreateManyUserInput | BookingRuleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookingExceptionCreateWithoutUserInput = {
    id: string
    date: string
    type: $Enums.BookingExceptionType
    start_time?: Date | string | null
    end_time?: Date | string | null
    slot_duration_minutes?: number | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingExceptionUncheckedCreateWithoutUserInput = {
    id: string
    date: string
    type: $Enums.BookingExceptionType
    start_time?: Date | string | null
    end_time?: Date | string | null
    slot_duration_minutes?: number | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingExceptionCreateOrConnectWithoutUserInput = {
    where: BookingExceptionWhereUniqueInput
    create: XOR<BookingExceptionCreateWithoutUserInput, BookingExceptionUncheckedCreateWithoutUserInput>
  }

  export type BookingExceptionCreateManyUserInputEnvelope = {
    data: BookingExceptionCreateManyUserInput | BookingExceptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutSubscription_recordInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    discount?: DiscountCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id: string
    unit_id: string
    plan_id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    discount_id?: string | null
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: SubscriptionCreateManyUserInput | SubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutUserInput = {
    id: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    line_items: JsonNullValueInput | InputJsonValue
    due_date: Date | string
    paid_at?: Date | string | null
    provider_invoice_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutUserInput = {
    id: string
    subscription_id: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    line_items: JsonNullValueInput | InputJsonValue
    due_date: Date | string
    paid_at?: Date | string | null
    provider_invoice_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateManyUserInputEnvelope = {
    data: InvoiceCreateManyUserInput | InvoiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CouponRedemptionCreateWithoutUserInput = {
    id: string
    coupon_id: string
    redeemed_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutCoupon_redemptionsInput
  }

  export type CouponRedemptionUncheckedCreateWithoutUserInput = {
    id: string
    coupon_id: string
    subscription_id: string
    redeemed_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CouponRedemptionCreateOrConnectWithoutUserInput = {
    where: CouponRedemptionWhereUniqueInput
    create: XOR<CouponRedemptionCreateWithoutUserInput, CouponRedemptionUncheckedCreateWithoutUserInput>
  }

  export type CouponRedemptionCreateManyUserInputEnvelope = {
    data: CouponRedemptionCreateManyUserInput | CouponRedemptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id: string
    channel: $Enums.NotificationChannel
    payload: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    provider_id?: string | null
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id: string
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    template: NotificationTemplateCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id: string
    channel: $Enums.NotificationChannel
    template_id: string
    payload: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    provider_id?: string | null
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id: string
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationPreferenceCreateWithoutUserInput = {
    id: string
    category: $Enums.NotificationPreferenceCategory
    channels: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationPreferenceUncheckedCreateWithoutUserInput = {
    id: string
    category: $Enums.NotificationPreferenceCategory
    channels: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationPreferenceCreateOrConnectWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type NotificationPreferenceCreateManyUserInputEnvelope = {
    data: NotificationPreferenceCreateManyUserInput | NotificationPreferenceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutUserInput = {
    id: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutUserInput = {
    id: string
    unit_id: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerCreateOrConnectWithoutUserInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
  }

  export type CustomerCreateManyUserInputEnvelope = {
    data: CustomerCreateManyUserInput | CustomerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutOwnerInput = {
    update: XOR<OrganizationUpdateWithoutOwnerInput, OrganizationUncheckedUpdateWithoutOwnerInput>
    create: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutOwnerInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutOwnerInput, OrganizationUncheckedUpdateWithoutOwnerInput>
  }

  export type OrganizationUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: UnitUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    units?: UnitUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutOwnerInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutOwnerInput, BookingUncheckedUpdateWithoutOwnerInput>
    create: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutOwnerInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutOwnerInput, BookingUncheckedUpdateWithoutOwnerInput>
  }

  export type BookingUpdateManyWithWhereWithoutOwnerInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutOwnerInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    user_id?: StringFilter<"Booking"> | string
    client_id?: StringFilter<"Booking"> | string
    unit_id?: StringFilter<"Booking"> | string
    service_id?: StringNullableFilter<"Booking"> | string | null
    price_cents?: IntNullableFilter<"Booking"> | number | null
    notes?: StringNullableFilter<"Booking"> | string | null
    start_at?: DateTimeFilter<"Booking"> | Date | string
    end_at?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    created_at?: DateTimeFilter<"Booking"> | Date | string
    updated_at?: DateTimeFilter<"Booking"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutClientInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutClientInput, BookingUncheckedUpdateWithoutClientInput>
    create: XOR<BookingCreateWithoutClientInput, BookingUncheckedCreateWithoutClientInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutClientInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutClientInput, BookingUncheckedUpdateWithoutClientInput>
  }

  export type BookingUpdateManyWithWhereWithoutClientInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutClientInput>
  }

  export type BookingRuleUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingRuleWhereUniqueInput
    update: XOR<BookingRuleUpdateWithoutUserInput, BookingRuleUncheckedUpdateWithoutUserInput>
    create: XOR<BookingRuleCreateWithoutUserInput, BookingRuleUncheckedCreateWithoutUserInput>
  }

  export type BookingRuleUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingRuleWhereUniqueInput
    data: XOR<BookingRuleUpdateWithoutUserInput, BookingRuleUncheckedUpdateWithoutUserInput>
  }

  export type BookingRuleUpdateManyWithWhereWithoutUserInput = {
    where: BookingRuleScalarWhereInput
    data: XOR<BookingRuleUpdateManyMutationInput, BookingRuleUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingRuleScalarWhereInput = {
    AND?: BookingRuleScalarWhereInput | BookingRuleScalarWhereInput[]
    OR?: BookingRuleScalarWhereInput[]
    NOT?: BookingRuleScalarWhereInput | BookingRuleScalarWhereInput[]
    id?: StringFilter<"BookingRule"> | string
    user_id?: StringFilter<"BookingRule"> | string
    type?: EnumBookingRuleTypeFilter<"BookingRule"> | $Enums.BookingRuleType
    weekday?: IntNullableFilter<"BookingRule"> | number | null
    date?: StringNullableFilter<"BookingRule"> | string | null
    start_time?: DateTimeFilter<"BookingRule"> | Date | string
    end_time?: DateTimeFilter<"BookingRule"> | Date | string
    slot_duration_minutes?: IntFilter<"BookingRule"> | number
    min_advance_minutes?: IntNullableFilter<"BookingRule"> | number | null
    max_duration_minutes?: IntNullableFilter<"BookingRule"> | number | null
    max_bookings_per_day?: IntNullableFilter<"BookingRule"> | number | null
    max_bookings_per_client_per_day?: IntNullableFilter<"BookingRule"> | number | null
    metadata?: JsonNullableFilter<"BookingRule">
    created_at?: DateTimeFilter<"BookingRule"> | Date | string
    updated_at?: DateTimeFilter<"BookingRule"> | Date | string
  }

  export type BookingExceptionUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingExceptionWhereUniqueInput
    update: XOR<BookingExceptionUpdateWithoutUserInput, BookingExceptionUncheckedUpdateWithoutUserInput>
    create: XOR<BookingExceptionCreateWithoutUserInput, BookingExceptionUncheckedCreateWithoutUserInput>
  }

  export type BookingExceptionUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingExceptionWhereUniqueInput
    data: XOR<BookingExceptionUpdateWithoutUserInput, BookingExceptionUncheckedUpdateWithoutUserInput>
  }

  export type BookingExceptionUpdateManyWithWhereWithoutUserInput = {
    where: BookingExceptionScalarWhereInput
    data: XOR<BookingExceptionUpdateManyMutationInput, BookingExceptionUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingExceptionScalarWhereInput = {
    AND?: BookingExceptionScalarWhereInput | BookingExceptionScalarWhereInput[]
    OR?: BookingExceptionScalarWhereInput[]
    NOT?: BookingExceptionScalarWhereInput | BookingExceptionScalarWhereInput[]
    id?: StringFilter<"BookingException"> | string
    user_id?: StringFilter<"BookingException"> | string
    date?: StringFilter<"BookingException"> | string
    type?: EnumBookingExceptionTypeFilter<"BookingException"> | $Enums.BookingExceptionType
    start_time?: DateTimeNullableFilter<"BookingException"> | Date | string | null
    end_time?: DateTimeNullableFilter<"BookingException"> | Date | string | null
    slot_duration_minutes?: IntNullableFilter<"BookingException"> | number | null
    reason?: StringNullableFilter<"BookingException"> | string | null
    created_at?: DateTimeFilter<"BookingException"> | Date | string
    updated_at?: DateTimeFilter<"BookingException"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    unit_id?: StringFilter<"Subscription"> | string
    user_id?: StringFilter<"Subscription"> | string
    plan_id?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    start_date?: DateTimeFilter<"Subscription"> | Date | string
    current_period_start?: DateTimeFilter<"Subscription"> | Date | string
    current_period_end?: DateTimeFilter<"Subscription"> | Date | string
    cancel_at_period_end?: BoolFilter<"Subscription"> | boolean
    canceled_at?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trial_end?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    renewal_interval?: EnumRenewalIntervalFilter<"Subscription"> | $Enums.RenewalInterval
    discount_id?: StringNullableFilter<"Subscription"> | string | null
    provider_subscription_id?: StringNullableFilter<"Subscription"> | string | null
    metadata?: JsonNullableFilter<"Subscription">
    created_at?: DateTimeFilter<"Subscription"> | Date | string
    updated_at?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUserInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUserInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    user_id?: StringFilter<"Invoice"> | string
    subscription_id?: StringFilter<"Invoice"> | string
    amount?: IntFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    line_items?: JsonFilter<"Invoice">
    due_date?: DateTimeFilter<"Invoice"> | Date | string
    paid_at?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    provider_invoice_id?: StringNullableFilter<"Invoice"> | string | null
    metadata?: JsonNullableFilter<"Invoice">
    created_at?: DateTimeFilter<"Invoice"> | Date | string
    updated_at?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type CouponRedemptionUpsertWithWhereUniqueWithoutUserInput = {
    where: CouponRedemptionWhereUniqueInput
    update: XOR<CouponRedemptionUpdateWithoutUserInput, CouponRedemptionUncheckedUpdateWithoutUserInput>
    create: XOR<CouponRedemptionCreateWithoutUserInput, CouponRedemptionUncheckedCreateWithoutUserInput>
  }

  export type CouponRedemptionUpdateWithWhereUniqueWithoutUserInput = {
    where: CouponRedemptionWhereUniqueInput
    data: XOR<CouponRedemptionUpdateWithoutUserInput, CouponRedemptionUncheckedUpdateWithoutUserInput>
  }

  export type CouponRedemptionUpdateManyWithWhereWithoutUserInput = {
    where: CouponRedemptionScalarWhereInput
    data: XOR<CouponRedemptionUpdateManyMutationInput, CouponRedemptionUncheckedUpdateManyWithoutUserInput>
  }

  export type CouponRedemptionScalarWhereInput = {
    AND?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
    OR?: CouponRedemptionScalarWhereInput[]
    NOT?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
    id?: StringFilter<"CouponRedemption"> | string
    coupon_id?: StringFilter<"CouponRedemption"> | string
    user_id?: StringFilter<"CouponRedemption"> | string
    subscription_id?: StringFilter<"CouponRedemption"> | string
    redeemed_at?: DateTimeFilter<"CouponRedemption"> | Date | string
    metadata?: JsonNullableFilter<"CouponRedemption">
    created_at?: DateTimeFilter<"CouponRedemption"> | Date | string
    updated_at?: DateTimeFilter<"CouponRedemption"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    target_user_id?: StringFilter<"Notification"> | string
    channel?: EnumNotificationChannelFilter<"Notification"> | $Enums.NotificationChannel
    template_id?: StringFilter<"Notification"> | string
    payload?: JsonFilter<"Notification">
    priority?: EnumNotificationPriorityFilter<"Notification"> | $Enums.NotificationPriority
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    provider_id?: StringNullableFilter<"Notification"> | string | null
    error_message?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    message_id?: StringFilter<"Notification"> | string
    sent_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    delivered_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    read_at?: DateTimeNullableFilter<"Notification"> | Date | string | null
    created_at?: DateTimeFilter<"Notification"> | Date | string
    updated_at?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationPreferenceUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    update: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationPreferenceCreateWithoutUserInput, NotificationPreferenceUncheckedCreateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationPreferenceWhereUniqueInput
    data: XOR<NotificationPreferenceUpdateWithoutUserInput, NotificationPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type NotificationPreferenceUpdateManyWithWhereWithoutUserInput = {
    where: NotificationPreferenceScalarWhereInput
    data: XOR<NotificationPreferenceUpdateManyMutationInput, NotificationPreferenceUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationPreferenceScalarWhereInput = {
    AND?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
    OR?: NotificationPreferenceScalarWhereInput[]
    NOT?: NotificationPreferenceScalarWhereInput | NotificationPreferenceScalarWhereInput[]
    id?: StringFilter<"NotificationPreference"> | string
    user_id?: StringFilter<"NotificationPreference"> | string
    category?: EnumNotificationPreferenceCategoryFilter<"NotificationPreference"> | $Enums.NotificationPreferenceCategory
    channels?: JsonFilter<"NotificationPreference">
    metadata?: JsonNullableFilter<"NotificationPreference">
    created_at?: DateTimeFilter<"NotificationPreference"> | Date | string
    updated_at?: DateTimeFilter<"NotificationPreference"> | Date | string
  }

  export type CustomerUpsertWithWhereUniqueWithoutUserInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutUserInput, CustomerUncheckedUpdateWithoutUserInput>
    create: XOR<CustomerCreateWithoutUserInput, CustomerUncheckedCreateWithoutUserInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutUserInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutUserInput, CustomerUncheckedUpdateWithoutUserInput>
  }

  export type CustomerUpdateManyWithWhereWithoutUserInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutUserInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    user_id?: StringFilter<"Customer"> | string
    unit_id?: StringFilter<"Customer"> | string
    notes?: StringNullableFilter<"Customer"> | string | null
    created_at?: DateTimeFilter<"Customer"> | Date | string
    updated_at?: DateTimeFilter<"Customer"> | Date | string
  }

  export type UserCreateWithoutOrganizationInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    bookings_as_owner?: BookingCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    bookings_as_owner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingUncheckedCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleUncheckedCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UnitCreateWithoutOrganizationInput = {
    id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit_specialties?: UnitSpecialtyCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionCreateNestedOneWithoutUnitInput
    bookings?: BookingCreateNestedManyWithoutUnitInput
    customers?: CustomerCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutOrganizationInput = {
    id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit_specialties?: UnitSpecialtyUncheckedCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceUncheckedCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionUncheckedCreateNestedOneWithoutUnitInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUnitInput
    customers?: CustomerUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutOrganizationInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutOrganizationInput, UnitUncheckedCreateWithoutOrganizationInput>
  }

  export type UnitCreateManyOrganizationInputEnvelope = {
    data: UnitCreateManyOrganizationInput | UnitCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrganizationInput = {
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganizationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings_as_owner?: BookingUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings_as_owner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUncheckedUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUncheckedUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UnitUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutOrganizationInput, UnitUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UnitCreateWithoutOrganizationInput, UnitUncheckedCreateWithoutOrganizationInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutOrganizationInput, UnitUncheckedUpdateWithoutOrganizationInput>
  }

  export type UnitUpdateManyWithWhereWithoutOrganizationInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    id?: StringFilter<"Unit"> | string
    organization_id?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    brand_color?: StringFilter<"Unit"> | string
    logo?: StringNullableFilter<"Unit"> | string | null
    gallery?: StringNullableListFilter<"Unit">
    is_active?: BoolFilter<"Unit"> | boolean
    whatsapp?: StringFilter<"Unit"> | string
    phone?: StringNullableFilter<"Unit"> | string | null
    address?: JsonFilter<"Unit">
    especialidades?: JsonFilter<"Unit">
    services?: JsonFilter<"Unit">
    service_type?: EnumServiceTypeFilter<"Unit"> | $Enums.ServiceType
    amenities?: StringNullableListFilter<"Unit">
    subscription?: JsonNullableFilter<"Unit">
    working_hours?: JsonNullableFilter<"Unit">
    lunch_break?: JsonNullableFilter<"Unit">
    created_at?: DateTimeFilter<"Unit"> | Date | string
    updated_at?: DateTimeFilter<"Unit"> | Date | string
  }

  export type OrganizationCreateWithoutUnitsInput = {
    id: string
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUnitsInput = {
    id: string
    name: string
    owner_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrganizationCreateOrConnectWithoutUnitsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUnitsInput, OrganizationUncheckedCreateWithoutUnitsInput>
  }

  export type UnitSpecialtyCreateWithoutUnitInput = {
    id: string
    created_at?: Date | string
    updated_at?: Date | string
    specialty: SpecialtyCreateNestedOneWithoutUnit_specialtiesInput
  }

  export type UnitSpecialtyUncheckedCreateWithoutUnitInput = {
    id: string
    specialty_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitSpecialtyCreateOrConnectWithoutUnitInput = {
    where: UnitSpecialtyWhereUniqueInput
    create: XOR<UnitSpecialtyCreateWithoutUnitInput, UnitSpecialtyUncheckedCreateWithoutUnitInput>
  }

  export type UnitSpecialtyCreateManyUnitInputEnvelope = {
    data: UnitSpecialtyCreateManyUnitInput | UnitSpecialtyCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitServiceCreateWithoutUnitInput = {
    id: string
    custom_price_cents?: number | null
    custom_duration_minutes?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    service: ServiceCreateNestedOneWithoutUnit_servicesInput
  }

  export type UnitServiceUncheckedCreateWithoutUnitInput = {
    id: string
    service_id: string
    custom_price_cents?: number | null
    custom_duration_minutes?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitServiceCreateOrConnectWithoutUnitInput = {
    where: UnitServiceWhereUniqueInput
    create: XOR<UnitServiceCreateWithoutUnitInput, UnitServiceUncheckedCreateWithoutUnitInput>
  }

  export type UnitServiceCreateManyUnitInputEnvelope = {
    data: UnitServiceCreateManyUnitInput | UnitServiceCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitAmenityCreateWithoutUnitInput = {
    id: string
    created_at?: Date | string
    updated_at?: Date | string
    amenity: AmenityCreateNestedOneWithoutUnit_amenitiesInput
  }

  export type UnitAmenityUncheckedCreateWithoutUnitInput = {
    id: string
    amenity_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAmenityCreateOrConnectWithoutUnitInput = {
    where: UnitAmenityWhereUniqueInput
    create: XOR<UnitAmenityCreateWithoutUnitInput, UnitAmenityUncheckedCreateWithoutUnitInput>
  }

  export type UnitAmenityCreateManyUnitInputEnvelope = {
    data: UnitAmenityCreateManyUnitInput | UnitAmenityCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitAvailabilityRuleCreateWithoutUnitInput = {
    id: string
    type: $Enums.UnitAvailabilityRuleType
    weekday?: number | null
    date?: string | null
    start_time: string
    end_time: string
    slot_duration_minutes: number
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAvailabilityRuleUncheckedCreateWithoutUnitInput = {
    id: string
    type: $Enums.UnitAvailabilityRuleType
    weekday?: number | null
    date?: string | null
    start_time: string
    end_time: string
    slot_duration_minutes: number
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAvailabilityRuleCreateOrConnectWithoutUnitInput = {
    where: UnitAvailabilityRuleWhereUniqueInput
    create: XOR<UnitAvailabilityRuleCreateWithoutUnitInput, UnitAvailabilityRuleUncheckedCreateWithoutUnitInput>
  }

  export type UnitAvailabilityRuleCreateManyUnitInputEnvelope = {
    data: UnitAvailabilityRuleCreateManyUnitInput | UnitAvailabilityRuleCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitAvailabilityExceptionCreateWithoutUnitInput = {
    id: string
    date: string
    type: $Enums.UnitAvailabilityExceptionType
    start_time?: string | null
    end_time?: string | null
    slot_duration_minutes?: number | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAvailabilityExceptionUncheckedCreateWithoutUnitInput = {
    id: string
    date: string
    type: $Enums.UnitAvailabilityExceptionType
    start_time?: string | null
    end_time?: string | null
    slot_duration_minutes?: number | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAvailabilityExceptionCreateOrConnectWithoutUnitInput = {
    where: UnitAvailabilityExceptionWhereUniqueInput
    create: XOR<UnitAvailabilityExceptionCreateWithoutUnitInput, UnitAvailabilityExceptionUncheckedCreateWithoutUnitInput>
  }

  export type UnitAvailabilityExceptionCreateManyUnitInputEnvelope = {
    data: UnitAvailabilityExceptionCreateManyUnitInput | UnitAvailabilityExceptionCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUnitInput = {
    id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    discount?: DiscountCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUnitInput = {
    id: string
    user_id: string
    plan_id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    discount_id?: string | null
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutUnitInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUnitInput, SubscriptionUncheckedCreateWithoutUnitInput>
  }

  export type BookingCreateWithoutUnitInput = {
    id: string
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutBookings_as_ownerInput
    client: UserCreateNestedOneWithoutBookings_as_clientInput
    service?: ServiceCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutUnitInput = {
    id: string
    user_id: string
    client_id: string
    service_id?: string | null
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingCreateOrConnectWithoutUnitInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUnitInput, BookingUncheckedCreateWithoutUnitInput>
  }

  export type BookingCreateManyUnitInputEnvelope = {
    data: BookingCreateManyUnitInput | BookingCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutUnitInput = {
    id: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutCustomer_profilesInput
  }

  export type CustomerUncheckedCreateWithoutUnitInput = {
    id: string
    user_id: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerCreateOrConnectWithoutUnitInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutUnitInput, CustomerUncheckedCreateWithoutUnitInput>
  }

  export type CustomerCreateManyUnitInputEnvelope = {
    data: CustomerCreateManyUnitInput | CustomerCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutUnitsInput = {
    update: XOR<OrganizationUpdateWithoutUnitsInput, OrganizationUncheckedUpdateWithoutUnitsInput>
    create: XOR<OrganizationCreateWithoutUnitsInput, OrganizationUncheckedCreateWithoutUnitsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUnitsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUnitsInput, OrganizationUncheckedUpdateWithoutUnitsInput>
  }

  export type OrganizationUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUnitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    owner_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitSpecialtyUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitSpecialtyWhereUniqueInput
    update: XOR<UnitSpecialtyUpdateWithoutUnitInput, UnitSpecialtyUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitSpecialtyCreateWithoutUnitInput, UnitSpecialtyUncheckedCreateWithoutUnitInput>
  }

  export type UnitSpecialtyUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitSpecialtyWhereUniqueInput
    data: XOR<UnitSpecialtyUpdateWithoutUnitInput, UnitSpecialtyUncheckedUpdateWithoutUnitInput>
  }

  export type UnitSpecialtyUpdateManyWithWhereWithoutUnitInput = {
    where: UnitSpecialtyScalarWhereInput
    data: XOR<UnitSpecialtyUpdateManyMutationInput, UnitSpecialtyUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitSpecialtyScalarWhereInput = {
    AND?: UnitSpecialtyScalarWhereInput | UnitSpecialtyScalarWhereInput[]
    OR?: UnitSpecialtyScalarWhereInput[]
    NOT?: UnitSpecialtyScalarWhereInput | UnitSpecialtyScalarWhereInput[]
    id?: StringFilter<"UnitSpecialty"> | string
    unit_id?: StringFilter<"UnitSpecialty"> | string
    specialty_id?: StringFilter<"UnitSpecialty"> | string
    created_at?: DateTimeFilter<"UnitSpecialty"> | Date | string
    updated_at?: DateTimeFilter<"UnitSpecialty"> | Date | string
  }

  export type UnitServiceUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitServiceWhereUniqueInput
    update: XOR<UnitServiceUpdateWithoutUnitInput, UnitServiceUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitServiceCreateWithoutUnitInput, UnitServiceUncheckedCreateWithoutUnitInput>
  }

  export type UnitServiceUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitServiceWhereUniqueInput
    data: XOR<UnitServiceUpdateWithoutUnitInput, UnitServiceUncheckedUpdateWithoutUnitInput>
  }

  export type UnitServiceUpdateManyWithWhereWithoutUnitInput = {
    where: UnitServiceScalarWhereInput
    data: XOR<UnitServiceUpdateManyMutationInput, UnitServiceUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitServiceScalarWhereInput = {
    AND?: UnitServiceScalarWhereInput | UnitServiceScalarWhereInput[]
    OR?: UnitServiceScalarWhereInput[]
    NOT?: UnitServiceScalarWhereInput | UnitServiceScalarWhereInput[]
    id?: StringFilter<"UnitService"> | string
    unit_id?: StringFilter<"UnitService"> | string
    service_id?: StringFilter<"UnitService"> | string
    custom_price_cents?: IntNullableFilter<"UnitService"> | number | null
    custom_duration_minutes?: IntNullableFilter<"UnitService"> | number | null
    is_active?: BoolFilter<"UnitService"> | boolean
    created_at?: DateTimeFilter<"UnitService"> | Date | string
    updated_at?: DateTimeFilter<"UnitService"> | Date | string
  }

  export type UnitAmenityUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitAmenityWhereUniqueInput
    update: XOR<UnitAmenityUpdateWithoutUnitInput, UnitAmenityUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitAmenityCreateWithoutUnitInput, UnitAmenityUncheckedCreateWithoutUnitInput>
  }

  export type UnitAmenityUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitAmenityWhereUniqueInput
    data: XOR<UnitAmenityUpdateWithoutUnitInput, UnitAmenityUncheckedUpdateWithoutUnitInput>
  }

  export type UnitAmenityUpdateManyWithWhereWithoutUnitInput = {
    where: UnitAmenityScalarWhereInput
    data: XOR<UnitAmenityUpdateManyMutationInput, UnitAmenityUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitAmenityScalarWhereInput = {
    AND?: UnitAmenityScalarWhereInput | UnitAmenityScalarWhereInput[]
    OR?: UnitAmenityScalarWhereInput[]
    NOT?: UnitAmenityScalarWhereInput | UnitAmenityScalarWhereInput[]
    id?: StringFilter<"UnitAmenity"> | string
    unit_id?: StringFilter<"UnitAmenity"> | string
    amenity_id?: StringFilter<"UnitAmenity"> | string
    created_at?: DateTimeFilter<"UnitAmenity"> | Date | string
    updated_at?: DateTimeFilter<"UnitAmenity"> | Date | string
  }

  export type UnitAvailabilityRuleUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitAvailabilityRuleWhereUniqueInput
    update: XOR<UnitAvailabilityRuleUpdateWithoutUnitInput, UnitAvailabilityRuleUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitAvailabilityRuleCreateWithoutUnitInput, UnitAvailabilityRuleUncheckedCreateWithoutUnitInput>
  }

  export type UnitAvailabilityRuleUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitAvailabilityRuleWhereUniqueInput
    data: XOR<UnitAvailabilityRuleUpdateWithoutUnitInput, UnitAvailabilityRuleUncheckedUpdateWithoutUnitInput>
  }

  export type UnitAvailabilityRuleUpdateManyWithWhereWithoutUnitInput = {
    where: UnitAvailabilityRuleScalarWhereInput
    data: XOR<UnitAvailabilityRuleUpdateManyMutationInput, UnitAvailabilityRuleUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitAvailabilityRuleScalarWhereInput = {
    AND?: UnitAvailabilityRuleScalarWhereInput | UnitAvailabilityRuleScalarWhereInput[]
    OR?: UnitAvailabilityRuleScalarWhereInput[]
    NOT?: UnitAvailabilityRuleScalarWhereInput | UnitAvailabilityRuleScalarWhereInput[]
    id?: StringFilter<"UnitAvailabilityRule"> | string
    unit_id?: StringFilter<"UnitAvailabilityRule"> | string
    type?: EnumUnitAvailabilityRuleTypeFilter<"UnitAvailabilityRule"> | $Enums.UnitAvailabilityRuleType
    weekday?: IntNullableFilter<"UnitAvailabilityRule"> | number | null
    date?: StringNullableFilter<"UnitAvailabilityRule"> | string | null
    start_time?: StringFilter<"UnitAvailabilityRule"> | string
    end_time?: StringFilter<"UnitAvailabilityRule"> | string
    slot_duration_minutes?: IntFilter<"UnitAvailabilityRule"> | number
    is_active?: BoolFilter<"UnitAvailabilityRule"> | boolean
    metadata?: JsonNullableFilter<"UnitAvailabilityRule">
    created_at?: DateTimeFilter<"UnitAvailabilityRule"> | Date | string
    updated_at?: DateTimeFilter<"UnitAvailabilityRule"> | Date | string
  }

  export type UnitAvailabilityExceptionUpsertWithWhereUniqueWithoutUnitInput = {
    where: UnitAvailabilityExceptionWhereUniqueInput
    update: XOR<UnitAvailabilityExceptionUpdateWithoutUnitInput, UnitAvailabilityExceptionUncheckedUpdateWithoutUnitInput>
    create: XOR<UnitAvailabilityExceptionCreateWithoutUnitInput, UnitAvailabilityExceptionUncheckedCreateWithoutUnitInput>
  }

  export type UnitAvailabilityExceptionUpdateWithWhereUniqueWithoutUnitInput = {
    where: UnitAvailabilityExceptionWhereUniqueInput
    data: XOR<UnitAvailabilityExceptionUpdateWithoutUnitInput, UnitAvailabilityExceptionUncheckedUpdateWithoutUnitInput>
  }

  export type UnitAvailabilityExceptionUpdateManyWithWhereWithoutUnitInput = {
    where: UnitAvailabilityExceptionScalarWhereInput
    data: XOR<UnitAvailabilityExceptionUpdateManyMutationInput, UnitAvailabilityExceptionUncheckedUpdateManyWithoutUnitInput>
  }

  export type UnitAvailabilityExceptionScalarWhereInput = {
    AND?: UnitAvailabilityExceptionScalarWhereInput | UnitAvailabilityExceptionScalarWhereInput[]
    OR?: UnitAvailabilityExceptionScalarWhereInput[]
    NOT?: UnitAvailabilityExceptionScalarWhereInput | UnitAvailabilityExceptionScalarWhereInput[]
    id?: StringFilter<"UnitAvailabilityException"> | string
    unit_id?: StringFilter<"UnitAvailabilityException"> | string
    date?: StringFilter<"UnitAvailabilityException"> | string
    type?: EnumUnitAvailabilityExceptionTypeFilter<"UnitAvailabilityException"> | $Enums.UnitAvailabilityExceptionType
    start_time?: StringNullableFilter<"UnitAvailabilityException"> | string | null
    end_time?: StringNullableFilter<"UnitAvailabilityException"> | string | null
    slot_duration_minutes?: IntNullableFilter<"UnitAvailabilityException"> | number | null
    reason?: StringNullableFilter<"UnitAvailabilityException"> | string | null
    created_at?: DateTimeFilter<"UnitAvailabilityException"> | Date | string
    updated_at?: DateTimeFilter<"UnitAvailabilityException"> | Date | string
  }

  export type SubscriptionUpsertWithoutUnitInput = {
    update: XOR<SubscriptionUpdateWithoutUnitInput, SubscriptionUncheckedUpdateWithoutUnitInput>
    create: XOR<SubscriptionCreateWithoutUnitInput, SubscriptionUncheckedCreateWithoutUnitInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUnitInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUnitInput, SubscriptionUncheckedUpdateWithoutUnitInput>
  }

  export type SubscriptionUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    discount?: DiscountUpdateOneWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    discount_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutUnitInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUnitInput, BookingUncheckedUpdateWithoutUnitInput>
    create: XOR<BookingCreateWithoutUnitInput, BookingUncheckedCreateWithoutUnitInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUnitInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUnitInput, BookingUncheckedUpdateWithoutUnitInput>
  }

  export type BookingUpdateManyWithWhereWithoutUnitInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUnitInput>
  }

  export type CustomerUpsertWithWhereUniqueWithoutUnitInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutUnitInput, CustomerUncheckedUpdateWithoutUnitInput>
    create: XOR<CustomerCreateWithoutUnitInput, CustomerUncheckedCreateWithoutUnitInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutUnitInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutUnitInput, CustomerUncheckedUpdateWithoutUnitInput>
  }

  export type CustomerUpdateManyWithWhereWithoutUnitInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutUnitInput>
  }

  export type ServiceCreateWithoutSpecialtyInput = {
    id: string
    code: string
    name: string
    description?: string | null
    default_duration_minutes: number
    default_price_cents: number
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    unit_services?: UnitServiceCreateNestedManyWithoutServiceInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutSpecialtyInput = {
    id: string
    code: string
    name: string
    description?: string | null
    default_duration_minutes: number
    default_price_cents: number
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    unit_services?: UnitServiceUncheckedCreateNestedManyWithoutServiceInput
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutSpecialtyInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutSpecialtyInput, ServiceUncheckedCreateWithoutSpecialtyInput>
  }

  export type ServiceCreateManySpecialtyInputEnvelope = {
    data: ServiceCreateManySpecialtyInput | ServiceCreateManySpecialtyInput[]
    skipDuplicates?: boolean
  }

  export type UnitSpecialtyCreateWithoutSpecialtyInput = {
    id: string
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutUnit_specialtiesInput
  }

  export type UnitSpecialtyUncheckedCreateWithoutSpecialtyInput = {
    id: string
    unit_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitSpecialtyCreateOrConnectWithoutSpecialtyInput = {
    where: UnitSpecialtyWhereUniqueInput
    create: XOR<UnitSpecialtyCreateWithoutSpecialtyInput, UnitSpecialtyUncheckedCreateWithoutSpecialtyInput>
  }

  export type UnitSpecialtyCreateManySpecialtyInputEnvelope = {
    data: UnitSpecialtyCreateManySpecialtyInput | UnitSpecialtyCreateManySpecialtyInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutSpecialtyInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutSpecialtyInput, ServiceUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<ServiceCreateWithoutSpecialtyInput, ServiceUncheckedCreateWithoutSpecialtyInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutSpecialtyInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutSpecialtyInput, ServiceUncheckedUpdateWithoutSpecialtyInput>
  }

  export type ServiceUpdateManyWithWhereWithoutSpecialtyInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutSpecialtyInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    specialty_id?: StringFilter<"Service"> | string
    code?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    default_duration_minutes?: IntFilter<"Service"> | number
    default_price_cents?: IntFilter<"Service"> | number
    is_predefined?: BoolFilter<"Service"> | boolean
    is_active?: BoolFilter<"Service"> | boolean
    created_at?: DateTimeFilter<"Service"> | Date | string
    updated_at?: DateTimeFilter<"Service"> | Date | string
  }

  export type UnitSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput = {
    where: UnitSpecialtyWhereUniqueInput
    update: XOR<UnitSpecialtyUpdateWithoutSpecialtyInput, UnitSpecialtyUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<UnitSpecialtyCreateWithoutSpecialtyInput, UnitSpecialtyUncheckedCreateWithoutSpecialtyInput>
  }

  export type UnitSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput = {
    where: UnitSpecialtyWhereUniqueInput
    data: XOR<UnitSpecialtyUpdateWithoutSpecialtyInput, UnitSpecialtyUncheckedUpdateWithoutSpecialtyInput>
  }

  export type UnitSpecialtyUpdateManyWithWhereWithoutSpecialtyInput = {
    where: UnitSpecialtyScalarWhereInput
    data: XOR<UnitSpecialtyUpdateManyMutationInput, UnitSpecialtyUncheckedUpdateManyWithoutSpecialtyInput>
  }

  export type UnitAmenityCreateWithoutAmenityInput = {
    id: string
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutUnit_amenitiesInput
  }

  export type UnitAmenityUncheckedCreateWithoutAmenityInput = {
    id: string
    unit_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAmenityCreateOrConnectWithoutAmenityInput = {
    where: UnitAmenityWhereUniqueInput
    create: XOR<UnitAmenityCreateWithoutAmenityInput, UnitAmenityUncheckedCreateWithoutAmenityInput>
  }

  export type UnitAmenityCreateManyAmenityInputEnvelope = {
    data: UnitAmenityCreateManyAmenityInput | UnitAmenityCreateManyAmenityInput[]
    skipDuplicates?: boolean
  }

  export type UnitAmenityUpsertWithWhereUniqueWithoutAmenityInput = {
    where: UnitAmenityWhereUniqueInput
    update: XOR<UnitAmenityUpdateWithoutAmenityInput, UnitAmenityUncheckedUpdateWithoutAmenityInput>
    create: XOR<UnitAmenityCreateWithoutAmenityInput, UnitAmenityUncheckedCreateWithoutAmenityInput>
  }

  export type UnitAmenityUpdateWithWhereUniqueWithoutAmenityInput = {
    where: UnitAmenityWhereUniqueInput
    data: XOR<UnitAmenityUpdateWithoutAmenityInput, UnitAmenityUncheckedUpdateWithoutAmenityInput>
  }

  export type UnitAmenityUpdateManyWithWhereWithoutAmenityInput = {
    where: UnitAmenityScalarWhereInput
    data: XOR<UnitAmenityUpdateManyMutationInput, UnitAmenityUncheckedUpdateManyWithoutAmenityInput>
  }

  export type SpecialtyCreateWithoutServicesInput = {
    id: string
    code: string
    name: string
    description?: string | null
    icon: string
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    unit_specialties?: UnitSpecialtyCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutServicesInput = {
    id: string
    code: string
    name: string
    description?: string | null
    icon: string
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    unit_specialties?: UnitSpecialtyUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutServicesInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutServicesInput, SpecialtyUncheckedCreateWithoutServicesInput>
  }

  export type UnitServiceCreateWithoutServiceInput = {
    id: string
    custom_price_cents?: number | null
    custom_duration_minutes?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutUnit_servicesInput
  }

  export type UnitServiceUncheckedCreateWithoutServiceInput = {
    id: string
    unit_id: string
    custom_price_cents?: number | null
    custom_duration_minutes?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitServiceCreateOrConnectWithoutServiceInput = {
    where: UnitServiceWhereUniqueInput
    create: XOR<UnitServiceCreateWithoutServiceInput, UnitServiceUncheckedCreateWithoutServiceInput>
  }

  export type UnitServiceCreateManyServiceInputEnvelope = {
    data: UnitServiceCreateManyServiceInput | UnitServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutServiceInput = {
    id: string
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutBookings_as_ownerInput
    client: UserCreateNestedOneWithoutBookings_as_clientInput
    unit: UnitCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutServiceInput = {
    id: string
    user_id: string
    client_id: string
    unit_id: string
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingCreateOrConnectWithoutServiceInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput>
  }

  export type BookingCreateManyServiceInputEnvelope = {
    data: BookingCreateManyServiceInput | BookingCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type SpecialtyUpsertWithoutServicesInput = {
    update: XOR<SpecialtyUpdateWithoutServicesInput, SpecialtyUncheckedUpdateWithoutServicesInput>
    create: XOR<SpecialtyCreateWithoutServicesInput, SpecialtyUncheckedCreateWithoutServicesInput>
    where?: SpecialtyWhereInput
  }

  export type SpecialtyUpdateToOneWithWhereWithoutServicesInput = {
    where?: SpecialtyWhereInput
    data: XOR<SpecialtyUpdateWithoutServicesInput, SpecialtyUncheckedUpdateWithoutServicesInput>
  }

  export type SpecialtyUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_specialties?: UnitSpecialtyUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_specialties?: UnitSpecialtyUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type UnitServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: UnitServiceWhereUniqueInput
    update: XOR<UnitServiceUpdateWithoutServiceInput, UnitServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<UnitServiceCreateWithoutServiceInput, UnitServiceUncheckedCreateWithoutServiceInput>
  }

  export type UnitServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: UnitServiceWhereUniqueInput
    data: XOR<UnitServiceUpdateWithoutServiceInput, UnitServiceUncheckedUpdateWithoutServiceInput>
  }

  export type UnitServiceUpdateManyWithWhereWithoutServiceInput = {
    where: UnitServiceScalarWhereInput
    data: XOR<UnitServiceUpdateManyMutationInput, UnitServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutServiceInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutServiceInput, BookingUncheckedUpdateWithoutServiceInput>
    create: XOR<BookingCreateWithoutServiceInput, BookingUncheckedCreateWithoutServiceInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutServiceInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutServiceInput, BookingUncheckedUpdateWithoutServiceInput>
  }

  export type BookingUpdateManyWithWhereWithoutServiceInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutServiceInput>
  }

  export type UnitCreateWithoutUnit_specialtiesInput = {
    id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    organization: OrganizationCreateNestedOneWithoutUnitsInput
    unit_services?: UnitServiceCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionCreateNestedOneWithoutUnitInput
    bookings?: BookingCreateNestedManyWithoutUnitInput
    customers?: CustomerCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutUnit_specialtiesInput = {
    id: string
    organization_id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit_services?: UnitServiceUncheckedCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionUncheckedCreateNestedOneWithoutUnitInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUnitInput
    customers?: CustomerUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutUnit_specialtiesInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutUnit_specialtiesInput, UnitUncheckedCreateWithoutUnit_specialtiesInput>
  }

  export type SpecialtyCreateWithoutUnit_specialtiesInput = {
    id: string
    code: string
    name: string
    description?: string | null
    icon: string
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    services?: ServiceCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutUnit_specialtiesInput = {
    id: string
    code: string
    name: string
    description?: string | null
    icon: string
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutUnit_specialtiesInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutUnit_specialtiesInput, SpecialtyUncheckedCreateWithoutUnit_specialtiesInput>
  }

  export type UnitUpsertWithoutUnit_specialtiesInput = {
    update: XOR<UnitUpdateWithoutUnit_specialtiesInput, UnitUncheckedUpdateWithoutUnit_specialtiesInput>
    create: XOR<UnitCreateWithoutUnit_specialtiesInput, UnitUncheckedCreateWithoutUnit_specialtiesInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutUnit_specialtiesInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutUnit_specialtiesInput, UnitUncheckedUpdateWithoutUnit_specialtiesInput>
  }

  export type UnitUpdateWithoutUnit_specialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUnitsNestedInput
    unit_services?: UnitServiceUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUpdateOneWithoutUnitNestedInput
    bookings?: BookingUpdateManyWithoutUnitNestedInput
    customers?: CustomerUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutUnit_specialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_services?: UnitServiceUncheckedUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUncheckedUpdateOneWithoutUnitNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUnitNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type SpecialtyUpsertWithoutUnit_specialtiesInput = {
    update: XOR<SpecialtyUpdateWithoutUnit_specialtiesInput, SpecialtyUncheckedUpdateWithoutUnit_specialtiesInput>
    create: XOR<SpecialtyCreateWithoutUnit_specialtiesInput, SpecialtyUncheckedCreateWithoutUnit_specialtiesInput>
    where?: SpecialtyWhereInput
  }

  export type SpecialtyUpdateToOneWithWhereWithoutUnit_specialtiesInput = {
    where?: SpecialtyWhereInput
    data: XOR<SpecialtyUpdateWithoutUnit_specialtiesInput, SpecialtyUncheckedUpdateWithoutUnit_specialtiesInput>
  }

  export type SpecialtyUpdateWithoutUnit_specialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutUnit_specialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type UnitCreateWithoutUnit_amenitiesInput = {
    id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    organization: OrganizationCreateNestedOneWithoutUnitsInput
    unit_specialties?: UnitSpecialtyCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionCreateNestedOneWithoutUnitInput
    bookings?: BookingCreateNestedManyWithoutUnitInput
    customers?: CustomerCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutUnit_amenitiesInput = {
    id: string
    organization_id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit_specialties?: UnitSpecialtyUncheckedCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionUncheckedCreateNestedOneWithoutUnitInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUnitInput
    customers?: CustomerUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutUnit_amenitiesInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutUnit_amenitiesInput, UnitUncheckedCreateWithoutUnit_amenitiesInput>
  }

  export type AmenityCreateWithoutUnit_amenitiesInput = {
    id: string
    code: string
    name: string
    description?: string | null
    icon: string
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AmenityUncheckedCreateWithoutUnit_amenitiesInput = {
    id: string
    code: string
    name: string
    description?: string | null
    icon: string
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AmenityCreateOrConnectWithoutUnit_amenitiesInput = {
    where: AmenityWhereUniqueInput
    create: XOR<AmenityCreateWithoutUnit_amenitiesInput, AmenityUncheckedCreateWithoutUnit_amenitiesInput>
  }

  export type UnitUpsertWithoutUnit_amenitiesInput = {
    update: XOR<UnitUpdateWithoutUnit_amenitiesInput, UnitUncheckedUpdateWithoutUnit_amenitiesInput>
    create: XOR<UnitCreateWithoutUnit_amenitiesInput, UnitUncheckedCreateWithoutUnit_amenitiesInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutUnit_amenitiesInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutUnit_amenitiesInput, UnitUncheckedUpdateWithoutUnit_amenitiesInput>
  }

  export type UnitUpdateWithoutUnit_amenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUnitsNestedInput
    unit_specialties?: UnitSpecialtyUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUpdateOneWithoutUnitNestedInput
    bookings?: BookingUpdateManyWithoutUnitNestedInput
    customers?: CustomerUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutUnit_amenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_specialties?: UnitSpecialtyUncheckedUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUncheckedUpdateOneWithoutUnitNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUnitNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type AmenityUpsertWithoutUnit_amenitiesInput = {
    update: XOR<AmenityUpdateWithoutUnit_amenitiesInput, AmenityUncheckedUpdateWithoutUnit_amenitiesInput>
    create: XOR<AmenityCreateWithoutUnit_amenitiesInput, AmenityUncheckedCreateWithoutUnit_amenitiesInput>
    where?: AmenityWhereInput
  }

  export type AmenityUpdateToOneWithWhereWithoutUnit_amenitiesInput = {
    where?: AmenityWhereInput
    data: XOR<AmenityUpdateWithoutUnit_amenitiesInput, AmenityUncheckedUpdateWithoutUnit_amenitiesInput>
  }

  export type AmenityUpdateWithoutUnit_amenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUncheckedUpdateWithoutUnit_amenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateWithoutUnit_servicesInput = {
    id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    organization: OrganizationCreateNestedOneWithoutUnitsInput
    unit_specialties?: UnitSpecialtyCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionCreateNestedOneWithoutUnitInput
    bookings?: BookingCreateNestedManyWithoutUnitInput
    customers?: CustomerCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutUnit_servicesInput = {
    id: string
    organization_id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit_specialties?: UnitSpecialtyUncheckedCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionUncheckedCreateNestedOneWithoutUnitInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUnitInput
    customers?: CustomerUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutUnit_servicesInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutUnit_servicesInput, UnitUncheckedCreateWithoutUnit_servicesInput>
  }

  export type ServiceCreateWithoutUnit_servicesInput = {
    id: string
    code: string
    name: string
    description?: string | null
    default_duration_minutes: number
    default_price_cents: number
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    specialty: SpecialtyCreateNestedOneWithoutServicesInput
    bookings?: BookingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutUnit_servicesInput = {
    id: string
    specialty_id: string
    code: string
    name: string
    description?: string | null
    default_duration_minutes: number
    default_price_cents: number
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutUnit_servicesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutUnit_servicesInput, ServiceUncheckedCreateWithoutUnit_servicesInput>
  }

  export type UnitUpsertWithoutUnit_servicesInput = {
    update: XOR<UnitUpdateWithoutUnit_servicesInput, UnitUncheckedUpdateWithoutUnit_servicesInput>
    create: XOR<UnitCreateWithoutUnit_servicesInput, UnitUncheckedCreateWithoutUnit_servicesInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutUnit_servicesInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutUnit_servicesInput, UnitUncheckedUpdateWithoutUnit_servicesInput>
  }

  export type UnitUpdateWithoutUnit_servicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUnitsNestedInput
    unit_specialties?: UnitSpecialtyUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUpdateOneWithoutUnitNestedInput
    bookings?: BookingUpdateManyWithoutUnitNestedInput
    customers?: CustomerUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutUnit_servicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_specialties?: UnitSpecialtyUncheckedUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUncheckedUpdateOneWithoutUnitNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUnitNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ServiceUpsertWithoutUnit_servicesInput = {
    update: XOR<ServiceUpdateWithoutUnit_servicesInput, ServiceUncheckedUpdateWithoutUnit_servicesInput>
    create: XOR<ServiceCreateWithoutUnit_servicesInput, ServiceUncheckedCreateWithoutUnit_servicesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutUnit_servicesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutUnit_servicesInput, ServiceUncheckedUpdateWithoutUnit_servicesInput>
  }

  export type ServiceUpdateWithoutUnit_servicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    default_duration_minutes?: IntFieldUpdateOperationsInput | number
    default_price_cents?: IntFieldUpdateOperationsInput | number
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    specialty?: SpecialtyUpdateOneRequiredWithoutServicesNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutUnit_servicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialty_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    default_duration_minutes?: IntFieldUpdateOperationsInput | number
    default_price_cents?: IntFieldUpdateOperationsInput | number
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserCreateWithoutBookings_as_ownerInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationCreateNestedOneWithoutOwnerInput
    bookings_as_client?: BookingCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookings_as_ownerInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationUncheckedCreateNestedOneWithoutOwnerInput
    bookings_as_client?: BookingUncheckedCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleUncheckedCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookings_as_ownerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookings_as_ownerInput, UserUncheckedCreateWithoutBookings_as_ownerInput>
  }

  export type UserCreateWithoutBookings_as_clientInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingCreateNestedManyWithoutOwnerInput
    booking_rules?: BookingRuleCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookings_as_clientInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationUncheckedCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    booking_rules?: BookingRuleUncheckedCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookings_as_clientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookings_as_clientInput, UserUncheckedCreateWithoutBookings_as_clientInput>
  }

  export type UnitCreateWithoutBookingsInput = {
    id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    organization: OrganizationCreateNestedOneWithoutUnitsInput
    unit_specialties?: UnitSpecialtyCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionCreateNestedOneWithoutUnitInput
    customers?: CustomerCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutBookingsInput = {
    id: string
    organization_id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit_specialties?: UnitSpecialtyUncheckedCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceUncheckedCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionUncheckedCreateNestedOneWithoutUnitInput
    customers?: CustomerUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutBookingsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutBookingsInput, UnitUncheckedCreateWithoutBookingsInput>
  }

  export type ServiceCreateWithoutBookingsInput = {
    id: string
    code: string
    name: string
    description?: string | null
    default_duration_minutes: number
    default_price_cents: number
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    specialty: SpecialtyCreateNestedOneWithoutServicesInput
    unit_services?: UnitServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutBookingsInput = {
    id: string
    specialty_id: string
    code: string
    name: string
    description?: string | null
    default_duration_minutes: number
    default_price_cents: number
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    unit_services?: UnitServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutBookingsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
  }

  export type UserUpsertWithoutBookings_as_ownerInput = {
    update: XOR<UserUpdateWithoutBookings_as_ownerInput, UserUncheckedUpdateWithoutBookings_as_ownerInput>
    create: XOR<UserCreateWithoutBookings_as_ownerInput, UserUncheckedCreateWithoutBookings_as_ownerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookings_as_ownerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookings_as_ownerInput, UserUncheckedUpdateWithoutBookings_as_ownerInput>
  }

  export type UserUpdateWithoutBookings_as_ownerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutOwnerNestedInput
    bookings_as_client?: BookingUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookings_as_ownerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUncheckedUpdateOneWithoutOwnerNestedInput
    bookings_as_client?: BookingUncheckedUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUncheckedUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutBookings_as_clientInput = {
    update: XOR<UserUpdateWithoutBookings_as_clientInput, UserUncheckedUpdateWithoutBookings_as_clientInput>
    create: XOR<UserCreateWithoutBookings_as_clientInput, UserUncheckedCreateWithoutBookings_as_clientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookings_as_clientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookings_as_clientInput, UserUncheckedUpdateWithoutBookings_as_clientInput>
  }

  export type UserUpdateWithoutBookings_as_clientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUpdateManyWithoutOwnerNestedInput
    booking_rules?: BookingRuleUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookings_as_clientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUncheckedUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    booking_rules?: BookingRuleUncheckedUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UnitUpsertWithoutBookingsInput = {
    update: XOR<UnitUpdateWithoutBookingsInput, UnitUncheckedUpdateWithoutBookingsInput>
    create: XOR<UnitCreateWithoutBookingsInput, UnitUncheckedCreateWithoutBookingsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutBookingsInput, UnitUncheckedUpdateWithoutBookingsInput>
  }

  export type UnitUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUnitsNestedInput
    unit_specialties?: UnitSpecialtyUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUpdateOneWithoutUnitNestedInput
    customers?: CustomerUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_specialties?: UnitSpecialtyUncheckedUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUncheckedUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUncheckedUpdateOneWithoutUnitNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ServiceUpsertWithoutBookingsInput = {
    update: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
    create: XOR<ServiceCreateWithoutBookingsInput, ServiceUncheckedCreateWithoutBookingsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBookingsInput, ServiceUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    default_duration_minutes?: IntFieldUpdateOperationsInput | number
    default_price_cents?: IntFieldUpdateOperationsInput | number
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    specialty?: SpecialtyUpdateOneRequiredWithoutServicesNestedInput
    unit_services?: UnitServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialty_id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    default_duration_minutes?: IntFieldUpdateOperationsInput | number
    default_price_cents?: IntFieldUpdateOperationsInput | number
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_services?: UnitServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserCreateWithoutCustomer_profilesInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomer_profilesInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationUncheckedCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingUncheckedCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleUncheckedCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomer_profilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomer_profilesInput, UserUncheckedCreateWithoutCustomer_profilesInput>
  }

  export type UnitCreateWithoutCustomersInput = {
    id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    organization: OrganizationCreateNestedOneWithoutUnitsInput
    unit_specialties?: UnitSpecialtyCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionCreateNestedOneWithoutUnitInput
    bookings?: BookingCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutCustomersInput = {
    id: string
    organization_id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit_specialties?: UnitSpecialtyUncheckedCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceUncheckedCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionUncheckedCreateNestedOneWithoutUnitInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutCustomersInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutCustomersInput, UnitUncheckedCreateWithoutCustomersInput>
  }

  export type UserUpsertWithoutCustomer_profilesInput = {
    update: XOR<UserUpdateWithoutCustomer_profilesInput, UserUncheckedUpdateWithoutCustomer_profilesInput>
    create: XOR<UserCreateWithoutCustomer_profilesInput, UserUncheckedCreateWithoutCustomer_profilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomer_profilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomer_profilesInput, UserUncheckedUpdateWithoutCustomer_profilesInput>
  }

  export type UserUpdateWithoutCustomer_profilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomer_profilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUncheckedUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUncheckedUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUncheckedUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UnitUpsertWithoutCustomersInput = {
    update: XOR<UnitUpdateWithoutCustomersInput, UnitUncheckedUpdateWithoutCustomersInput>
    create: XOR<UnitCreateWithoutCustomersInput, UnitUncheckedCreateWithoutCustomersInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutCustomersInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutCustomersInput, UnitUncheckedUpdateWithoutCustomersInput>
  }

  export type UnitUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUnitsNestedInput
    unit_specialties?: UnitSpecialtyUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUpdateOneWithoutUnitNestedInput
    bookings?: BookingUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_specialties?: UnitSpecialtyUncheckedUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUncheckedUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUncheckedUpdateOneWithoutUnitNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UserCreateWithoutBooking_rulesInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingCreateNestedManyWithoutClientInput
    booking_exceptions?: BookingExceptionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBooking_rulesInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationUncheckedCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingUncheckedCreateNestedManyWithoutClientInput
    booking_exceptions?: BookingExceptionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBooking_rulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBooking_rulesInput, UserUncheckedCreateWithoutBooking_rulesInput>
  }

  export type UserUpsertWithoutBooking_rulesInput = {
    update: XOR<UserUpdateWithoutBooking_rulesInput, UserUncheckedUpdateWithoutBooking_rulesInput>
    create: XOR<UserCreateWithoutBooking_rulesInput, UserUncheckedCreateWithoutBooking_rulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBooking_rulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBooking_rulesInput, UserUncheckedUpdateWithoutBooking_rulesInput>
  }

  export type UserUpdateWithoutBooking_rulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUpdateManyWithoutClientNestedInput
    booking_exceptions?: BookingExceptionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBooking_rulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUncheckedUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUncheckedUpdateManyWithoutClientNestedInput
    booking_exceptions?: BookingExceptionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBooking_exceptionsInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBooking_exceptionsInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationUncheckedCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingUncheckedCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBooking_exceptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBooking_exceptionsInput, UserUncheckedCreateWithoutBooking_exceptionsInput>
  }

  export type UserUpsertWithoutBooking_exceptionsInput = {
    update: XOR<UserUpdateWithoutBooking_exceptionsInput, UserUncheckedUpdateWithoutBooking_exceptionsInput>
    create: XOR<UserCreateWithoutBooking_exceptionsInput, UserUncheckedCreateWithoutBooking_exceptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBooking_exceptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBooking_exceptionsInput, UserUncheckedUpdateWithoutBooking_exceptionsInput>
  }

  export type UserUpdateWithoutBooking_exceptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBooking_exceptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUncheckedUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUncheckedUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UnitCreateWithoutUnit_availability_rulesInput = {
    id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    organization: OrganizationCreateNestedOneWithoutUnitsInput
    unit_specialties?: UnitSpecialtyCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionCreateNestedOneWithoutUnitInput
    bookings?: BookingCreateNestedManyWithoutUnitInput
    customers?: CustomerCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutUnit_availability_rulesInput = {
    id: string
    organization_id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit_specialties?: UnitSpecialtyUncheckedCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceUncheckedCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionUncheckedCreateNestedOneWithoutUnitInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUnitInput
    customers?: CustomerUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutUnit_availability_rulesInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutUnit_availability_rulesInput, UnitUncheckedCreateWithoutUnit_availability_rulesInput>
  }

  export type UnitUpsertWithoutUnit_availability_rulesInput = {
    update: XOR<UnitUpdateWithoutUnit_availability_rulesInput, UnitUncheckedUpdateWithoutUnit_availability_rulesInput>
    create: XOR<UnitCreateWithoutUnit_availability_rulesInput, UnitUncheckedCreateWithoutUnit_availability_rulesInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutUnit_availability_rulesInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutUnit_availability_rulesInput, UnitUncheckedUpdateWithoutUnit_availability_rulesInput>
  }

  export type UnitUpdateWithoutUnit_availability_rulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUnitsNestedInput
    unit_specialties?: UnitSpecialtyUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUpdateOneWithoutUnitNestedInput
    bookings?: BookingUpdateManyWithoutUnitNestedInput
    customers?: CustomerUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutUnit_availability_rulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_specialties?: UnitSpecialtyUncheckedUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUncheckedUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUncheckedUpdateOneWithoutUnitNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUnitNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateWithoutUnit_availability_exceptionsInput = {
    id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    organization: OrganizationCreateNestedOneWithoutUnitsInput
    unit_specialties?: UnitSpecialtyCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionCreateNestedOneWithoutUnitInput
    bookings?: BookingCreateNestedManyWithoutUnitInput
    customers?: CustomerCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutUnit_availability_exceptionsInput = {
    id: string
    organization_id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit_specialties?: UnitSpecialtyUncheckedCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceUncheckedCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedCreateNestedManyWithoutUnitInput
    subscription_record?: SubscriptionUncheckedCreateNestedOneWithoutUnitInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUnitInput
    customers?: CustomerUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutUnit_availability_exceptionsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutUnit_availability_exceptionsInput, UnitUncheckedCreateWithoutUnit_availability_exceptionsInput>
  }

  export type UnitUpsertWithoutUnit_availability_exceptionsInput = {
    update: XOR<UnitUpdateWithoutUnit_availability_exceptionsInput, UnitUncheckedUpdateWithoutUnit_availability_exceptionsInput>
    create: XOR<UnitCreateWithoutUnit_availability_exceptionsInput, UnitUncheckedCreateWithoutUnit_availability_exceptionsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutUnit_availability_exceptionsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutUnit_availability_exceptionsInput, UnitUncheckedUpdateWithoutUnit_availability_exceptionsInput>
  }

  export type UnitUpdateWithoutUnit_availability_exceptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUnitsNestedInput
    unit_specialties?: UnitSpecialtyUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUpdateOneWithoutUnitNestedInput
    bookings?: BookingUpdateManyWithoutUnitNestedInput
    customers?: CustomerUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutUnit_availability_exceptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_specialties?: UnitSpecialtyUncheckedUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUncheckedUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUncheckedUpdateOneWithoutUnitNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUnitNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutSubscription_recordInput
    user: UserCreateNestedOneWithoutSubscriptionsInput
    discount?: DiscountCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id: string
    unit_id: string
    user_id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    discount_id?: string | null
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type UnitCreateWithoutSubscription_recordInput = {
    id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    organization: OrganizationCreateNestedOneWithoutUnitsInput
    unit_specialties?: UnitSpecialtyCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionCreateNestedManyWithoutUnitInput
    bookings?: BookingCreateNestedManyWithoutUnitInput
    customers?: CustomerCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutSubscription_recordInput = {
    id: string
    organization_id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit_specialties?: UnitSpecialtyUncheckedCreateNestedManyWithoutUnitInput
    unit_services?: UnitServiceUncheckedCreateNestedManyWithoutUnitInput
    unit_amenities?: UnitAmenityUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedCreateNestedManyWithoutUnitInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedCreateNestedManyWithoutUnitInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUnitInput
    customers?: CustomerUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutSubscription_recordInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutSubscription_recordInput, UnitUncheckedCreateWithoutSubscription_recordInput>
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationUncheckedCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingUncheckedCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleUncheckedCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PlanCreateWithoutSubscriptionsInput = {
    id: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval: $Enums.RenewalInterval
    features: JsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    trial_days?: number | null
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlanUncheckedCreateWithoutSubscriptionsInput = {
    id: string
    name: string
    description?: string | null
    price: number
    currency?: string
    interval: $Enums.RenewalInterval
    features: JsonNullValueInput | InputJsonValue
    limits: JsonNullValueInput | InputJsonValue
    trial_days?: number | null
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PlanCreateOrConnectWithoutSubscriptionsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type DiscountCreateWithoutSubscriptionsInput = {
    id: string
    code: string
    type: $Enums.DiscountType
    value: number
    duration: $Enums.DiscountDuration
    repeating_count?: number | null
    assigned_to_user_id?: string | null
    max_redemptions?: number | null
    redemptions_count?: number
    expires_at?: Date | string | null
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DiscountUncheckedCreateWithoutSubscriptionsInput = {
    id: string
    code: string
    type: $Enums.DiscountType
    value: number
    duration: $Enums.DiscountDuration
    repeating_count?: number | null
    assigned_to_user_id?: string | null
    max_redemptions?: number | null
    redemptions_count?: number
    expires_at?: Date | string | null
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DiscountCreateOrConnectWithoutSubscriptionsInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutSubscriptionsInput, DiscountUncheckedCreateWithoutSubscriptionsInput>
  }

  export type InvoiceCreateWithoutSubscriptionInput = {
    id: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    line_items: JsonNullValueInput | InputJsonValue
    due_date: Date | string
    paid_at?: Date | string | null
    provider_invoice_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutSubscriptionInput = {
    id: string
    user_id: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    line_items: JsonNullValueInput | InputJsonValue
    due_date: Date | string
    paid_at?: Date | string | null
    provider_invoice_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type InvoiceCreateManySubscriptionInputEnvelope = {
    data: InvoiceCreateManySubscriptionInput | InvoiceCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type CouponRedemptionCreateWithoutSubscriptionInput = {
    id: string
    coupon_id: string
    redeemed_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutCoupon_redemptionsInput
  }

  export type CouponRedemptionUncheckedCreateWithoutSubscriptionInput = {
    id: string
    coupon_id: string
    user_id: string
    redeemed_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CouponRedemptionCreateOrConnectWithoutSubscriptionInput = {
    where: CouponRedemptionWhereUniqueInput
    create: XOR<CouponRedemptionCreateWithoutSubscriptionInput, CouponRedemptionUncheckedCreateWithoutSubscriptionInput>
  }

  export type CouponRedemptionCreateManySubscriptionInputEnvelope = {
    data: CouponRedemptionCreateManySubscriptionInput | CouponRedemptionCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type UnitUpsertWithoutSubscription_recordInput = {
    update: XOR<UnitUpdateWithoutSubscription_recordInput, UnitUncheckedUpdateWithoutSubscription_recordInput>
    create: XOR<UnitCreateWithoutSubscription_recordInput, UnitUncheckedCreateWithoutSubscription_recordInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutSubscription_recordInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutSubscription_recordInput, UnitUncheckedUpdateWithoutSubscription_recordInput>
  }

  export type UnitUpdateWithoutSubscription_recordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUnitsNestedInput
    unit_specialties?: UnitSpecialtyUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUpdateManyWithoutUnitNestedInput
    bookings?: BookingUpdateManyWithoutUnitNestedInput
    customers?: CustomerUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutSubscription_recordInput = {
    id?: StringFieldUpdateOperationsInput | string
    organization_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_specialties?: UnitSpecialtyUncheckedUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUncheckedUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedUpdateManyWithoutUnitNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUnitNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUncheckedUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUncheckedUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUncheckedUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlanUpsertWithoutSubscriptionsInput = {
    update: XOR<PlanUpdateWithoutSubscriptionsInput, PlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutSubscriptionsInput, PlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    features?: JsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    trial_days?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    features?: JsonNullValueInput | InputJsonValue
    limits?: JsonNullValueInput | InputJsonValue
    trial_days?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUpsertWithoutSubscriptionsInput = {
    update: XOR<DiscountUpdateWithoutSubscriptionsInput, DiscountUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<DiscountCreateWithoutSubscriptionsInput, DiscountUncheckedCreateWithoutSubscriptionsInput>
    where?: DiscountWhereInput
  }

  export type DiscountUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: DiscountWhereInput
    data: XOR<DiscountUpdateWithoutSubscriptionsInput, DiscountUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type DiscountUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: IntFieldUpdateOperationsInput | number
    duration?: EnumDiscountDurationFieldUpdateOperationsInput | $Enums.DiscountDuration
    repeating_count?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_to_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    max_redemptions?: NullableIntFieldUpdateOperationsInput | number | null
    redemptions_count?: IntFieldUpdateOperationsInput | number
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: IntFieldUpdateOperationsInput | number
    duration?: EnumDiscountDurationFieldUpdateOperationsInput | $Enums.DiscountDuration
    repeating_count?: NullableIntFieldUpdateOperationsInput | number | null
    assigned_to_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    max_redemptions?: NullableIntFieldUpdateOperationsInput | number | null
    redemptions_count?: IntFieldUpdateOperationsInput | number
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutSubscriptionInput, InvoiceUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<InvoiceCreateWithoutSubscriptionInput, InvoiceUncheckedCreateWithoutSubscriptionInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutSubscriptionInput, InvoiceUncheckedUpdateWithoutSubscriptionInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutSubscriptionInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type CouponRedemptionUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: CouponRedemptionWhereUniqueInput
    update: XOR<CouponRedemptionUpdateWithoutSubscriptionInput, CouponRedemptionUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<CouponRedemptionCreateWithoutSubscriptionInput, CouponRedemptionUncheckedCreateWithoutSubscriptionInput>
  }

  export type CouponRedemptionUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: CouponRedemptionWhereUniqueInput
    data: XOR<CouponRedemptionUpdateWithoutSubscriptionInput, CouponRedemptionUncheckedUpdateWithoutSubscriptionInput>
  }

  export type CouponRedemptionUpdateManyWithWhereWithoutSubscriptionInput = {
    where: CouponRedemptionScalarWhereInput
    data: XOR<CouponRedemptionUpdateManyMutationInput, CouponRedemptionUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type UserCreateWithoutInvoicesInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationUncheckedCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingUncheckedCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleUncheckedCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type SubscriptionCreateWithoutInvoicesInput = {
    id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutSubscription_recordInput
    user: UserCreateNestedOneWithoutSubscriptionsInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    discount?: DiscountCreateNestedOneWithoutSubscriptionsInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutInvoicesInput = {
    id: string
    unit_id: string
    user_id: string
    plan_id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    discount_id?: string | null
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutInvoicesInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
  }

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUncheckedUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUncheckedUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUncheckedUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionUpsertWithoutInvoicesInput = {
    update: XOR<SubscriptionUpdateWithoutInvoicesInput, SubscriptionUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SubscriptionCreateWithoutInvoicesInput, SubscriptionUncheckedCreateWithoutInvoicesInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutInvoicesInput, SubscriptionUncheckedUpdateWithoutInvoicesInput>
  }

  export type SubscriptionUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutSubscription_recordNestedInput
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    discount?: DiscountUpdateOneWithoutSubscriptionsNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    discount_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateWithoutDiscountInput = {
    id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutSubscription_recordInput
    user: UserCreateNestedOneWithoutSubscriptionsInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutDiscountInput = {
    id: string
    unit_id: string
    user_id: string
    plan_id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutDiscountInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutDiscountInput, SubscriptionUncheckedCreateWithoutDiscountInput>
  }

  export type SubscriptionCreateManyDiscountInputEnvelope = {
    data: SubscriptionCreateManyDiscountInput | SubscriptionCreateManyDiscountInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutDiscountInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutDiscountInput, SubscriptionUncheckedUpdateWithoutDiscountInput>
    create: XOR<SubscriptionCreateWithoutDiscountInput, SubscriptionUncheckedCreateWithoutDiscountInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutDiscountInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutDiscountInput, SubscriptionUncheckedUpdateWithoutDiscountInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutDiscountInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutDiscountInput>
  }

  export type UserCreateWithoutCoupon_redemptionsInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoupon_redemptionsInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationUncheckedCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingUncheckedCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleUncheckedCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoupon_redemptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoupon_redemptionsInput, UserUncheckedCreateWithoutCoupon_redemptionsInput>
  }

  export type SubscriptionCreateWithoutCoupon_redemptionsInput = {
    id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    unit: UnitCreateNestedOneWithoutSubscription_recordInput
    user: UserCreateNestedOneWithoutSubscriptionsInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    discount?: DiscountCreateNestedOneWithoutSubscriptionsInput
    invoices?: InvoiceCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutCoupon_redemptionsInput = {
    id: string
    unit_id: string
    user_id: string
    plan_id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    discount_id?: string | null
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutCoupon_redemptionsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutCoupon_redemptionsInput, SubscriptionUncheckedCreateWithoutCoupon_redemptionsInput>
  }

  export type UserUpsertWithoutCoupon_redemptionsInput = {
    update: XOR<UserUpdateWithoutCoupon_redemptionsInput, UserUncheckedUpdateWithoutCoupon_redemptionsInput>
    create: XOR<UserCreateWithoutCoupon_redemptionsInput, UserUncheckedCreateWithoutCoupon_redemptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoupon_redemptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoupon_redemptionsInput, UserUncheckedUpdateWithoutCoupon_redemptionsInput>
  }

  export type UserUpdateWithoutCoupon_redemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoupon_redemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUncheckedUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUncheckedUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUncheckedUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SubscriptionUpsertWithoutCoupon_redemptionsInput = {
    update: XOR<SubscriptionUpdateWithoutCoupon_redemptionsInput, SubscriptionUncheckedUpdateWithoutCoupon_redemptionsInput>
    create: XOR<SubscriptionCreateWithoutCoupon_redemptionsInput, SubscriptionUncheckedCreateWithoutCoupon_redemptionsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutCoupon_redemptionsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutCoupon_redemptionsInput, SubscriptionUncheckedUpdateWithoutCoupon_redemptionsInput>
  }

  export type SubscriptionUpdateWithoutCoupon_redemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutSubscription_recordNestedInput
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    discount?: DiscountUpdateOneWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutCoupon_redemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    discount_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationUncheckedCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingUncheckedCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleUncheckedCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    notification_prefs?: NotificationPreferenceUncheckedCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type NotificationTemplateCreateWithoutNotificationsInput = {
    id: string
    name: string
    channel: $Enums.NotificationTemplateChannel
    subject?: string | null
    body_template: string
    title_template?: string | null
    variables?: NotificationTemplateCreatevariablesInput | string[]
    version?: number
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationTemplateUncheckedCreateWithoutNotificationsInput = {
    id: string
    name: string
    channel: $Enums.NotificationTemplateChannel
    subject?: string | null
    body_template: string
    title_template?: string | null
    variables?: NotificationTemplateCreatevariablesInput | string[]
    version?: number
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationTemplateCreateOrConnectWithoutNotificationsInput = {
    where: NotificationTemplateWhereUniqueInput
    create: XOR<NotificationTemplateCreateWithoutNotificationsInput, NotificationTemplateUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUncheckedUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUncheckedUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUncheckedUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    notification_prefs?: NotificationPreferenceUncheckedUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NotificationTemplateUpsertWithoutNotificationsInput = {
    update: XOR<NotificationTemplateUpdateWithoutNotificationsInput, NotificationTemplateUncheckedUpdateWithoutNotificationsInput>
    create: XOR<NotificationTemplateCreateWithoutNotificationsInput, NotificationTemplateUncheckedCreateWithoutNotificationsInput>
    where?: NotificationTemplateWhereInput
  }

  export type NotificationTemplateUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: NotificationTemplateWhereInput
    data: XOR<NotificationTemplateUpdateWithoutNotificationsInput, NotificationTemplateUncheckedUpdateWithoutNotificationsInput>
  }

  export type NotificationTemplateUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationTemplateChannelFieldUpdateOperationsInput | $Enums.NotificationTemplateChannel
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body_template?: StringFieldUpdateOperationsInput | string
    title_template?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTemplateUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationTemplateChannelFieldUpdateOperationsInput | $Enums.NotificationTemplateChannel
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body_template?: StringFieldUpdateOperationsInput | string
    title_template?: NullableStringFieldUpdateOperationsInput | string | null
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateWithoutTemplateInput = {
    id: string
    channel: $Enums.NotificationChannel
    payload: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    provider_id?: string | null
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id: string
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutTemplateInput = {
    id: string
    target_user_id: string
    channel: $Enums.NotificationChannel
    payload: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    provider_id?: string | null
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id: string
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationCreateOrConnectWithoutTemplateInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTemplateInput, NotificationUncheckedCreateWithoutTemplateInput>
  }

  export type NotificationCreateManyTemplateInputEnvelope = {
    data: NotificationCreateManyTemplateInput | NotificationCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type NotificationUpsertWithWhereUniqueWithoutTemplateInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutTemplateInput, NotificationUncheckedUpdateWithoutTemplateInput>
    create: XOR<NotificationCreateWithoutTemplateInput, NotificationUncheckedCreateWithoutTemplateInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutTemplateInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutTemplateInput, NotificationUncheckedUpdateWithoutTemplateInput>
  }

  export type NotificationUpdateManyWithWhereWithoutTemplateInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutTemplateInput>
  }

  export type UserCreateWithoutNotification_prefsInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotification_prefsInput = {
    id: string
    name: string
    email: string
    provider_id: string
    photo_url?: string | null
    onboarding_completed?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationUncheckedCreateNestedOneWithoutOwnerInput
    bookings_as_owner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    bookings_as_client?: BookingUncheckedCreateNestedManyWithoutClientInput
    booking_rules?: BookingRuleUncheckedCreateNestedManyWithoutUserInput
    booking_exceptions?: BookingExceptionUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    coupon_redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    customer_profiles?: CustomerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotification_prefsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotification_prefsInput, UserUncheckedCreateWithoutNotification_prefsInput>
  }

  export type UserUpsertWithoutNotification_prefsInput = {
    update: XOR<UserUpdateWithoutNotification_prefsInput, UserUncheckedUpdateWithoutNotification_prefsInput>
    create: XOR<UserCreateWithoutNotification_prefsInput, UserUncheckedCreateWithoutNotification_prefsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotification_prefsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotification_prefsInput, UserUncheckedUpdateWithoutNotification_prefsInput>
  }

  export type UserUpdateWithoutNotification_prefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotification_prefsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    photo_url?: NullableStringFieldUpdateOperationsInput | string | null
    onboarding_completed?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUncheckedUpdateOneWithoutOwnerNestedInput
    bookings_as_owner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    bookings_as_client?: BookingUncheckedUpdateManyWithoutClientNestedInput
    booking_rules?: BookingRuleUncheckedUpdateManyWithoutUserNestedInput
    booking_exceptions?: BookingExceptionUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    customer_profiles?: CustomerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingCreateManyOwnerInput = {
    id: string
    client_id: string
    unit_id: string
    service_id?: string | null
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingCreateManyClientInput = {
    id: string
    user_id: string
    unit_id: string
    service_id?: string | null
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingRuleCreateManyUserInput = {
    id: string
    type: $Enums.BookingRuleType
    weekday?: number | null
    date?: string | null
    start_time: Date | string
    end_time: Date | string
    slot_duration_minutes: number
    min_advance_minutes?: number | null
    max_duration_minutes?: number | null
    max_bookings_per_day?: number | null
    max_bookings_per_client_per_day?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingExceptionCreateManyUserInput = {
    id: string
    date: string
    type: $Enums.BookingExceptionType
    start_time?: Date | string | null
    end_time?: Date | string | null
    slot_duration_minutes?: number | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionCreateManyUserInput = {
    id: string
    unit_id: string
    plan_id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    discount_id?: string | null
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceCreateManyUserInput = {
    id: string
    subscription_id: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    line_items: JsonNullValueInput | InputJsonValue
    due_date: Date | string
    paid_at?: Date | string | null
    provider_invoice_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CouponRedemptionCreateManyUserInput = {
    id: string
    coupon_id: string
    subscription_id: string
    redeemed_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id: string
    channel: $Enums.NotificationChannel
    template_id: string
    payload: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    provider_id?: string | null
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id: string
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationPreferenceCreateManyUserInput = {
    id: string
    category: $Enums.NotificationPreferenceCategory
    channels: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerCreateManyUserInput = {
    id: string
    unit_id: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutBookings_as_clientNestedInput
    unit?: UnitUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutBookings_as_ownerNestedInput
    unit?: UnitUpdateOneRequiredWithoutBookingsNestedInput
    service?: ServiceUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRuleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingRuleTypeFieldUpdateOperationsInput | $Enums.BookingRuleType
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    slot_duration_minutes?: IntFieldUpdateOperationsInput | number
    min_advance_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    max_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    max_bookings_per_day?: NullableIntFieldUpdateOperationsInput | number | null
    max_bookings_per_client_per_day?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRuleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingRuleTypeFieldUpdateOperationsInput | $Enums.BookingRuleType
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    slot_duration_minutes?: IntFieldUpdateOperationsInput | number
    min_advance_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    max_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    max_bookings_per_day?: NullableIntFieldUpdateOperationsInput | number | null
    max_bookings_per_client_per_day?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRuleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingRuleTypeFieldUpdateOperationsInput | $Enums.BookingRuleType
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    slot_duration_minutes?: IntFieldUpdateOperationsInput | number
    min_advance_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    max_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    max_bookings_per_day?: NullableIntFieldUpdateOperationsInput | number | null
    max_bookings_per_client_per_day?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingExceptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingExceptionTypeFieldUpdateOperationsInput | $Enums.BookingExceptionType
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slot_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingExceptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingExceptionTypeFieldUpdateOperationsInput | $Enums.BookingExceptionType
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slot_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingExceptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    type?: EnumBookingExceptionTypeFieldUpdateOperationsInput | $Enums.BookingExceptionType
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slot_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutSubscription_recordNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    discount?: DiscountUpdateOneWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    discount_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    discount_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    line_items?: JsonNullValueInput | InputJsonValue
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscription_id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    line_items?: JsonNullValueInput | InputJsonValue
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscription_id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    line_items?: JsonNullValueInput | InputJsonValue
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coupon_id?: StringFieldUpdateOperationsInput | string
    redeemed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutCoupon_redemptionsNestedInput
  }

  export type CouponRedemptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coupon_id?: StringFieldUpdateOperationsInput | string
    subscription_id?: StringFieldUpdateOperationsInput | string
    redeemed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coupon_id?: StringFieldUpdateOperationsInput | string
    subscription_id?: StringFieldUpdateOperationsInput | string
    redeemed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    payload?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: NotificationTemplateUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    template_id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    template_id?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumNotificationPreferenceCategoryFieldUpdateOperationsInput | $Enums.NotificationPreferenceCategory
    channels?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumNotificationPreferenceCategoryFieldUpdateOperationsInput | $Enums.NotificationPreferenceCategory
    channels?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationPreferenceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumNotificationPreferenceCategoryFieldUpdateOperationsInput | $Enums.NotificationPreferenceCategory
    channels?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateManyOrganizationInput = {
    id: string
    name: string
    brand_color: string
    logo?: string | null
    gallery?: UnitCreategalleryInput | string[]
    is_active?: boolean
    whatsapp: string
    phone?: string | null
    address: JsonNullValueInput | InputJsonValue
    especialidades: JsonNullValueInput | InputJsonValue
    services: JsonNullValueInput | InputJsonValue
    service_type?: $Enums.ServiceType
    amenities?: UnitCreateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_specialties?: UnitSpecialtyUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUpdateOneWithoutUnitNestedInput
    bookings?: BookingUpdateManyWithoutUnitNestedInput
    customers?: CustomerUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_specialties?: UnitSpecialtyUncheckedUpdateManyWithoutUnitNestedInput
    unit_services?: UnitServiceUncheckedUpdateManyWithoutUnitNestedInput
    unit_amenities?: UnitAmenityUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_rules?: UnitAvailabilityRuleUncheckedUpdateManyWithoutUnitNestedInput
    unit_availability_exceptions?: UnitAvailabilityExceptionUncheckedUpdateManyWithoutUnitNestedInput
    subscription_record?: SubscriptionUncheckedUpdateOneWithoutUnitNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUnitNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand_color?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    gallery?: UnitUpdategalleryInput | string[]
    is_active?: BoolFieldUpdateOperationsInput | boolean
    whatsapp?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: JsonNullValueInput | InputJsonValue
    especialidades?: JsonNullValueInput | InputJsonValue
    services?: JsonNullValueInput | InputJsonValue
    service_type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    amenities?: UnitUpdateamenitiesInput | string[]
    subscription?: NullableJsonNullValueInput | InputJsonValue
    working_hours?: NullableJsonNullValueInput | InputJsonValue
    lunch_break?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitSpecialtyCreateManyUnitInput = {
    id: string
    specialty_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitServiceCreateManyUnitInput = {
    id: string
    service_id: string
    custom_price_cents?: number | null
    custom_duration_minutes?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAmenityCreateManyUnitInput = {
    id: string
    amenity_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAvailabilityRuleCreateManyUnitInput = {
    id: string
    type: $Enums.UnitAvailabilityRuleType
    weekday?: number | null
    date?: string | null
    start_time: string
    end_time: string
    slot_duration_minutes: number
    is_active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAvailabilityExceptionCreateManyUnitInput = {
    id: string
    date: string
    type: $Enums.UnitAvailabilityExceptionType
    start_time?: string | null
    end_time?: string | null
    slot_duration_minutes?: number | null
    reason?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingCreateManyUnitInput = {
    id: string
    user_id: string
    client_id: string
    service_id?: string | null
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerCreateManyUnitInput = {
    id: string
    user_id: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitSpecialtyUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    specialty?: SpecialtyUpdateOneRequiredWithoutUnit_specialtiesNestedInput
  }

  export type UnitSpecialtyUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialty_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitSpecialtyUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialty_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitServiceUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    custom_price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    custom_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutUnit_servicesNestedInput
  }

  export type UnitServiceUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    custom_price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    custom_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitServiceUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    custom_price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    custom_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAmenityUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    amenity?: AmenityUpdateOneRequiredWithoutUnit_amenitiesNestedInput
  }

  export type UnitAmenityUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    amenity_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAmenityUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    amenity_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAvailabilityRuleUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumUnitAvailabilityRuleTypeFieldUpdateOperationsInput | $Enums.UnitAvailabilityRuleType
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    slot_duration_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAvailabilityRuleUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumUnitAvailabilityRuleTypeFieldUpdateOperationsInput | $Enums.UnitAvailabilityRuleType
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    slot_duration_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAvailabilityRuleUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumUnitAvailabilityRuleTypeFieldUpdateOperationsInput | $Enums.UnitAvailabilityRuleType
    weekday?: NullableIntFieldUpdateOperationsInput | number | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: StringFieldUpdateOperationsInput | string
    end_time?: StringFieldUpdateOperationsInput | string
    slot_duration_minutes?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAvailabilityExceptionUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    type?: EnumUnitAvailabilityExceptionTypeFieldUpdateOperationsInput | $Enums.UnitAvailabilityExceptionType
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    slot_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAvailabilityExceptionUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    type?: EnumUnitAvailabilityExceptionTypeFieldUpdateOperationsInput | $Enums.UnitAvailabilityExceptionType
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    slot_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAvailabilityExceptionUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    type?: EnumUnitAvailabilityExceptionTypeFieldUpdateOperationsInput | $Enums.UnitAvailabilityExceptionType
    start_time?: NullableStringFieldUpdateOperationsInput | string | null
    end_time?: NullableStringFieldUpdateOperationsInput | string | null
    slot_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutBookings_as_ownerNestedInput
    client?: UserUpdateOneRequiredWithoutBookings_as_clientNestedInput
    service?: ServiceUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    service_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCustomer_profilesNestedInput
  }

  export type CustomerUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManySpecialtyInput = {
    id: string
    code: string
    name: string
    description?: string | null
    default_duration_minutes: number
    default_price_cents: number
    is_predefined?: boolean
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitSpecialtyCreateManySpecialtyInput = {
    id: string
    unit_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ServiceUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    default_duration_minutes?: IntFieldUpdateOperationsInput | number
    default_price_cents?: IntFieldUpdateOperationsInput | number
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_services?: UnitServiceUpdateManyWithoutServiceNestedInput
    bookings?: BookingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    default_duration_minutes?: IntFieldUpdateOperationsInput | number
    default_price_cents?: IntFieldUpdateOperationsInput | number
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit_services?: UnitServiceUncheckedUpdateManyWithoutServiceNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    default_duration_minutes?: IntFieldUpdateOperationsInput | number
    default_price_cents?: IntFieldUpdateOperationsInput | number
    is_predefined?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitSpecialtyUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutUnit_specialtiesNestedInput
  }

  export type UnitSpecialtyUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitSpecialtyUncheckedUpdateManyWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAmenityCreateManyAmenityInput = {
    id: string
    unit_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitAmenityUpdateWithoutAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutUnit_amenitiesNestedInput
  }

  export type UnitAmenityUncheckedUpdateWithoutAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitAmenityUncheckedUpdateManyWithoutAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitServiceCreateManyServiceInput = {
    id: string
    unit_id: string
    custom_price_cents?: number | null
    custom_duration_minutes?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BookingCreateManyServiceInput = {
    id: string
    user_id: string
    client_id: string
    unit_id: string
    price_cents?: number | null
    notes?: string | null
    start_at: Date | string
    end_at: Date | string
    status?: $Enums.BookingStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UnitServiceUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    custom_price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    custom_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutUnit_servicesNestedInput
  }

  export type UnitServiceUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    custom_price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    custom_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    custom_price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    custom_duration_minutes?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutBookings_as_ownerNestedInput
    client?: UserUpdateOneRequiredWithoutBookings_as_clientNestedInput
    unit?: UnitUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    price_cents?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    start_at?: DateTimeFieldUpdateOperationsInput | Date | string
    end_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyPlanInput = {
    id: string
    unit_id: string
    user_id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    discount_id?: string | null
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutSubscription_recordNestedInput
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    discount?: DiscountUpdateOneWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    discount_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    discount_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManySubscriptionInput = {
    id: string
    user_id: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    line_items: JsonNullValueInput | InputJsonValue
    due_date: Date | string
    paid_at?: Date | string | null
    provider_invoice_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CouponRedemptionCreateManySubscriptionInput = {
    id: string
    coupon_id: string
    user_id: string
    redeemed_at?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    line_items?: JsonNullValueInput | InputJsonValue
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    line_items?: JsonNullValueInput | InputJsonValue
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    line_items?: JsonNullValueInput | InputJsonValue
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    coupon_id?: StringFieldUpdateOperationsInput | string
    redeemed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoupon_redemptionsNestedInput
  }

  export type CouponRedemptionUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    coupon_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    redeemed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    coupon_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    redeemed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyDiscountInput = {
    id: string
    unit_id: string
    user_id: string
    plan_id: string
    status: $Enums.SubscriptionStatus
    start_date: Date | string
    current_period_start: Date | string
    current_period_end: Date | string
    cancel_at_period_end?: boolean
    canceled_at?: Date | string | null
    trial_end?: Date | string | null
    renewal_interval: $Enums.RenewalInterval
    provider_subscription_id?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUpdateWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutSubscription_recordNestedInput
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    invoices?: InvoiceUpdateManyWithoutSubscriptionNestedInput
    coupon_redemptions?: CouponRedemptionUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutSubscriptionNestedInput
    coupon_redemptions?: CouponRedemptionUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    unit_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    plan_id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_start?: DateTimeFieldUpdateOperationsInput | Date | string
    current_period_end?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_at_period_end?: BoolFieldUpdateOperationsInput | boolean
    canceled_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trial_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewal_interval?: EnumRenewalIntervalFieldUpdateOperationsInput | $Enums.RenewalInterval
    provider_subscription_id?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyTemplateInput = {
    id: string
    target_user_id: string
    channel: $Enums.NotificationChannel
    payload: JsonNullValueInput | InputJsonValue
    priority?: $Enums.NotificationPriority
    status?: $Enums.NotificationStatus
    provider_id?: string | null
    error_message?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id: string
    sent_at?: Date | string | null
    delivered_at?: Date | string | null
    read_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    payload?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_user_id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    payload?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    target_user_id?: StringFieldUpdateOperationsInput | string
    channel?: EnumNotificationChannelFieldUpdateOperationsInput | $Enums.NotificationChannel
    payload?: JsonNullValueInput | InputJsonValue
    priority?: EnumNotificationPriorityFieldUpdateOperationsInput | $Enums.NotificationPriority
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    message_id?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delivered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}